{"meta":{"title":"乐行僧的博客","subtitle":"","description":"","author":"lexingsen","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-11-29T17:10:39.000Z","updated":"2020-11-29T17:10:39.199Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-11-29T16:23:08.000Z","updated":"2020-11-29T18:12:13.402Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-29T17:10:43.000Z","updated":"2020-11-29T17:10:43.999Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线性代数：求A^n","slug":"线性代数：求A^n","date":"2020-11-28T01:55:07.000Z","updated":"2020-11-29T19:35:16.847Z","comments":true,"path":"2020/11/28/线性代数：求A^n/","link":"","permalink":"http://example.com/2020/11/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%9A%E6%B1%82A^n/","excerpt":"","text":"","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"clang -Xclang -ast-print -fsyntax-only main.cc ＞ main-init.cc","slug":"clang -Xclang -ast-print -fsyntax-only main.cc ＞ main-init.cc","date":"2020-11-24T23:12:36.000Z","updated":"2020-11-29T19:35:16.899Z","comments":true,"path":"2020/11/25/clang -Xclang -ast-print -fsyntax-only main.cc ＞ main-init.cc/","link":"","permalink":"http://example.com/2020/11/25/clang%20-Xclang%20-ast-print%20-fsyntax-only%20main.cc%20%EF%BC%9E%20main-init.cc/","excerpt":"","text":"分析C++泛型编程代码的利器，生成实例化后的代码！！！ 如下面我们编写计算斐波那契数列的元函数： 12345678910111213141516171819template &lt;int N&gt;struct Fib &#123; enum &#123;Value = Fib&lt;N-1&gt;::Value + Fib&lt;N-2&gt;::Value&#125;;&#125;;template&lt;&gt;struct Fib&lt;1&gt; &#123; enum &#123;Value = 1&#125;;&#125;;template&lt;&gt;struct Fib&lt;2&gt; &#123; enum &#123;Value = 1&#125;;&#125;;int main() &#123; Fib&lt;20&gt;::Value; return 0;&#125; 鼠标指针放到Fib&lt;20&gt;::Value;上，观察编译期的结果： 使用clang工具生成实例化的模板文件: 命令格式：clang -Xclang -ast-print -fsyntax-only main.cc ＞ main-init.cc其中输入文件为main.cc 输出文件为main-init.cc 生成的文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112main-init.cctemplate &lt;int N&gt; struct Fib &#123; enum &#123; Value = Fib&lt;N - 1&gt;::Value + Fib&lt;N - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;20&gt; &#123; enum &#123; Value = Fib&lt;20 - 1&gt;::Value + Fib&lt;20 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;19&gt; &#123; enum &#123; Value = Fib&lt;19 - 1&gt;::Value + Fib&lt;19 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;18&gt; &#123; enum &#123; Value = Fib&lt;18 - 1&gt;::Value + Fib&lt;18 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;17&gt; &#123; enum &#123; Value = Fib&lt;17 - 1&gt;::Value + Fib&lt;17 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;16&gt; &#123; enum &#123; Value = Fib&lt;16 - 1&gt;::Value + Fib&lt;16 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;15&gt; &#123; enum &#123; Value = Fib&lt;15 - 1&gt;::Value + Fib&lt;15 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;14&gt; &#123; enum &#123; Value = Fib&lt;14 - 1&gt;::Value + Fib&lt;14 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;13&gt; &#123; enum &#123; Value = Fib&lt;13 - 1&gt;::Value + Fib&lt;13 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;12&gt; &#123; enum &#123; Value = Fib&lt;12 - 1&gt;::Value + Fib&lt;12 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;11&gt; &#123; enum &#123; Value = Fib&lt;11 - 1&gt;::Value + Fib&lt;11 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;10&gt; &#123; enum &#123; Value = Fib&lt;10 - 1&gt;::Value + Fib&lt;10 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;9&gt; &#123; enum &#123; Value = Fib&lt;9 - 1&gt;::Value + Fib&lt;9 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;8&gt; &#123; enum &#123; Value = Fib&lt;8 - 1&gt;::Value + Fib&lt;8 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;7&gt; &#123; enum &#123; Value = Fib&lt;7 - 1&gt;::Value + Fib&lt;7 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;6&gt; &#123; enum &#123; Value = Fib&lt;6 - 1&gt;::Value + Fib&lt;6 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;5&gt; &#123; enum &#123; Value = Fib&lt;5 - 1&gt;::Value + Fib&lt;5 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;4&gt; &#123; enum &#123; Value = Fib&lt;4 - 1&gt;::Value + Fib&lt;4 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;3&gt; &#123; enum &#123; Value = Fib&lt;3 - 1&gt;::Value + Fib&lt;3 - 2&gt;::Value &#125;;&#125;;template&lt;&gt; struct Fib&lt;1&gt; &#123; enum &#123; Value = 1 &#125;;&#125;;template&lt;&gt; struct Fib&lt;2&gt; &#123; enum &#123; Value = 1 &#125;;&#125;;int main() &#123; Fib&lt;20&gt;::Value; return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"C++11-关键字集合","slug":"C++11-关键字集合","date":"2020-11-22T14:54:05.000Z","updated":"2020-11-29T19:35:16.847Z","comments":true,"path":"2020/11/22/C++11-关键字集合/","link":"","permalink":"http://example.com/2020/11/22/C++11-%E5%85%B3%E9%94%AE%E5%AD%97%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++STL-vector实现 空间配置器","slug":"C++STL-vector实现 空间配置器","date":"2020-11-22T01:18:56.000Z","updated":"2020-11-29T19:35:16.927Z","comments":true,"path":"2020/11/22/C++STL-vector实现 空间配置器/","link":"","permalink":"http://example.com/2020/11/22/C++STL-vector%E5%AE%9E%E7%8E%B0%20%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/","excerpt":"","text":"一、没有空间配置器的vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;template &lt;typename T&gt;class vector &#123;private: T *_first; T *_last; T *_end;public: vector(int size=10) &#123; _first = new T[size]; _end = _first+size; _last = _first; &#125; vector(const vector&lt;T&gt;&amp; src) &#123; int size=src._end - src._first; _first = new T[size]; int len = _last-_first; for (int i=0; i&lt;len; ++i) &#123; _first[i] = src._first[i]; &#125; _last = _first + len; _end = _first + size; &#125; vector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; src) &#123; if (this == &amp;src) &#123; return *this; &#125; delete[] _first; int size = src._end - src._first; int len = src._last - src._first; _first = new T[size]; for (int i=0; i&lt;len; ++i) &#123; _first[i] = src._first[i]; &#125; _last = _first + len; _end = _first + size; return *this; &#125; ~vector() &#123; delete[] _first; _first = _last = _end = nullptr; &#125; void push_back(const T &amp;x) &#123; if (full()) &#123; resize(); &#125; *_last ++ = x; &#125; void pop_back() &#123; if (empty()) &#123; return; &#125; -- _last; &#125; T back() const &#123; if (empty()) &#123; &#125; return *(_last-1); &#125; bool full() &#123; return _end == _last; &#125; bool empty() &#123; return _last == _first; &#125; void resize() &#123; int size=_end-_first; T *tmp = new T[2*size]; int len = _last-_first; for(int i=0; i&lt;len; ++i) &#123; tmp[i] = _first[i]; &#125; delete[] _first; _first = tmp; _end = _first + 2*size; _last = _first + len; &#125;&#125;;struct Test &#123; Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test(const Test &amp;t) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; cout &lt;&lt; &quot;operator=(const Test&amp;)&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Test t1; Test t2; vector&lt;Test&gt; vec; vec.push_back(t1); vec.push_back(t2); cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl; vec.pop_back(); cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl; return 0;&#125; 执行结果： 通过观察打印结果，得到一下几个存在的问题？1.vector中什么元素都没有，居然就进行了10次构造？按道理，没有push_back进去元素，我们只需要申请初始空间即可，不需要进行构造。2.pop_back推出vector尾部的元素时，没有进行析构，如果此时vector的元素为对象并且持有堆资源，那么就会造成内存的泄露？3.pop_back推出尾部元素时，只需要析构该位置的元素即可，不需要释放空间？空间的释放时机是vector对象生命周期结束时造成上述结果的缘由：1.vector的构造函数直接使用了new，包含两个动作，开辟空间和调用构造函数进行构造。2.pop_back时，直接 –_last，没有进行该位置对象的析构。但是如果单纯的使用delete，不仅不会调用析构函数析构该位置的对象，还会删除该位置的内存。综上：本质的问题就是new没有将开辟内存和构造对象这两个操作步骤分离开来。delete没有将析构对象和释放内存这两个操作分离开来。 二、增加空间配置器的vector为了解决上述存在的问题，将开辟内存、释放内存、析构对象和构造对象四个步骤分离开来，抽象成一个空间配置器，是的上边四个操作每一个都是互不干涉，相互独立的操作。 空间配置器 12345678910111213141516171819template &lt;typename T&gt;struct Allocator &#123; // 开辟内存 T* allocate(size_t size) &#123; return (T*)malloc(sizeof(T)*size); &#125; // 释放内存 void deallocate(T *p) &#123; free(p); &#125; // 构造对象，这里使用定位new void construct(T *p, const T&amp; x) &#123; new (p) T(x); &#125; // 析构对象 void destoy(T *p) &#123; p-&gt;~T(); &#125;&#125;; 增加空间配置器的vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138template &lt;typename T, typename Alloc=Allocator&lt;T&gt;&gt;class vector &#123;private: T *_first; T *_last; T *_end; Alloc _allocator; // 增加空间配置器成员处理vector成员 内存开辟 内存释放 对象构造 对象析构 public: vector(int size=10) &#123; // _first = new T[size]; _first = _allocator.allocate(size); // 仅仅开辟内存 _end = _first+size; _last = _first; &#125; vector(const vector&lt;T&gt;&amp; src) &#123; int size=src._end - src._first; // _first = new T[size]; _first = _allocator.allocate(size); int len = _last-_first; for (int i=0; i&lt;len; ++i) &#123; // _first[i] = src._first[i]; _allocator.construct(_first[i], src._first[i]); // 构造对象 &#125; _last = _first + len; _end = _first + size; &#125; vector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; src) &#123; if (this == &amp;src) &#123; return *this; &#125; delete[] _first; int size = src._end - src._first; int len = src._last - src._first; _first = new T[size]; for (int i=0; i&lt;len; ++i) &#123; _first[i] = src._first[i]; &#125; _last = _first + len; _end = _first + size; return *this; &#125; ~vector() &#123; // delete[] _first; 1.首先析构有效的对象元素 2.释放空间 int len = _last - _first; for (T* p=_first; p!=_last; ++p) &#123; _allocator.destroy(p);// 析构有效对象 &#125; _allocator.deallocate(_first); // 释放内存 _first = _last = _end = nullptr; &#125; void push_back(const T &amp;x) &#123; if (full()) &#123; resize(); &#125; // *_last ++ = x; _allocator.construct(_last, x); _last ++; &#125; void pop_back() &#123; if (empty()) &#123; return; &#125; -- _last; _allocator.destroy(_last); &#125; T back() const &#123; if (empty()) &#123; &#125; return *(_last-1); &#125; bool full() &#123; return _end == _last; &#125; bool empty() &#123; return _last == _first; &#125; void resize() &#123; int size=_end-_first; // T *tmp = new T[2*size]; T* tmp = _allocator.allocate(2*size); int len = _last-_first; for(int i=0; i&lt;len; ++i) &#123; _allocator.construct(tmp+i, _first[i]); &#125; // delete[] _first; for (T *p=_first; p!=_last; ++p) &#123; _allocator.destroy(p); &#125; _allocator.deallocate(_first); _first = tmp; _end = _first + 2*size; _last = _first + len; &#125;&#125;;struct Test &#123; Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test(const Test &amp;t) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; cout &lt;&lt; &quot;operator=(const Test&amp;)&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Test t1; Test t2; vector&lt;Test&gt; vec; vec.push_back(t1); vec.push_back(t2); cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl; vec.pop_back(); cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl; return 0;&#125; 执行结果：观察执行结果，增加空间配置器的vector完全按照预期。内存开辟和释放，对象构造和析构完全分离开来，至此，简易的vector已经实现了。 三、增加带右值引用的push_back，进一步提高效率，旨在优化构造对象的背后调用函数的开销。 1234567891011121314template &lt;typename Ty&gt;void push_back(Ty &amp;&amp;x) &#123; if (full()) &#123; resize(); &#125; _allocator.constuct(_last, std::forward&lt;Ty&gt;(x));&#125;对应的空间配置器中的对象构造template &lt;typename Ty&gt;void construct(T *p, Ty &amp;&amp;x) &#123; new (p) T(std::forward&lt;Ty&gt;(x));&#125; 需要注意的是模板类Test中需要实现，带右值引用的拷贝构造函数和赋值运算符重载函数。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"C++11-forward&move&引用折叠","slug":"C++11-forward&move&引用折叠","date":"2020-11-21T23:22:31.000Z","updated":"2020-11-29T19:35:16.875Z","comments":true,"path":"2020/11/22/C++11-forward&move&引用折叠/","link":"","permalink":"http://example.com/2020/11/22/C++11-forward&move&%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0/","excerpt":"","text":"一、moveC++11引入了右值引用，方便处理临时对象，临时量，没有内存的值，字面量等。早在之前的常引用也可对对左值引用，但是仅仅能够提升左值的生命周期，不能对其进行修改。 123456const int&amp; a=10;/*int tmp=10;const int&amp; a=tmp;但是这里的a所引用的值是不能被修改的*/ C++11，提出右值引用。不仅能够提升临时量的声明周期，还能够对临时进行修改。 12345int &amp;&amp;d=10;/*int tmp=10;int &amp;&amp;d=tmp;*/ tips：右值引用变量本身是一个左值。在实际开发中，当我们需要对一个左值进行操作时间，函数参数会写成这种形式T &amp;&amp; x，但是在函数内部，由于右值引用变量本身还是一个左值，此时操作x，x还是被认为是一个左值。但是我们需要x是一个右值，如何处理呢？C++11提出了std::move移动语义，将x强制转换为一个右值，方便后序的处理！！！下面是move的源码实现： 1234template&lt;typename _Tp&gt;constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; 通过源码可以看到，move实际上做的事情就是进行强制转换，强制转换为一个右值。如在vector的push_back操作中 1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;typename T&gt;struct Allocator &#123; T* allocate(size_t size) &#123; return (T*)malloc(size * T); &#125; void deallocate(T *p) &#123; free(p); &#125; /* void construct(T *p, const T &amp;x) &#123; new (p) T(val); &#125; void construct(T *p, T &amp;&amp;x) &#123; new (p) T(std::move(val)); &#125; */ // 统一处理 template &lt;typename Ty&gt; void construct (T *p, Ty &amp;&amp;x) &#123; new (p) T(std::forward&lt;Ty&gt;(x)); &#125; void destruct(T *p) &#123; p-&gt;~T(); &#125;&#125;;void push_back(T &amp;&amp;x) &#123; if (full()) &#123; resize(); &#125; /* 这样调用，x认为是一个左值，直接调用构造函数 而事实上，我们希望x是一个右值，去调用带有右值的构造函数 */ // _allocator.construct(x); // 修改一下 // 使用std::move()强制转换为右值，便可调用带右值的构造函数 _allocator.construct(_last, std::move(x)); &#125; 二、forward个人理解forward的产生一方面是为了配和右值引用的使用，另一方面是为了更好的进行模板编程。这里还是要提一句，左值引用变量本身是一个右值，这样就造成了一个事实。如下： 1234567891011121314151617void construct(T *p, const T &amp;x) &#123;&#125;void construct(T *p, T &amp;&amp;x) &#123;&#125;void push_back(const T &amp;x) &#123;... construct(x);&#125;void push_back(T &amp;&amp;x) &#123;... construct(x);&#125; 不管是实际参数传入的是一个左值还是右值，都会被当成左值处理。 123456struct Test &#123;&#125;;Test t1;push_back(t1); // t1本身就是左值一定会调用 push_back(const T&amp;)push_back(Test());// Test()是一个临时对象，是右值，调用push_back(T &amp;&amp;x)// 但是在push_back函数内部x还是被当作了一个右值// 最终他们都是调用construct(T *p, const T&amp; x) 为了解决上述问题，C++11提出了forward类型的完美转发。使用函数模板类型推演+引用折叠是的左值引用参数和右值引用参数函数得到统一化。 12345template &lt;typename Ty&gt;void push_back(Ty &amp;&amp;x) &#123; .... _allocator.construt(_last, std::forward&lt;Ty&gt;(x));&#125; 引用折叠T&amp; + &amp;&amp; = T&amp;T&amp;&amp; + &amp;&amp; = T&amp;&amp;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"带右值引用的拷贝构造函数和运算符重载函数","slug":"带右值引用的拷贝构造函数和运算符重载函数","date":"2020-11-21T17:54:50.000Z","updated":"2020-11-29T19:35:16.883Z","comments":true,"path":"2020/11/22/带右值引用的拷贝构造函数和运算符重载函数/","link":"","permalink":"http://example.com/2020/11/22/%E5%B8%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/","excerpt":"","text":"考虑一个占用堆资源类对象的拷贝构造和赋值运算符重载函数，当我们用一个临时对象去拷贝构造一个新对象或者赋值给一个已经存在的对象时，会出现一下的问题：如string类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyString &#123;private: char *mptr;public: MyString(const char *src = nullptr) &#123; cout &lt;&lt; &quot;MyString(const char*)&quot; &lt;&lt; endl; if (src != nullptr) &#123; mptr = new char[strlen(src) + 1]; strcpy(mptr, src); &#125; else &#123; mptr = new char[1]; *mptr = &#x27;\\0&#x27;; &#125; &#125; MyString(const MyString&amp; src) &#123; cout &lt;&lt; &quot;MyString(const MyString&amp;)&quot; &lt;&lt; endl; mptr = new char[strlen(src.mptr) + 1]; strcpy(mptr, src.mptr); &#125; MyString&amp; operator=(const MyString&amp; src) &#123; cout &lt;&lt; &quot;operator=(const MyString&amp;)&quot; &lt;&lt; endl; if (this == &amp;src) &#123; return *this; &#125; delete[] mptr; mptr = new char[strlen(src.mptr) + 1]; strcpy(mptr, src.mptr); return *this; &#125; ~MyString() &#123; cout &lt;&lt; &quot;~MyString()&quot; &lt;&lt; endl; delete[] mptr; mptr = nullptr; &#125; const char* c_str() const &#123; return mptr; &#125;&#125;;MyString getString(MyString &amp;s) &#123; const char* t = s.c_str(); MyString res(t); return res;&#125;int main() &#123; MyString s1(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); MyString s2; s2 = getString(s1); return 0;&#125; 1.当我们用临时对象去拷贝构造一个新对象时。MyString res = MyString(“aaaa”);显然，这样做很不合理，很浪费！！！你临时对象用完就析构了，还不如直接给我新对象用，避免开辟新空间，避免拷贝！！！到这里就引出了第一个主题，带右值引用的拷贝构造函数。因为临时对象是右值。临时对象用完就要析构的，那就把临时对象占用的资源直接给新对象就好了。这样做一方面避免了在原来拷贝构造函数需要首先申请空间，然后进行拷贝的麻烦。另一方面避免临时对象析构时还有释放堆资源的麻烦，一举两得！！！ 1234MyString(MyString &amp;&amp;src) &#123; mptr = src.mptr; src.mptr = nullptr;&#125; 2.当我们用临时对象去赋值一个已经存在的对象时。这里指的对象都是持有堆资源的对象。首先，被赋值的对象要释放自己占用的堆资源，然后申请一个和临时对象指向堆资源一摸一样大小的空间，之后将临时对象指向堆空间的内容拷贝到自己的堆空间中。这里同样存在着上边的问题，我临时对象给你赋值完我就析构了，堆资源也在析构函数中被释放了，但是你被赋值的对象还得申请空间，还得拷贝，你直接用临时对象的那块堆资源不就好了。问题就处在临时对象赋值完就析构了，与其白白浪费，不如拿来直接使用，有点“偷”的感觉！！！ 123456789MyString&amp; opeator=(MyString &amp;&amp;s) &#123; if (this == &amp;s) &#123; return *this; &#125; delete[] mptr; mptr = s.mptr; s.mptr = nullptr; return *this;&#125; 结论：至此，通过一个例子我们总结出了带右值引用的拷贝构造函数和运算符重载函数所带来效率的提升，以及为什么可以这样处理的原因。在实际开发中，当出现一定要用临时对象作为返回值，要用临时来进行赋值时，我们可以为其类实现带右值引用的拷贝构造函数和运算符重载函数，在程序的效率上会得到很大的提升。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++ c++11","slug":"c-c-11","permalink":"http://example.com/tags/c-c-11/"}]},{"title":"面试22.栈的压入、弹出","slug":"面试22.栈的压入、弹出","date":"2020-11-21T15:26:26.000Z","updated":"2020-11-29T19:35:16.863Z","comments":true,"path":"2020/11/21/面试22.栈的压入、弹出/","link":"","permalink":"http://example.com/2020/11/21/%E9%9D%A2%E8%AF%9522.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/","excerpt":"","text":"题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 样例1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 样例2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出 方法：使用模拟的思路，首先将入栈序列一次入栈，然后将当前栈顶元素与出栈序列的当前元素进行比较。如果相同，就出栈当前元素，并且将出栈序列后移一个元素位置。当所有的元素入栈之后，判断栈中是否还有元素，如果有说明出栈序列不合法。没有则合法。 123456789101112131415class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n=a.size(),m=b.size(); stack&lt;int&gt; st; for (int i=0,j=0; i&lt;n; ++i) &#123; st.push(a[i]); while (!st.empty() &amp;&amp; st.top()==b[j]) &#123; st.pop(); j ++; &#125; &#125; return st.empty(); &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++对象的优化--减少不必要的函数调用","slug":"C++对象的优化--减少不必要的函数调用","date":"2020-11-21T14:58:25.000Z","updated":"2020-11-29T19:35:16.867Z","comments":true,"path":"2020/11/21/C++对象的优化--减少不必要的函数调用/","link":"","permalink":"http://example.com/2020/11/21/C++%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96--%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/","excerpt":"","text":"测试环境：win10+vs2013初始代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Test &#123;private: int ma;public: Test(int data = 10) :ma(data) &#123; cout &lt;&lt; &quot;Test(int)&quot; &lt;&lt; endl; &#125; Test(const Test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; ma = t.ma; cout &lt;&lt; &quot;operator=&quot; &lt;&lt; endl; return *this; &#125; int getData() &#123; return ma; &#125;&#125;;Test getObject(Test t) &#123; int val = t.getData(); Test res(val); return res;&#125;int main() &#123; Test t1(10); Test t2; t2 = getObject(t1); return 0;&#125; 执行结果：上面短短的三行代码，背后居然11次的函数调用，效率太低了！！！ 一、函数参数要求传入对象时，使用引用传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Test &#123;private: int ma;public: Test(int data = 10) :ma(data) &#123; cout &lt;&lt; &quot;Test(int)&quot; &lt;&lt; endl; &#125; Test(const Test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; ma = t.ma; cout &lt;&lt; &quot;operator=&quot; &lt;&lt; endl; return *this; &#125; int getData() &#123; return ma; &#125;&#125;;// 相对上边的代码 仅仅是将形式参数 Test t改为Test &amp;tTest getObject(Test&amp; t) &#123; int val = t.getData(); Test res(val); return res;&#125;int main() &#123; Test t1(10); Test t2; t2 = getObject(t1); return 0;&#125; 执行结果： 可以看到，经过函数参数的优化（值传递-&gt;引用传递），减少了一次临时对象构造和析构的函数开销。相对于之前，只有9次的函数调用，减少了两次！！！ 二、函数返回时，返回临时对象，不要先定义对象，然后再返回。直接提前计算好构造该函数返回对象所需要的参数，直接返回临时对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Test &#123;private: int ma;public: Test(int data = 10) :ma(data) &#123; cout &lt;&lt; &quot;Test(int)&quot; &lt;&lt; endl; &#125; Test(const Test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; ma = t.ma; cout &lt;&lt; &quot;operator=&quot; &lt;&lt; endl; return *this; &#125; int getData() &#123; return ma; &#125;&#125;;Test getObject(Test &amp;t) &#123; int val = t.getData(); // Test res(val); // return res; return Test(val);&#125;int main() &#123; Test t1(10); Test t2; t2 = getObject(t1); return 0;&#125; 执行结果：相对于上一步优化，又减少了两次函数调用的开销！！！ 三、当需要接受一个函数的返回值时，并且该返回值是一个对象，不要以赋值的方式接受，以初始化的方式接受。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Test &#123;private: int ma;public: Test(int data = 10) :ma(data) &#123; cout &lt;&lt; &quot;Test(int)&quot; &lt;&lt; endl; &#125; Test(const Test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test&amp; operator=(const Test&amp; t) &#123; ma = t.ma; cout &lt;&lt; &quot;operator=&quot; &lt;&lt; endl; return *this; &#125; int getData() &#123; return ma; &#125;&#125;;Test getObject(Test &amp;t) &#123; int val = t.getData(); // Test res(val); // return res; return Test(val);&#125;int main() &#123; Test t1(10); Test t2 = getObject(t1);// 初始化的方式接受 // t2 = getObject(t1); // 赋值的方式接受 return 0;&#125; 执行结果： 相对于初始的代码，同样是获取一个对象的功能，优化到现在只有两次的构造和两次析构的调用，程序减少了相当大的一部分的函数调用开销，程序的效率也得到了很大的提升。一次调用getObejct()函数可以减少7次的函数调用开销，那么100万次的调用，就能减少700万次的开销。量变产生质变！！！对象优化的三条规则1.当函数的形式参数需要传递对象时，不要用值接受，用引用接受。减少一次临时对象的构造和析构。2.当函数的返回值为对象时，不要再函数题先定义好零时对象，然后再返回值。直接提前计算好构造该返回对象需要的参数，直接返回一个临时对象。3.当接受函数返回值为对象的函数的返回值时，以初始化的方式接受，不要以赋值的方式接受。tips：当以临时对象拷贝构造一个新对象时，编译器不会产生这个临时对象，直接以构造临时对象的方式直接构造新对象，减少一次临时对象的构造和析构。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"C++-对象的生存周期","slug":"C++-对象的生存周期","date":"2020-11-21T10:36:48.000Z","updated":"2020-11-29T19:35:16.851Z","comments":true,"path":"2020/11/21/C++-对象的生存周期/","link":"","permalink":"http://example.com/2020/11/21/C++-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class A &#123;private: int ma;public: A(int a=20):ma(a) &#123;cout &lt;&lt; &quot;A(int)&quot; &lt;&lt; endl;&#125; ~A() &#123;cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;&#125; A(const A&amp; t):ma(t.ma) &#123;cout &lt;&lt; &quot;A(const A&amp;)&quot; &lt;&lt; endl;&#125; A&amp; operator=(const A&amp; t) &#123; cout &lt;&lt; &quot;operator=&quot; &lt;&lt; endl; this.ma = t.ma; return *this; &#125;&#125;;int main() &#123; A a1; // 构造a1 A a2(a1); // 用a1拷贝构造a2 A a3 = a1; // 用a1拷贝构造a3 A a4 = A(20); // 用临时对象拷贝构造a4,但是编译器做了优化，此处不用产生临时对象，相当于A a4(20); cout &lt;&lt; &quot;=========&quot; &lt;&lt; endl; a2 = a4; // 调用赋值运算符重载构造函数 a2 = A(100); /* 此处的临时对象需要产生，因为是要拷贝构造，所以临时对象是要一个已经存在的，占有内存的对象 1.首先构造临时对象 2.使用临时对象拷贝构a2 3.临时对象对象的生存周期是语句末，到语句末析构临时对象 */&#125; 指针和引用 1234int main() &#123; A *p = &amp;A(10); // 错误的，不能用指针指向一个临时对象。因为到语句末，临时对象就析构了 const A&amp; ref = A(10); // 可以用一个常引用引用一个临时对象，临时对象的声明周期提升为栈变量的生命周期&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"单链表逆置(递归和迭代)","slug":"单链表逆置(递归和迭代)","date":"2020-11-15T17:31:40.000Z","updated":"2020-11-29T19:35:17.179Z","comments":true,"path":"2020/11/16/单链表逆置(递归和迭代)/","link":"","permalink":"http://example.com/2020/11/16/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE(%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3)/","excerpt":"","text":"迭代 1234567891011121314class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null) return head; ListNode a=head, b=head.next; head.next = null; while (b != null) &#123; ListNode c = b.next; b.next = a; a = b; b = c; &#125; return a; &#125;&#125; 递归 1234567891011class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head==null || head.next==null) &#123; return head; &#125; ListNode res = reverseList(head.next); head.next.next = head; head.next = null; return res; &#125;&#125;","categories":[{"name":"数据结构 java Leetcode","slug":"数据结构-java-Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-java-Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"递归逆序和正数输出正整数","slug":"递归逆序和正数输出正整数","date":"2020-11-15T08:24:14.000Z","updated":"2020-11-29T19:35:17.175Z","comments":true,"path":"2020/11/15/递归逆序和正数输出正整数/","link":"","permalink":"http://example.com/2020/11/15/%E9%80%92%E5%BD%92%E9%80%86%E5%BA%8F%E5%92%8C%E6%AD%A3%E6%95%B0%E8%BE%93%E5%87%BA%E6%AD%A3%E6%95%B4%E6%95%B0/","excerpt":"","text":"正序输出 12345678#include &lt;bits/stdc++.h&gt;using namespace std;void print(int x) &#123; if (x == 0) return; print(x/10); cout &lt;&lt; x%10 &lt;&lt; &quot; &quot;;&#125; 逆序输出 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;void reversePrint(int x) &#123; if (x == 0) &#123; return x; &#125; cout &lt;&lt; x%10 &lt;&lt; &quot; &quot;; reversePrint(x/10); &#125;","categories":[{"name":"c/c++ 趣味编程 算法基础","slug":"c-c-趣味编程-算法基础","permalink":"http://example.com/categories/c-c-%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"BF算法-串匹配算法","slug":"BF算法-串匹配算法","date":"2020-11-11T02:51:08.000Z","updated":"2020-11-29T19:35:17.167Z","comments":true,"path":"2020/11/11/BF算法-串匹配算法/","link":"","permalink":"http://example.com/2020/11/11/BF%E7%AE%97%E6%B3%95-%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","excerpt":"","text":"串的模式匹配：暴力算法，时间复杂度为O(n)。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;// 返回第一次匹配到的位置int bf(char *s, char *t) &#123; int i=0,j=0,k=0; while (i &lt; strlen(s) &amp;&amp; j &lt; strlen(t)) &#123; if (s[i] == t[j]) &#123; i ++, j++; &#125; else &#123; j = 0; // 模式串回溯 i = ++k; // 文本串移动到失配的下一个位置 &#125; &#125; if (j &gt;= strlen(t)) &#123; return k; &#125; else &#123; return -1; &#125;&#125;","categories":[{"name":"c/c++ 数据结构 算法基础","slug":"c-c-数据结构-算法基础","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构 算法","slug":"数据结构-算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}]},{"title":"层序遍历求树的深度","slug":"层序遍历求树的深度","date":"2020-11-09T13:20:30.000Z","updated":"2020-11-29T19:35:17.171Z","comments":true,"path":"2020/11/09/层序遍历求树的深度/","link":"","permalink":"http://example.com/2020/11/09/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;struct TreeNode &#123; int val; TreeNode *left, *right;&#125;;void dfsGetDepth(TreeNode *root, int &amp;x) &#123; if (!root) return; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; int n = q.size(); for (int i=0; i&lt;n; ++i) &#123; auto f=q.front();q.pop(); if (f-&gt;left) q.push(f-&gt;left); if (f-&gt;right) q.push(f-&gt;right); &#125; x ++; &#125;&#125;int main() &#123; return 0;&#125;","categories":[{"name":"数据结构 算法基础 Leetcode","slug":"数据结构-算法基础-Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"}],"tags":[{"name":"leetcode c++","slug":"leetcode-c","permalink":"http://example.com/tags/leetcode-c/"}]},{"title":"最长公共子序列(dp)","slug":"最长公共子序列(dp)","date":"2020-10-30T01:17:32.000Z","updated":"2020-11-29T19:35:17.175Z","comments":true,"path":"2020/10/30/最长公共子序列(dp)/","link":"","permalink":"http://example.com/2020/10/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(dp)/","excerpt":"","text":"f[i][j]表示所有在第一个序列中前i个字母出现并且在第二个序列中前j个字母出现的子序列。初始化：第一行，第一列f[i][0]和f[0][j]均为0状态转移：（1）当前a[i]==b[j], f[i][j] = f[i-1][j-1]+1;（2）a[i]!=b[j]，f[i][j] = max(f[i-1][j], f[i][j-1]); 1234567891011121314151617class Solution &#123;public: int longestCommonSubsequence(string a, string b) &#123; int n = a.size(); int m = b.size(); vevtor&lt;vector&lt;int&gt;&gt; f(n+1, vector&lt;int&gt;(m+1, 0)); for (int i=1; i&lt;=n; ++i) &#123; for (int j=1; j&lt;=m; ++j) &#123; f[i][j] = max(f[i-1][j], f[i][j-1]); if (a[i-1] == b[j-1]) &#123; f[i][j] = max(f[i-1][j-1]+1, f[i][j]); &#125; &#125; &#125; return f[n][m]; &#125;&#125;;","categories":[{"name":"c/c++ 算法基础 Leetcode","slug":"c-c-算法基础-Leetcode","permalink":"http://example.com/categories/c-c-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"}],"tags":[{"name":"动态规划 算法 leetcode","slug":"动态规划-算法-leetcode","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95-leetcode/"}]},{"title":"最长回文子串","slug":"最长回文子串","date":"2020-10-28T23:48:54.000Z","updated":"2020-11-29T19:35:17.191Z","comments":true,"path":"2020/10/29/最长回文子串/","link":"","permalink":"http://example.com/2020/10/29/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size()==1 || !s.size()) return s; if (s.size()==2 &amp;&amp; s[0]==s[1]) return s; int n = s.siz(); vector&lt;vector&lt;bool&gt;&gt; f(n, vector&lt;bool&gt;(n)); // 记录子串的起始索引和长度 int start=0,len=1; for (int i=0; i&lt;n; ++i) &#123; f[i][i] = 1;// 所有长度为1的子串均为一个回文串 if (i+1&lt;n &amp;&amp; s[i]==s[i+1]) &#123; start = i; len = 2; // 长度为2的回文串 f[i][i+1] = 1; &#125; &#125; // 枚举长度L [3,n] // 枚举左右端点 i right=i+L-1 right-i+1==L for (int L=3; i&lt;=n; ++L) &#123; for(int i=0; i+L-1&lt;n; ++i) &#123; int j = i+L-1; // 左右端点处字符相等并且子区间是一个回文串，则可以扩充 if (s[i]==s[j] &amp;&amp; f[i+1][j-1]) &#123; f[i][j] = 1; start = i; len = L; &#125; &#125; &#125; return s.substr(start, len); &#125;&#125;;","categories":[{"name":"c/c++ 数据结构 Leetcode","slug":"c-c-数据结构-Leetcode","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Leetcode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"多机调度问题（贪心）","slug":"多机调度问题（贪心）","date":"2020-10-28T04:23:56.000Z","updated":"2020-11-29T19:35:17.167Z","comments":true,"path":"2020/10/28/多机调度问题（贪心）/","link":"","permalink":"http://example.com/2020/10/28/%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/","excerpt":"","text":"有n个任务，m台机器，n&gt;m，每个作业i可以选择一台设备进行加工，加工时间为ti，每台机器同时只能加工一个作业，且不可中断。实现作业调度，使得n个作业的等待时间最短。样例输入： 126 32 5 13 15 16 20 样例输出： 128 贪心策略：优先处理花费时间长的任务，这样可以减少短任务的等待时间实现： 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10010;int t[N]; // 存储任务所需要时间int time[N]; // 存储完成任务后的时间int main() &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for (int i=0; i&lt;n; ++i) cin &gt;&gt; t[i]; sort(t, t+n, [](const int&amp; x, const int&amp; y) &#123;return x &gt; y;&#125;); int res = 0;//统计等待时间 for (int i=0; i&lt;n; ++i) &#123; // 将最长处理时间的任务分配给最先空闲的机器 // 这里不需要关注那一台机器首先空闲 res += (res + *min_element(time, time+n)); *min_element(time,time+n) += t[i]; &#125; // 输出最早完成时间 cout &lt;&lt; *max_element(time, time+n) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"for循环  while循环  do while循环流程图画法","slug":"for循环  while循环  do while循环流程图画法","date":"2020-10-25T08:30:41.000Z","updated":"2020-11-29T19:35:17.167Z","comments":true,"path":"2020/10/25/for循环  while循环  do while循环流程图画法/","link":"","permalink":"http://example.com/2020/10/25/for%E5%BE%AA%E7%8E%AF%20%20while%E5%BE%AA%E7%8E%AF%20%20do%20while%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%94%BB%E6%B3%95/","excerpt":"","text":"1.for(表达式1;表达式2;表达式3） 2.while(条件) {循环体} 3.do {循环体} while(条件)","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"输出二叉树中值为x的祖先","slug":"输出二叉树中值为x的祖先","date":"2020-10-24T14:59:35.000Z","updated":"2020-11-29T19:35:17.155Z","comments":true,"path":"2020/10/24/输出二叉树中值为x的祖先/","link":"","permalink":"http://example.com/2020/10/24/%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%A5%96%E5%85%88/","excerpt":"","text":"123456789101112131415161718struct node &#123; int val; node *left, *right;&#125;;// 返回值判断二叉树中是否含有x// 含有x并且在子树中 则当前节点是一个祖先// 含有x但是就是当前节点的值 则直接返回到上一层调用bool ancestor(node *root, int x) &#123; if (!root) return false; if (root-&gt;val == x) return true; if ((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == x) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == x)) &#123; cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; return true; &#125; return false;&#125;","categories":[{"name":"c/c++ 数据结构 算法基础","slug":"c-c-数据结构-算法基础","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"1024程序员节","slug":"1024程序员节","permalink":"http://example.com/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/"}]},{"title":"最近公共祖先lca(C++实现)","slug":"最近公共祖先lca(C++实现)","date":"2020-10-24T10:38:47.000Z","updated":"2020-11-29T19:35:17.167Z","comments":true,"path":"2020/10/24/最近公共祖先lca(C++实现)/","link":"","permalink":"http://example.com/2020/10/24/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca(C++%E5%AE%9E%E7%8E%B0)/","excerpt":"","text":"12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int val; node *left, *right;&#125;;node *lca(node *root, node *p, node *q) &#123; if (!root || root==q || root==q) return root; auto left = lca(root-&gt;left, p, q); auto right = lca(root-&gt;right, p, q); if (!left) return right; if (!right) return left; return root;&#125;","categories":[{"name":"c/c++ 数据结构","slug":"c-c-数据结构","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"1024程序员节 c++","slug":"1024程序员节-c","permalink":"http://example.com/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82-c/"}]},{"title":"1024我在csdn","slug":"1024我在csdn","date":"2020-10-24T01:56:44.000Z","updated":"2020-11-29T19:35:17.439Z","comments":true,"path":"2020/10/24/1024我在csdn/","link":"","permalink":"http://example.com/2020/10/24/1024%E6%88%91%E5%9C%A8csdn/","excerpt":"","text":"程序员的快乐","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"1024程序员节","slug":"1024程序员节","permalink":"http://example.com/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/"}]},{"title":"二叉树的宽度","slug":"二叉树的宽度","date":"2020-10-13T18:10:59.000Z","updated":"2020-11-29T19:35:17.467Z","comments":true,"path":"2020/10/14/二叉树的宽度/","link":"","permalink":"http://example.com/2020/10/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6/","excerpt":"","text":"算法思想：用一个w维护当前二叉树的宽度，使用层序遍历的方式，每次入队后更新w的值。 12345678910111213141516171819202122232425#include &lt;bit/stdc++.h&gt;using namespace std;struct TreeNode &#123; int val; TreeNode *left, *right;&#125;;int width(TreeNode *root) &#123; if (!root) return 0; queue&lt;TreeNode*&gt; q; q.push(root); int w = 1;// 当前二叉树的宽度为1 while (!q.empty()) &#123; int size = q.size(); while (size &gt; 0) &#123; auto f = q.front();q.pop(); size --; if (f-&gt;left) q.push(f-&gt;left); if (f-&gt;right) q.push(f-&gt;right); &#125; w = max(w, (int)q.size()); &#125; return w;&#125;","categories":[{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡二叉树(AVL)C++实现","slug":"平衡二叉树(AVL)C++实现","date":"2020-10-09T13:40:34.000Z","updated":"2020-11-29T19:35:17.467Z","comments":true,"path":"2020/10/09/平衡二叉树(AVL)C++实现/","link":"","permalink":"http://example.com/2020/10/09/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)C++%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;bits/stdc++.h&gt;using namespace std;class AVL &#123;private: struct node &#123; int val; int height; node *left, *right; node (int x) &#123; this-&gt;val = x; this-&gt;height = 1; this-&gt;left = this-&gt;right = nullptr; &#125; &#125;; node *root; int size; void updateHeight(node *root) &#123; root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1; &#125; int getHeight(node *root) &#123; return !root?0:root-&gt;height; &#125; int getBalanceFactor(node* root) &#123; return !root?0:(getHeight(root-&gt;left) - getHeight(root-&gt;right)); &#125; node* add(node *root, int x) &#123; if (!root) &#123; size ++; return new node(x); &#125; if (x &lt; root-&gt;val) &#123; root-&gt;left = add(root-&gt;left, x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right = add(root-&gt;right, x); &#125; else &#123; root-&gt;val = x; &#125; // 更新高度 updateHeight(root); int balanceFactor = getBalanceFactor(root); // 维护平衡 // LL if (balanceFactor==2 &amp;&amp; getBalanceFactor(root-&gt;left)&gt;=0) &#123; return rightRotate(root); &#125; // LR // y // / \\ // x t4 // / \\ leftRotate(x) rightRotate(y) // t1 z // / \\ // t2 t3 if (balanceFactor==2 &amp;&amp; getBalanceFactor(root-&gt;left)&lt;0) &#123; root-&gt;left = leftRotate(root-&gt;left); return rightRotate(root); &#125; // RR if (balanceFactor==-2 &amp;&amp; getBalanceFactor(root-&gt;right)&lt;=0) &#123; return leftRotate(root); &#125; // RL // y // / \\ // t1 x // / \\ rightRotate(x) leftRotate(y) // z t4 // / \\ // t2 t3 if (balanceFactor==-2 &amp;&amp; getBalanceFactor(root-&gt;right)&gt;0) &#123; root-&gt;right = rightRotate(root-&gt;right); return leftRotate(root); &#125; return root; &#125;public: AVL() &#123; this-&gt;root = nullptr; this-&gt;size = 0; &#125; ~AVL() &#123; destroy(root); &#125; // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // T1 x 向左旋转 (y) y z // / \\ - - - - - - - -&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 node* leftRotate(node *y) &#123; node *x = y-&gt;right; node *t2 = x-&gt;left; x-&gt;left = y; y-&gt;right = t2; updateHeight(y); updateHeight(x); return x; &#125; // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // x T4 向右旋转 (y) z y // / \\ - - - - - - - -&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 node* rightRotate(node *y) &#123; node *x = y-&gt;left; node *t3 = x-&gt;right; x-&gt;right = y; y-&gt;left = t3; updateHeight(y); updateHeight(x); return x; &#125; void add(int x) &#123; root = add(root, x); &#125; void destroy(node *root) &#123; if (root) &#123; destroy(root-&gt;left); destroy(root-&gt;right); delete root; &#125; &#125; void bfs() &#123; if (!root) return; queue&lt;node*&gt; q; q.push(root); while (!q.empty()) &#123; node *f = q.front();q.pop(); cout &lt;&lt; f-&gt;val &lt;&lt; &quot; &quot;; if (f-&gt;left) q.push(f-&gt;left); if (f-&gt;right) q.push(f-&gt;right); &#125; cout &lt;&lt; endl; &#125; bool isBST() &#123; // 判断中序遍历序列 vector&lt;int&gt; res; inOrder(root, res); for (int i=1; i&lt;res.size(); ++i) &#123; if (res[i-1] &gt;= res[i]) return false; &#125; return true; &#125; bool isBalanced() &#123; return isBalanced(root); &#125; bool isBalanced(node *root) &#123; if (!root) return 1; if (abs(getHeight(root-&gt;left) - getHeight(root-&gt;right)) &gt; 1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; void inOrder(node *root, vector&lt;int&gt; &amp;res) &#123; if (root) &#123; inOrder(root-&gt;left, res); res.push_back(root-&gt;val); inOrder(root-&gt;right, res); &#125; &#125;&#125;;int main() &#123; int a[] = &#123;1,2,3,4,5&#125;; int n = sizeof(a)/sizeof(int); AVL avl; for (int i=0; i&lt;n; ++i) avl.add(a[i]); avl.bfs(); cout &lt;&lt; avl.isBalanced() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c/c++ 数据结构","slug":"c-c-数据结构","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"并查集(路径压缩)C++实现","slug":"并查集(路径压缩)C++实现","date":"2020-10-07T14:16:43.000Z","updated":"2020-11-29T19:35:17.451Z","comments":true,"path":"2020/10/07/并查集(路径压缩)C++实现/","link":"","permalink":"http://example.com/2020/10/07/%E5%B9%B6%E6%9F%A5%E9%9B%86(%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9)C++%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536class UnionFind &#123;private: int *father; int count;public: UnionFind(int n) &#123; this-&gt;count = n; father = new int[n]; for (int i=0; i&lt;n; ++i) father[i] = i; &#125; ~UnionFind(int n) &#123; delete[] father; &#125; // 查找索引为x的节点的父亲节点的索引 int find(int x) &#123; assert(x &gt;= 0 &amp;&amp; x &lt; count); int a = x; while (x != father[x]) x = father[x]; while (a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x; &#125; void Union(int x, int y) &#123; int fx = find(x); int fy = find(y); if (fx != fy) father[fx] = fy; &#125; bool isConnected(int x, int y) &#123; return find(x) == find(y); &#125;&#125;;","categories":[{"name":"c/c++ 数据结构 算法基础","slug":"c-c-数据结构-算法基础","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"一维数组&二维数组&对称矩阵&三角矩阵&三对角矩阵地址的计算","slug":"一维数组&二维数组&对称矩阵&三角矩阵&三对角矩阵地址的计算","date":"2020-10-07T12:39:23.000Z","updated":"2020-11-29T19:35:17.467Z","comments":true,"path":"2020/10/07/一维数组&二维数组&对称矩阵&三角矩阵&三对角矩阵地址的计算/","link":"","permalink":"http://example.com/2020/10/07/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84&%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5&%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5&%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"","text":"一维数组的地址计算设每个元素的大小是size，首元素的地址是a[1]，则a[i] = a[1] + (i-1)*size 若首元素的地址是a[0]则a[i] = a[0] + i*size *二维数组的地址计算 (mn的矩阵)**行优先设每个元素的大小是size，首元素的地址是a[1][1]，则a[i][j]?分析：a[i][j]位于第i行，第j列。它之前有i-1行，在第i行它之前有j-1个元素。即a[i][j] = a[1][1] + [n*(i-1) + (j-1)]*size 三维数组的地址计算 (rmn) r行m列n纵行优先首元素的地址a[1,1,1] a[i,j,k] = a[1,1,1] + [(i-1)*n*m + (j-1)*n + (k-1)]*size 压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间，其目的是为了节省存储空间。 二维数组通常用来存储矩阵，特殊矩阵分为两类：（1）元素分布没有规律的矩阵，按照规律对用的公式实现压缩。（2）无规律，但非零元素很少的稀疏矩阵，只存储非零元素实现压缩。 一、三角矩阵包括上三角矩阵，下三角矩阵和对称矩阵(1)若i&lt;j时，ai,j=0，则称此矩阵为下三角矩阵。(2)若i&gt;j时，ai,j=0，则称此矩阵为上三角矩阵。(3)若矩阵中的所有元素满足ai,j=aj,i，则称此矩阵为对称矩阵。下三角上三角 二、三对角矩阵带状矩阵的压缩方法：将非零元素按照行优先存入一维数组。（1）确定一维数组的存储空间大小：2+(n-2)3+2 = 3n-2（2）确定非零元素在一维数组中的地址loc(i,j) = loc(1,1) + 前i-1行非零元素个数+第i行中ai,j前非零元素的个数前i-1行：3 * (i-1) - 1，因为第一行只有两个，所以要减去1第i行中ai,j前非零元素的个数=(j-i)+1,j-i有三种情况：（1）j&lt;i **j-i=-1**（2）j==i **j-i=0**（3）j&gt;i *j-i=1** loc(i,j) = loc(1,1) + 3(i-1)-1 + j-i+1 = loc(1,1) + 2(i-1) + j-1 = loc(1,1) + 2i+j-3","categories":[{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"kmp算法","slug":"kmp算法","date":"2020-10-07T00:05:32.000Z","updated":"2020-11-29T19:35:17.463Z","comments":true,"path":"2020/10/07/kmp算法/","link":"","permalink":"http://example.com/2020/10/07/kmp%E7%AE%97%E6%B3%95/","excerpt":"","text":"Kmp算法是一种效率极高的串匹配算法，适用这样的场景，在给定文本串text中查找是否含有指定的模式串pattern。 效率高的原因：利用部分匹配的信息，将已经匹配到信息存入next数组。本质上我觉得还是空间换时间的思想。类似的有求最大回文串长度的manacher算法。时间复杂度O(n+m) 最长公共前后缀next数组的求解 next数组可以称之为prefix table，前缀表。next[i]表示的最长公共前后缀中前缀的最后一位下标(在数组中的位置)。对于任意字串s[0…i] 长度为k+1的前缀为s[0…k] 后缀为s[i-k…i] next[i]表示使得子串s[0…i]的前缀s[0…k]和后缀s[i-k…i]相等的最大的k，其中前缀和后缀可以部分重叠，但是不也能是s[0…i]本身。 123456789101112131415const int MAX=10010;int Next[MAX];void getNext(char s[], int n) &#123; int j = -1; /* Next数组的起始索引，是一个无效的索引 表示最长公共前后缀前缀的最后一位的下标 */ Next[0] = -1; for (int i=1; i&lt;n; ++i) &#123; while (j != -1 &amp;&amp; s[i]!=s[j+1]) j = Next[j]; if (s[i] == s[j+1]) j ++; Next[i] = j; &#125;&#125; 1234567891011bool kmp(char *text, char *pattern) &#123; int n = strlen(text), m = strlen(pattern); getNext(pattern, m); int j = -1; for (int i=0; i&lt;n; ++i) &#123; while (j != -1 &amp;&amp; text[i] != pattern[j+1]) j = Next[j]; if (text[i] == pattern[j+1]) j ++; if (j == m-1) return true; &#125; return false;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"二级页表的划分和由来","slug":"二级页表的划分和由来","date":"2020-09-21T03:16:25.000Z","updated":"2020-11-29T19:35:17.419Z","comments":true,"path":"2020/09/21/二级页表的划分和由来/","link":"","permalink":"http://example.com/2020/09/21/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E7%94%B1%E6%9D%A5/","excerpt":"","text":"","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Java实现替换字符串中空格为两个#","slug":"Java实现替换字符串中空格为两个#","date":"2020-09-20T15:10:36.000Z","updated":"2020-11-29T19:35:17.463Z","comments":true,"path":"2020/09/20/Java实现替换字符串中空格为两个#/","link":"","permalink":"http://example.com/2020/09/20/Java%E5%AE%9E%E7%8E%B0%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A9%BA%E6%A0%BC%E4%B8%BA%E4%B8%A4%E4%B8%AA#/","excerpt":"","text":"方法一 123456789101112131415161718public static void addChar(String s) &#123; char[] a = s.toCharArray(); int wordStart = 0; for (int i=0; i&lt;a.length; ++i) &#123; int j = i; if (a[j] == &#x27; &#x27;) &#123; int wordEnd = j; String x = s.substring(0, wordEnd); String y = s.substring(wordEnd+1, s.length()); s = x+&quot;##&quot;+y; i = j+1; wordStart = j + 2; &#125; a = s.toCharArray(); &#125; System.out.println(s); &#125; 方法二 1234567891011121314public static void main(String[] args) &#123; String s = &quot;hello world shi jian ni hao&quot;; addChar(s); String[] a = s.split(&quot; &quot;); String res = &quot;&quot;; for (int i=0; i+1&lt;a.length; i+=2) &#123; if (i+1 != a.length-1) &#123; res += (a[i] + &quot;##&quot; + a[i + 1] + &quot;##&quot;); &#125; else &#123; res += (a[i] + &quot;##&quot; + a[i + 1]); &#125; &#125; System.out.println(res); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java实现字符串单词反转","slug":"Java实现字符串单词反转","date":"2020-09-20T15:07:44.000Z","updated":"2020-11-29T19:35:17.463Z","comments":true,"path":"2020/09/20/Java实现字符串单词反转/","link":"","permalink":"http://example.com/2020/09/20/Java%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E8%AF%8D%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"一.方法一思想：1.首先将字符串转换成字符数组，方便索引字符。2.反转整个字符数组3.反转每个单词，单词是如何划分的：维护一个单词的起始索引和结束索引i,j,分别表示一个单词的起始下标和结尾下标，对这个区间的字符数组进行反转。 123456789101112131415161718192021222324public static void reverse(char[]arr,int i ,int j) &#123; //每个单词首位交换 while (i &lt; j)&#123; swap(arr, i ++, j --); &#125; &#125; public static void swap(char[] arr, int i, int j)&#123; char brr = arr[i]; arr[i] = arr[j]; arr[j] = brr; &#125;public static void rev(String word)&#123; char[] a = word.toCharArray(); int n = a.length; reverse(a,0,n-1); for (int i=0; i&lt;n; ++i) &#123; int j = i; for (; j&lt;n &amp;&amp; a[j]!=&#x27; &#x27;; j++); reverse(a, i, j-1); i = j; &#125; System.out.println(a); &#125; 二.方法二思想：1.使用String的split方法，空格字符当分隔符，切割字符串存入一个字符串数组。2.反转整个输入3.遍历数据，拼接字符串，当不是最后一个元素时，中间添加空格 1234567891011121314151617public static void main(String[] args) &#123; String s = &quot;hello world ni hao shi jian&quot;; String[] arr = s.split(&quot; &quot;); int i=0, j=arr.length-1; while (i &lt; j) &#123; String x = arr[i]; arr[i] = arr[j]; arr[j] = x; i ++;j--; &#125; String res=&quot;&quot;; for (int k=0; k&lt;arr.length; ++k) &#123; res = res + arr[k]; if (k != arr.length-1) res += &quot; &quot;; &#125; System.out.println(res);&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"插入型排序","slug":"插入型排序","date":"2020-09-16T17:33:03.000Z","updated":"2020-11-29T19:35:17.491Z","comments":true,"path":"2020/09/17/插入型排序/","link":"","permalink":"http://example.com/2020/09/17/%E6%8F%92%E5%85%A5%E5%9E%8B%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入型排序包括：直接插入排序 折半插入排序 希尔排序直接插入排序时间复杂度：O(n^2)空间复杂度：O(1)稳定性：稳定比较次数和移动次数与待排序序列的初始状态有关最好情况：序列有序 比较次数：n-1次 移动次数：0最差情况：序列逆序 比较次数：1+2+3+….+n-1次 移动次数直接插入特性：当数组基本有序时，时间复杂度达到O(n) 123456789void insertSort(int *a, int n) &#123; for (int i=1; i&lt;n; ++i) &#123; int x = a[i]; int j; for (j=i; j&gt;0 &amp;&amp; a[j-1]&gt;x; --j) a[j] = a[j-1]; a[j] = x; &#125; return;&#125; 折半插入排序时间复杂度：O(n^2)空间复杂度：O(1)稳定性：稳定比较次数与初态无关，约为nlg2n次移动次数与初态有关折半插入排序相对于直接插入排序，减少了比较次数 1234567891011121314void binaryInsertSort(int *a, int n) &#123; for (int i=1; i&lt;n; ++i) &#123; int l=0, r=i-1; while (l &lt;= r) &#123; int m = (r+l)/2; if (a[i] &lt;= a[m]) r = m-1; else l = m+1; &#125; int x = a[i]; for (int j=i; j&gt;l; --j) a[j] = a[j-1]; a[l] = x; &#125; return;&#125; 希尔排序递减增量排序时间复杂度：O(n^2) 最好约为O(n^1.3)空间复杂度：O(1)稳定性：不稳定 1234567891011121314void shellSort(int *a, int n) &#123; int d = 1; while (d &lt; n/3) d = d*3 + 1; while (d &gt;= 1) &#123; for (int i=d; i&lt;n; ++i) &#123; int x = a[i]; int j; for (j=i; j&gt;=d &amp;&amp; a[j-d]&gt;x; j-=d) a[j] = a[j-d]; a[j-d] = x; &#125; d /= 3; &#125; return;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Spooling技术","slug":"Spooling技术","date":"2020-09-16T13:30:17.000Z","updated":"2020-11-29T19:35:17.967Z","comments":true,"path":"2020/09/16/Spooling技术/","link":"","permalink":"http://example.com/2020/09/16/Spooling%E6%8A%80%E6%9C%AF/","excerpt":"","text":"输入设备将数据输入到输入缓冲区中，然后由sp in(输入进程）将输入缓冲区的数据送到位于磁盘的输入井中，当cpu需要使用输入数据时，再由磁盘的输入井读入内存。 输出进程首先将输出缓冲区中的数据送到位于磁盘的输出井中，当需要输出数据时，由输出进程将输出井的数据先搬运到位于内存的输出缓冲区中，然后再将输出缓冲区中的数据送往IO设备。 空间换时间 何为虚拟设备？Spooling系统如何实现虚拟设备的？试说明Spooling系统的组成？为什么要在设备管理中引入缓冲技术？spooling系统的含义是什么？为什么要引入spooling系统？spooling系统可以带来的好处有哪些？为什么要引入缓冲区？unix系统如何管理缓冲区？举例说明什么是Spooling系统（也称之为伪脱机技术）？为什么要引入spooling系统？请说明spooling系统的作用？spooling技术是如何实现的？","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"01背包问题","slug":"01背包问题","date":"2020-09-16T12:03:08.000Z","updated":"2020-11-29T19:35:17.747Z","comments":true,"path":"2020/09/16/01背包问题/","link":"","permalink":"http://example.com/2020/09/16/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是vi，得到的价值是wi。求解将哪些物品装入背包可以使得价值之和最大。 二维数组的暴力解法，未涉及空间优化。首先用子问题来定义状态，f[i][j]表示前i个物品放到容量为j的空间总价值最大。f[i][j]这个状态是由i-1推过来的，这里有两种考虑：第i中物品选择还是不选择，如果不选择f[i][j]==f[i-1][j]，如果选择f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])。max(f[i-1][j], f[i-1][j-v[i]]+w[i])的解释：第i件物品选择，第i件物品占据的空间是v[i]，价值为w[i]。那么前i-1件物品所占据的空间为j-v[i]，价值为f[i-1][j-v[i]]。而f[i][j]是f[i-1][j]和f[i-1][j-v[i]]+w[i]其中较大的一个。 代码部分： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn=1010;int v[maxn], w[maxn];int f[maxn][maxn];int n, m; //分别表示物品总数为n 背包容量为mint main() &#123; cin &gt;&gt; n &gt;&gt; m; f[0][0] = 0; for (int i=1; i&lt;=n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i=1; i&lt;=n; ++i) &#123; for (int j=1; j&lt;=m; ++j) &#123; f[i][j] = f[i-1][j]; if (j &gt;= v[i]) &#123; f[i][j] = max(f[i][j], f[i-1][j-v[i]]+w[i]); &#125; &#125; &#125; int res = 0; for (int i=0; i&lt;=m; ++i) &#123; res = max(res, f[n][i]); &#125; return 0;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"IO控制方式","slug":"IO控制方式","date":"2020-09-14T16:02:55.000Z","updated":"2020-11-29T19:35:17.755Z","comments":true,"path":"2020/09/15/IO控制方式/","link":"","permalink":"http://example.com/2020/09/15/IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/","excerpt":"","text":"程序直接控制方式cpu干预程度：非常的频繁，IO操作开始前，完成后均需要cpu介入，并且在等待IO完成的过程中cpu需要不断的介入进行轮询检查，实际上是忙轮询，极大的浪费了cpu的资源，本质原因还是IO设备与cpu速度差异造成的矛盾，其次的原因是没有中断机制，IO设备无法向cpu报告自己的状态数据流向: 读 IO设备-&gt;cpu-&gt;内存 写 内存-&gt;cpu-&gt;IO设备传输单位: 一个字缺点：cpu与IO设备只能串行工作，忙等IO完成，极大的浪费cpu资源，cpu利用率很低。优点：简单易于实现。 中断驱动方式由于中断机制的产生，cpu不需要忙轮询检查IO设备是否完成IO，而是被动的等待IO设备向自己通知，cpu的利用率得到提高。cpu干预程度：每次IO操作开始之前，完成之后需要cpu的介入。数据流向:传输单位: 一个字缺点：1.虽然引入中断，进一步的解放了cpu，提高了cpu的使用率。但是中断处理的过程需要保护现场，恢复现场，这是需要一定时间开销，如果频繁的触发中断，也会降低系统的性能，甚至得不偿失。2.由于传输数据的每个字都在IO控制器和存储器之间的传输都会经过cpu，这会导致中断驱动方式任然会消耗较多的cpu时间。优点：cpu利用率得到提高 DMA方式 direct memort accesscpu干预程度：仅在传送一个或多个连续的数据块的开始和结束时，才需要cpu的干涉。数据流向: 内存-&gt;IO设备 IO设备-&gt;内存传输单位: 数据块缺点：cpu每发出一条IO指令，只能读/写一块或多块连续的数据块。优点：1.相对有中断驱动方式，DMA方式减少了中断cpu的次数，仅在所要求传送的一批数据全部传送结束时才会中断cpu。2.数据传送是在DMA控制器控制下完成，而中断驱动方式的数据传送是在cpu的控制下完成的。总结:1.减少中断cpu的次数 2.数据传送的过程交由DMA控制器控制。 通道方式通道方式进一步降低了cpu对于IO设备的控制，将对于IO控制的权力下放到通道，由通道负责cpu制定的IO任务，当完成数据传送后才向cpu发送中断请求。cpu干预程度：数据流向:传输单位:缺点：实现复杂，需要通道硬件支持。优点：可以实现IO设备，cpu，通道三者的并行工作，资源利用率高，整个系统性能好。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"死锁","slug":"死锁","date":"2020-09-13T15:25:22.000Z","updated":"2020-11-29T19:35:17.731Z","comments":true,"path":"2020/09/13/死锁/","link":"","permalink":"http://example.com/2020/09/13/%E6%AD%BB%E9%94%81/","excerpt":"","text":"死锁产生的原因有两个:1.多进程或多线程对不可剥夺的软硬件资源进行的竞争2.操作系统内核对于多个进程推进顺序的非法，多个进程对于资源的请求与释放的顺序不正确，造成资源的死锁。 程序员对信号量的使用不当，造成应用程序内部多进程或多线程的死锁。程序员对互斥锁的使用不当，也会造成死锁，自己锁自己，这里的死锁并不是操作系统意义上的死锁，而是编程层面未对互斥锁成对(lock unlock)使用造成的。 1234567891011121314151617181920212223242526#include &lt;thread&gt;#include &lt;semaphore.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;using namespace std;sem_t s1, s2; // 两个用于同步的信号量int main() &#123; sem_init(&amp;s1, 0, 0); sem_init(&amp;s2, 0, 0); thread t1([&amp;]()&#123; sem_wait(&amp;s2); // 请求持有s2 陷入阻塞 cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; sem_post(&amp;s1); // 持有s1 但不能释放 &#125;); thread t2([&amp;]()&#123; sem_wait(&amp;s1); // 请求持有s1 陷入阻塞 cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; sem_post(&amp;s2); // 持有s2 但不能释放 &#125;); sem_destroy(&amp;s1); sem_destroy(&amp;s2); return 0;&#125; 上述两个两个线程分别持有一个信号量，但是又请求占用对方的信号量。满足互斥条件，满足不可剥夺条件，满足请求保持条件，满足循环等待条件，最终造成两个线程死锁，在无外力条件的破坏的情况下，两线程将永远不会向前推进。 12345678910111213141516#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;pthread_mutex_t mtx;int x=10;int main() &#123; pthread_mutex_init(&amp;mtx, NULL); pthread_mutex_lock(&amp;mtx);// 对mutex加锁成功 pthread_mutex_lock(&amp;mtx); // 还未对mutex解锁 将会永久阻塞 x += 100; pthread_mutex_unlock(&amp;mtx); pthread_mutex_destroy(&amp;mtx); return 0;&#125; 死锁预防死锁预防的本质就是釜底抽薪，直接从根本上干掉死锁，避免死锁的发生。破坏死锁的四个必要条件的一个或多个。互斥条件：几乎不可行 不可剥夺条件：强行剥夺，是要付出代价的。强行剥夺可能会造成进程或线程前一段工作的失效，只适用在一些易于保存和恢复的资源。 请求和保持条件：代价太高，一次性分配完，系统没有那么多资源，造成资源的浪费。 循环等待条件：顺序资源分配资源递增编号 进程或线程按序申请使用资源 死锁避免银行家算法 死锁检测与解除死锁定理+资源分配图","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux 信号量实现同步，实现互斥","slug":"Linux 信号量实现同步，实现互斥","date":"2020-09-12T14:35:02.000Z","updated":"2020-11-29T19:35:17.763Z","comments":true,"path":"2020/09/12/Linux 信号量实现同步，实现互斥/","link":"","permalink":"http://example.com/2020/09/12/Linux%20%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5/","excerpt":"","text":"一.实现同步同步模板 123456789101112使用信号量实现同步时，需要将信号量的初值设置为0semaphore s=0;p1() &#123; p(s); 具体的代码&#125;p2() &#123; 具体的代码 v(s);&#125; 1.假设p1先执行，执行到p(s), s-=1, 此时s=-1&lt;0,进程阻塞，主动放弃cpu使用权，cpu调度执行p2,执行p2的具体任务，然后进行v(s),，s+=1，s=0，p2执行完毕。cpu调度继续执行p1，此时s=0，p1被唤醒，因此就达到了先执行p2后执行p1的同步关系。2.假设p2先执行，首先执行具体的代码，然后进行v(s)，s+=1，s=1&gt;0，然后p2执行完毕。cpu调度执行p1，p1首先p(s)，s-=1，s=0，然后执行具体的代码。同样也达到了先执行p2后执行p1的同步关系。二.Linux下信号量实现同步，线程2先执行输出”hello”，线程1后执行输出”world\\n”的功能 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#include &lt;thread&gt;using namespace std;int x = 10;int main() &#123; sem_init(&amp;sem, 0, 0); thread t1([&amp;]()&#123; cout &lt;&lt; &quot;hello&quot;; sem_post(&amp;sem); &#125;); thread t2([&amp;]()&#123; sem_wait(&amp;sem); cout &lt;&lt; &quot;world&quot; &lt;&lt; endl; &#125;); t1.join(); t2.join(); sem_destroy(&amp;sem); return 0;&#125; 执行结果： 三.实现互斥互斥模板 12345678910111213141516171819互斥是对临界资源的保护 所以互斥只需要在临界区之前和之后分别进行加锁和解锁需要注意的是，用信号量充当互斥锁实现互斥的时候，信号量的初值应设置为1，表示临界资源的个数为1.int x=10; 临界资源semaphore s=1;p1() &#123; p(s); x ++; 访问临界资源 v(s);&#125;p2() &#123; p(s); x --; 访问临界资源 v(s);&#125; 1.假设p1先执行，p(s)，s-=1，s=0，假设此时cpu时间片用完，cpu调度执行p2，p(s)，s-=1，s=-1 &lt; 0，此时p2阻塞，主动放弃cpu使用权，cpu调度执行p1，进行x++，v(s)s+=1, s=0，p1执行完毕。cpu调度执行p2，由于s=0，p2唤醒，执行x –, v(s)，s+=1，s=1，p2执行完毕。此时信号量为1，表示可以临界资源个数为1。2.假设p2先执行同上。四.使用Linux信号量实现互斥 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#include &lt;thread&gt;using namespace std;int main() &#123; sem_init(&amp;sem, 0, 1); thread t1([&amp;]()&#123; sem_wait(&amp;sem); x ++; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot; this thread id:&quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl; sem_post(&amp;sem); &#125;); thread t2([&amp;]()&#123; sem_wait(&amp;sem); x --; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot; this thread id:&quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl; sem_post(&amp;sem); &#125;); t1.join(); t2.join(); sem_destroy(&amp;sem);&#125; 执行结果：","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"信号量原理","slug":"信号量原理","date":"2020-09-12T12:18:54.000Z","updated":"2020-11-29T19:35:17.815Z","comments":true,"path":"2020/09/12/信号量原理/","link":"","permalink":"http://example.com/2020/09/12/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"信号量：信号量是基于软件互斥或硬件互斥方法实现的一种用于同步和互斥的机制。信号量只有两种操作原语：wait, signal 一.整型信号量整型信号量用于描述临界资源的个数。 123456789s=10; 表示一个初始资源数量为10的信号量wait(s) &#123; while (s &lt;= 0); s --;&#125;signal(s) &#123; s ++;&#125; 缺点：违背“让权等待”的同步原则，由于当信号量所表示的资源数目&lt;=0时，而此时该进程的时间片还未用完，便会不断运行while(s&lt;=0)，从而造成cpu资源的浪费，违背“让权等待”的原则。 二.记录型信号量为了解决整型信号量中在wait原语中违背“让权等待”的原则的问题，记录型信号量提出新的想法，设置一个阻塞队列，当s.value&lt;=0时，便将改成挂到阻塞队列队尾，以免造成对cpu时间的浪费。记录型信号量是一个结构题，包含对临界资源数量的描述以及阻塞队列。 1234567891011121314151617181920212223typedef struct semaphore &#123; int value; // 描述临界资源的数量 queue&lt;process*&gt; blockQue; // 阻塞队列&#125;sem;void wait(sem s) &#123; s.value --; if (s.value &lt; 0) &#123; blockQue.push(this process); block(blockQue); 调用block原语，进行自我阻塞，放弃CPU的使用权 &#125;&#125;void signal(sem s) &#123; s.value ++; if (s.value &lt;= 0) &#123; process* head=blockQue.front();blcokQue.pop(); wakeup(head); 使用wakeup原语唤醒进程 阻塞态-&gt;就绪态 &#125;&#125; 三.用法对于整型信号量：当用于同步时，信号量的初始值设置为0。同步是为了规定不同进程的执行的先后顺序，在实际开发中，可能会有两个进程需要相互合作完成某项任务，比如，前者执行的结果是后者的初始值。 12345678910111213int x=10;sem s=0;A() &#123; x ++; v(s);&#125;B() &#123; p(s); cout &lt;&lt; x &lt;&lt; endl;&#125; 当用于互斥时，信号量的初始值设置为1。当信号量的初始值为1时，表示临界资源的格式为1个，当不同进程使用临界资源时，需要互斥的使用。 12345678910111213141516int x=10;//临界资源sem s=1;A() &#123; p(s); x ++; v(s);&#125;B() &#123; p(s); cout &lt;&lt; x &lt;&lt; endl; v(s);&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"软件方法实现互斥","slug":"软件方法实现互斥","date":"2020-09-12T11:58:08.000Z","updated":"2020-11-29T19:35:16.899Z","comments":true,"path":"2020/09/12/软件方法实现互斥/","link":"","permalink":"http://example.com/2020/09/12/%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5/","excerpt":"","text":"一.单标志法轮流交替使用。缺点:当有一个进程不再进入临界区，便不能修改公共变量的turn，来标识另外一个进程可以进入临界区。因此另外一个进程将永久不能进入临界区，违背“空则让进”的原则 1234567891011A进程while (turn != A);critical section 临界区turn = Bremainder section 剩余区B进程while (turn != B);critical sectionturn = Aremainder section 二.双标志先检查法为了解决在单标志法中出现的违背“空则让进”的原则的问题，增加一个变量用于检查对方的状态。 123456789101112131415161718bool flag[2] = &#123;false, false&#125;; flag[A]==true 表示A正在使用临界区flag[B]==true 表示B正在使用临界区A进程while (flag[B]==true); 当B在临界区便一直循环检查 (1) flag[A]=true; 表示A自己在临界区域中 (3)critical sectionflag[A]=false; 表示A自己退出临界区remainder sectionB进程while (flag[A]==true); 当A在临界区便一直循环检查 (2) flag[B]=true; 表示B自己在临界区域中 (4)critical sectionflag[B]=false; 表示B自己退出临界区remainder section 优点：不需要交替进入临界区，可以连续使用缺点：两个进程可能会同时进入临界区，初始状态，A与B进程均不在临界区内，所以flag[A]==flag[B]=false，此时按照CPU若按照，(1)(2)(3)(4)的顺序进行执行，A，B进程都能检查到对方不在临界区中，然后进入临界区，分别置自己的值为true，但此时临界区中有两个互斥的进程，违背“忙则等待”的原则。出现这种问题的原因是：检查对方的状态和置自己的状态这两步操作之间存在漏洞，不是原子的。 三.双标志后检查法为了解决在双标志先检查法中出现的违背“忙则等待”的原则的问题，双标志后检查法的做法是：首先更改自己的状态为进入临界区，然后再检查对方是否在临界区中。 123456789101112131415flag[2] = &#123;false, false&#125;;A进程flag[A]=true; (1)while (flag[B]==true); (3)critical sectionflag[A]=false;remainder section;B进程flag[B]=true; (2)while (flag[A]==true); (4) critical sectionflag[B]=false;remainder section; 优点：双标志后检查法解决了在双标志先检查法中出现的违背“忙则等待”原则的问题。缺点：可能会造成饥饿现象，违背“有限等待”的原则。原因：CPU可能是按照(1)(2)(3)(4)的顺序执行程序，此时A与B进程均将自己的状态修改为进入临界区，此时执行(3)(4)，A,B进程均检查到对方在临界区中，最终造成饥饿，违背“优先等待”的原则。 四.peterson算法为了解决双标志后检查出现的违背“有限等待”的原则，提出了peterson算法，该算法基于比较绅士友好的想法，A与B都声明自己对于临界区的占有权flag[A]=true，flag[B]=true，但是它们比较绅士，考虑到双方都要声明对临界区的占用权，最终会争吵的难分难舍，不分高低。所以双方都各自非常绅士的说到，虽然我对临界区有占有权，但是你要的话可以让你优先使用，不要客气，因此设置一个turn变量表示临界区让谁用。 1234567891011121314151617A进程flag[2] = &#123;false, false&#125;;flag[A]=true;我有占有权 turn=B;你先用，不要客气while (flag[B]==true &amp;&amp; turn==B);critical sectionflag[A]=false;remainder sectionB进程flag[2] = &#123;false, false&#125;;flag[B]=true;我有占有权 turn=A;你先用，不要客气while (flag[A]==true &amp;&amp; turn==A);critical sectionflag[B]=false;remainder section 优点：peterson算法完美的遵守了空则让进，有限等待，忙则等待的原则。但是，当A或B进程其一在临界区中，而此时处理机调度B或A时，while循环进行了忙轮询，浪费消耗处理机时间，违背“让权等待”的原则。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"三重积分的球面坐标系的体积元素表示","slug":"三重积分的球面坐标系的体积元素表示","date":"2020-09-05T12:05:19.000Z","updated":"2020-11-29T19:35:18.059Z","comments":true,"path":"2020/09/05/三重积分的球面坐标系的体积元素表示/","link":"","permalink":"http://example.com/2020/09/05/%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E7%90%83%E9%9D%A2%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E4%BD%93%E7%A7%AF%E5%85%83%E7%B4%A0%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"","categories":[{"name":"高等数学","slug":"高等数学","permalink":"http://example.com/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux条件变量和互斥锁实现生产者消费者问题","slug":"Linux条件变量和互斥锁实现生产者消费者问题","date":"2020-08-28T09:30:38.000Z","updated":"2020-11-29T19:35:17.763Z","comments":true,"path":"2020/08/28/Linux条件变量和互斥锁实现生产者消费者问题/","link":"","permalink":"http://example.com/2020/08/28/Linux%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"生产者消费者问题作为多线程多进程同步互斥的经典问题，值得思考。本文使用Linux系统调用，通过互斥锁和条件变量模拟生产者消费者问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;struct Node &#123; int _val; Node *_next; Node(int val, Node *next):_val(val), _next(next) &#123;&#125;&#125;;pthread_mutex_t mtx;pthread_cond_t cond;Node *head=NULL; // 全局变量 为消费者和生产者的互斥共享资源void* func1(void *arg) &#123; while (1) &#123; pthread_mutex_lock(&amp;mtx); // 涉及到访问临界区的访问都需要互斥锁保护 if (!head) &#123; // head==NULL 缓冲区无内容可读 // 阻塞当前线程 并对mutex进行解锁操作 pthread_cond_wait(&amp;cond, &amp;mtx); // 生产者通知消费者消费后 接触阻塞 并对mutex进行加锁操作 &#125; else &#123; // 删除头节点 Node *p = head; head = p-&gt;_next; printf(&quot;consumer: %lu thread, consume %d\\n&quot;, pthread_self(), p-&gt;_val); delete p; p = NULL; &#125; pthread_mutex_unlock(&amp;mtx); &#125; return NULL;&#125;void* func2(void *arg) &#123; while (1) &#123; pthread_mutex_lock(&amp;mtx); Node* p = new Node(rand()%100, head); head = p; printf(&quot;producer: %lu thread, produce %d\\n&quot;, pthread_self(), p-&gt;_val); pthread_mutex_unlock(&amp;mtx); pthread_cond_signal(&amp;cond);// 通知消费者线程缓冲区现在又内容可以读 sleep(rand() % 3); &#125; return NULL;&#125;int main() &#123; srand(time(NULL)); pthread_mutex_init(&amp;mtx, NULL); pthread_cond_init(&amp;cond, NULL); pthread_t consumer, producer; pthread_create(&amp;consumer, NULL, func1, NULL); pthread_create(&amp;producer, NULL, func2, NULL); pthread_join(consumer, NULL); pthread_join(producer, NULL); pthread_cond_destroy(&amp;cond); pthread_mutex_destroy(&amp;mtx); return 0;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"极大连通子图、极小连通子图、极大强连通子图和极小强连通子图","slug":"极大连通子图、极小连通子图、极大强连通子图和极小强连通子图","date":"2020-08-26T01:55:30.000Z","updated":"2020-11-29T19:35:17.731Z","comments":true,"path":"2020/08/26/极大连通子图、极小连通子图、极大强连通子图和极小强连通子图/","link":"","permalink":"http://example.com/2020/08/26/%E6%9E%81%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%E3%80%81%E6%9E%81%E5%B0%8F%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%E3%80%81%E6%9E%81%E5%A4%A7%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%E5%92%8C%E6%9E%81%E5%B0%8F%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE/","excerpt":"","text":"一、极大连通子图 （1）极大连通子图是连通图的一个连通分量，连通分量本身是一个连通图。（2）连通图的极大连通子图只有一个就是其本身，是唯一的。（3）非连通的极大连通子图有多个，每一个都是一个连通图。为什么称为极大？如果将连通分量外的任意一个顶点添加进连通分量都会造成不连通。 二、极小连通子图（1）一个连通图的生成树是该连通图的极小连通子图。同一个连通图可以有不同的生成树，所以生成树不是唯一的。（2）极小连通子图=生成树，则有n个顶点，必然有n-1条边。（3）为什么称为最小？如果去极小连通子图的一条边就无法构成树，不满足树的定义。意味着在极小连通子图中每一条边都是必不可少的。如果给极小连通子图增加一条边，n个节点，n条边，则必然会构成环。意味只有能够连通图中所有顶点而又不会构成回路的任意的子图都是他的生成树。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"protobuf的使用(三)","slug":"protobuf的使用(三)","date":"2020-05-30T03:25:29.000Z","updated":"2020-11-29T19:35:17.755Z","comments":true,"path":"2020/05/30/protobuf的使用(三)/","link":"","permalink":"http://example.com/2020/05/30/protobuf%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%89)/","excerpt":"","text":"rpc方法的序列化和反序列化 rpc标签 在protobuf中定义描述rpc方法的类型 - service 在proto文件中增加rpc服务的选项 12&#x2F;&#x2F; 表示生成service服务类和rpc方法描述，默认是不生成的option cc_generic_services &#x3D; true; 123456789message LoginRequest&#123;&#125;message LoginResponse&#123;&#125;message ExitRequest&#123;&#125;message ExitResponse&#123;&#125;service UserServiceRpc &#123; rpc Login(LoginRequest) returns(LoginResponse); rpc Exit(ExitRequest) returns(ExitResponse);&#125; ** **","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"protobuf的使用(二)","slug":"protobuf的使用(二)","date":"2020-05-30T02:35:28.000Z","updated":"2020-11-29T19:35:18.271Z","comments":true,"path":"2020/05/30/protobuf的使用(二)/","link":"","permalink":"http://example.com/2020/05/30/protobuf%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%BA%8C)/","excerpt":"","text":"1.定义字符串一般不使用string,使用bytes来代替string。若定义为string,proto底层还是会把string-&gt;bytes，虽然不会影响结果，但是在一定程度上还是会浪费效率。 2.其他的数据类型，基本数据，列表，映射表 3.为成员变量设置值test.proto 1234567891011121314151617181920message Error &#123; int32 errorCode &#x3D; 1; bytes errorMsg &#x3D; 2;&#125;message User &#123; bytes name &#x3D; 1; int32 age &#x3D; 2; enum Sex &#123; MAN &#x3D; 0; WOMAN &#x3D; 1; &#125; Sex sex &#x3D; 3;&#125;message GetUserList &#123; Error error &#x3D; 1; repeated User list &#x3D; 2;&#x2F;&#x2F; repeated表示列表&#125; main.cc 1234567891011121314int main() &#123; GetUserList p; Error* err &#x3D; p.mutable_error(); err-&gt;set_errorcode(1); err-&gt;set_errormsg(&quot;xxx&quot;); User* user &#x3D; p.add_list(); user-&gt;set_age(10); user-&gt;set_name(&quot;zhangsan&quot;); user-&gt;set_sex(User::MAN); cout &lt;&lt; p.list_size() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"protobuf的使用(一)","slug":"protobuf的使用(一)","date":"2020-05-30T01:26:35.000Z","updated":"2020-11-29T19:35:18.279Z","comments":true,"path":"2020/05/30/protobuf的使用(一)/","link":"","permalink":"http://example.com/2020/05/30/protobuf%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%80)/","excerpt":"","text":"一、protobuf简介protobuf (protocol buffer)是google公司实现的一种数据交换的格式，由于其是一种二进制的格式，相对于xml,json进行数据交换要快很多，且占用存储空间更小。因此可以把它用于分布式应用之间的数据通信的数据交换格式，作为一种效率和兼容性都非常优秀的二进制数据传输格式。 二、protobuf的基础语法及编译命令由于protobuf独立于平台语言，Google为其提供了多种语言的实现，包括Java,C++,Go,Python等，并且为每一种实现都包含了相应语言的编译器和库文件，方便不同语言开发者的使用。 (1)基础语法 12345678910111213syntax &#x3D; &quot;proto3&quot;;package testprotobuf;message Person &#123; string name &#x3D; 1; &#x2F;&#x2F; 字符串类型 int32 age &#x3D; 2; &#x2F;&#x2F; int32类型 enum Sex &#123; &#x2F;&#x2F;枚举类型 MAN &#x3D; 0; WOMAN &#x3D; 1; &#125; Sex sex &#x3D; 3; bool flag &#x3D; 4; &#x2F;&#x2F; bool类型&#125; (2)编译使用protoc讲proto文件，编译生成C++的源文件和头文件，如对test1.proto进行编译：protoc test1.proto --cpp_out=./生成test1.pb.cc和test1.pb.h文件 三、使用proto文件生成的类，对对象进行序列化和反序列化 (1)序列化 123456789101112131415161718192021#include &quot;test1.pb.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;using namespace testprotobuf;int main() &#123; Person p; p.set_age(10); p.set_name(&quot;zhangsan&quot;); p.set_sex(testprotobuf::Person::MAN); p.set_flag(false); &#x2F;&#x2F; 序列化 std::string msg; if (p.SerializeToString(&amp;msg)) &#123; cout &lt;&lt; msg.c_str() &lt;&lt; endl; &#125;&#125; g++ main.cc test1.pb.cc -lprotobuf -o main (2)反序列化 12345678910111213141516171819202122232425262728293031#include &quot;test1.pb.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;using namespace testprotobuf;int main() &#123; Person p; p.set_age(10); p.set_name(&quot;zhangsan&quot;); p.set_sex(testprotobuf::Person::MAN); p.set_flag(false); &#x2F;&#x2F; 序列化 std::string msg; if (p.SerializeToString(&amp;msg)) &#123; cout &lt;&lt; msg.c_str() &lt;&lt; endl; &#125; &#x2F;&#x2F; 反序列化 Person p1; if (p1.ParseFromString(msg)) &#123; cout &lt;&lt; p1.name() &lt;&lt; endl; cout &lt;&lt; p1.age() &lt;&lt; endl; cout &lt;&lt; p1.sex() &lt;&lt; endl; cout &lt;&lt; p1.flag() &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"C++关键字mutable和explicit","slug":"C++关键字mutable和explicit","date":"2020-05-22T01:20:42.000Z","updated":"2020-11-29T19:35:18.283Z","comments":true,"path":"2020/05/22/C++关键字mutable和explicit/","link":"","permalink":"http://example.com/2020/05/22/C++%E5%85%B3%E9%94%AE%E5%AD%97mutable%E5%92%8Cexplicit/","excerpt":"","text":"mutuble:使得变量可以修改，不能修饰被static和const的变量。一般在类的常方法中，尽管常方法不允许我们修改类中的任何变量，但是有时候由于实际场景的需求，还是需要对某一或某几个变量进行修改，这时候就可以使用mutable来修饰对应的变量了。 explicit:禁止类构造函数进行自动隐式转换，这样可能造成歧义。1.对于单个无默认参数的构造函数适用。2.对于多个无默认值参数的构造函数不适用。3.对于多个参数的构造函数，如果第一个参数未给出默认值，而其余所有的参数都给出了默认值同样适用。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"PAT（乙级）1047.编程团体赛（20）","slug":"PAT（乙级）1047.编程团体赛（20）","date":"2020-05-06T00:02:02.000Z","updated":"2020-11-29T19:35:18.315Z","comments":true,"path":"2020/05/06/PAT（乙级）1047.编程团体赛（20）/","link":"","permalink":"http://example.com/2020/05/06/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891047.%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1047.编程团体赛（20） 编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。现给定所有队员的比赛成绩，请你编写程序找出冠军队。 输入格式：输入第一行给出一个正整数 N（≤10^4），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。 输出格式：在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。 输入样例： 123456763-10 9911-5 87102-1 0102-3 10011-9 893-2 61 输出样例： 111 176 题目分析：数组hash的使用，这个题目队员编号没啥意义，统计成绩。找最大值及其下标即可。 AC代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int max_n &#x3D; 1000;int arr[max_n] &#x3D; &#123;0&#125;;int main()&#123; int n, a, b, score; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d-%d %d&quot;, &amp;a, &amp;b, &amp;score); arr[a] +&#x3D; score; &#125; int max_score, index; for(int i&#x3D;1; i&lt;&#x3D;1000; ++i)&#123; if(arr[i]&gt;max_score)&#123; index &#x3D; i; max_score &#x3D; arr[i]; &#125; &#125; cout&lt;&lt;index&lt;&lt;&quot; &quot;&lt;&lt;max_score&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"信号量","slug":"信号量","date":"2020-05-05T23:58:56.000Z","updated":"2020-11-29T19:35:18.303Z","comments":true,"path":"2020/05/06/信号量/","link":"","permalink":"http://example.com/2020/05/06/%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"头文件：include &lt;semaphore.h&gt;主要的函数： 1.初始化信号量函数原型：int sem_init(sem_t* sem,int pshared,unsigned int value)参数：sem:指定是哪一个信号量pshared:指定信号量的类型，值为0表示是在当前进程使用的局部信号量，否则该信号量就可以在多个进程中共享。value:指定信号量的初始值，可以理解为最多由多少个线程可以访问共享资源。返回值： 2.销毁信号量函数原型：int sem_destroy(sem_t* sem)函数功能：释放信号量占用的内核资源，注意不能释放正在被线程其他等待的信号量，否则会出现错误。返回值： 3.加锁函数原型：int sem_wait(sem_t* sem)函数功能：对信号量的值value进行-1操作，相当于p操作。如果value的值为0，会发生阻塞。 4.尝试加锁函数原型：int sem_trywait(sem_t* sem)函数功能：对信号量的值value进行-1操作，相当于p操作。如果value的值为0，会立即返回，不发生阻塞。 5.解锁函数原型：int sem_post(sem_t* sem)函数功能：对信号量的值value进行+1操作，相当于v操作。当信号量的值value大于0时，其他调用sem_wait()正在等待信号量的线程将被唤醒。 线程级信号量相对于互斥锁对于线程的控制尺度更大，在sem_init()第三个参数可以控制同时访问共享资源的线程的个数，通过这个参数，可以实现同步控制、互斥、以及阻塞。 比如两个线程协同工作，只有在一个工作线程完成对共享资源的访问操作之后，另外一个工作线程才可以对共享资源做访问。还有比如只有当事件发生后才能让线程开始工作，需要让线程在此之间处于阻塞的状态，一旦事件发生后，唤醒等待的线程即可开始工作。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"面试题05. 替换空格","slug":"面试题05. 替换空格","date":"2020-05-05T14:33:49.000Z","updated":"2020-11-29T19:35:18.343Z","comments":true,"path":"2020/05/05/面试题05. 替换空格/","link":"","permalink":"http://example.com/2020/05/05/%E9%9D%A2%E8%AF%95%E9%A2%9805.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例1： 12输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 10 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000 简单题，直接遍历时间复杂度为O(n),空间复杂度为O(n) 1234567891011class Solution &#123;public: string replaceSpace(string s) &#123; string res; for (int i&#x3D;0; i&lt;s.size(); ++i) &#123; if (s[i] &#x3D;&#x3D; &#39; &#39;) res +&#x3D; &quot;%20&quot;; else res +&#x3D; s[i]; &#125; return res; &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"面试题04. 二维数组中的查找","slug":"面试题04. 二维数组中的查找","date":"2020-05-05T14:07:07.000Z","updated":"2020-11-29T19:35:18.291Z","comments":true,"path":"2020/05/05/面试题04. 二维数组中的查找/","link":"","permalink":"http://example.com/2020/05/05/%E9%9D%A2%E8%AF%95%E9%A2%9804.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例： 12345678910现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target &#x3D; 5，返回 true。给定 target &#x3D; 20，返回 false。 限制： 120 &lt;&#x3D; n &lt;&#x3D; 10000 &lt;&#x3D; m &lt;&#x3D; 1000 方法一(二分查找)：给出的矩阵，每行每列都是递增有序的。因此可以按行或按列进行二分查找。按行进行二分查找，时间复杂度为O(nlogm) 12345678910111213141516171819class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; for (int i&#x3D;0; i&lt;matrix.size(); ++i) &#123; if (binarySearch(matrix[i], 0, matrix[i].size()-1, target)) return true; &#125; return false; &#125; bool binarySearch(vector&lt;int&gt;&amp; a, int l, int r, int x) &#123; while (l &lt;&#x3D; r) &#123; int m &#x3D; (r-l)&#x2F;2 + l; if (a[m] &#x3D;&#x3D; x) return true; else if (a[m] &lt; x) l &#x3D; m+1; else if (a[m] &gt; x) r &#x3D; m-1; &#125; return false; &#125;&#125;; 方法二：从右上角开始，如果当前元素大于target，列向左移动。如果当前元素小于target，行向下移动。如果相等，返回true。如果越界后还是未找到target，则返回false时间复杂度O(n+m) 1234567891011121314class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; a, int target) &#123; if (!a.size()) return false; int n &#x3D; a.size(), m &#x3D; a[0].size(); int row &#x3D; 0, col &#x3D; m-1; while (row &lt; n &amp;&amp; col &gt;&#x3D; 0) &#123; if (a[row][col] &gt; target) col --; else if (a[row][col] &lt; target) row ++; else return true; &#125; return false; &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"面试题03. 数组中重复的数字","slug":"面试题03. 数组中重复的数字","date":"2020-05-05T13:32:16.000Z","updated":"2020-11-29T19:35:18.307Z","comments":true,"path":"2020/05/05/面试题03. 数组中重复的数字/","link":"","permalink":"http://example.com/2020/05/05/%E9%9D%A2%E8%AF%95%E9%A2%9803.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"找出数组中重复的数字在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 12 &lt;&#x3D; n &lt;&#x3D; 100000 方法一（hash计数)： 空间复杂度为O(n),时间复杂度为O(n),典型的以空间换时间的策略 12345678910111213class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; a) &#123; int n &#x3D; a.size(); int hash[n]; for (int i&#x3D;0; i&lt;n; ++i) hash[i] &#x3D; 0; for (int i&#x3D;0; i&lt;n; ++i) hash[a[i]] ++; for (int i&#x3D;0; i&lt;n; ++i) &#123; if (hash[i] &gt; 1) return i; &#125; return -1; &#125;&#125;; 方法二 .排序,比较相邻元素 空间复杂度为O(1),时间复杂度为O(nlogn) 12345678910class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; a) &#123; sort(a.begin(), a.end()); for (int i&#x3D;1; i&lt;a.size(); ++i) &#123; if (a[i] &#x3D;&#x3D; a[i-1]) return a[i]; &#125; return -1; &#125;&#125;; 方法三 .抽屉原理 利用题目已知的条件，数组长度为n，且数组内所有元素的范围为0~n-1。利用这个特性，将值为x的元素放置在a[x]中，在放置的过程中，如果a[x]==a[a[x]] (a[x]作为索引)，说明有重复。否则，交换a[x]与a[a[x]]。 12345678910111213class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; a) &#123; int n &#x3D; a.size(); for (int i&#x3D;0; i&lt;n; ++i) &#123; while (i !&#x3D; a[i]) &#123; if (a[i] &#x3D;&#x3D; a[a[i]]) return a[i]; swap(a[i], a[a[i]]); &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"x86保护模式下的内存分段的地址映射","slug":"x86保护模式下的内存分段的地址映射","date":"2020-03-13T06:54:54.000Z","updated":"2020-11-29T19:35:18.619Z","comments":true,"path":"2020/03/13/x86保护模式下的内存分段的地址映射/","link":"","permalink":"http://example.com/2020/03/13/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/","excerpt":"","text":"阅读此文，先熟悉x86体系早期的实模式下的内存分段的地址映射。 正是由于在实模式下直接对物理内存进行读写，非常不安全，所以诞生了新的内存分段的映射方式，其目的就是对物理内存进行保护，而对内存进行保护需要注意的是一下三点：1.内存的起始地址。2.内存的长度。3.内存的权限信息。 此时CPU的架构已经来到了32位，寻址能力达到了2^32=4G。此前的分段地址映射的模式已经不再适用，但是Intel x86的CPU为了能够保证整个体系向前兼容的能力，所以它并不能删除80386之前已有的CPU内部寄存器，如段寄存器CS,DS,SS。它的解决办法是对已有的段寄存器做出新的定义。 保护模式下内存分段的地址映射的模式：段描述符+段表。其中段表是由段表项组成的，那么有多少个段表项？，段表项具体描述了什么信息？，每个段表项有多大字节？，段表的起始地址在哪里存放？，带着这些个问题，接下来一一分析。 (1)对段寄存器的重新定义，即段描述符：从上图可以看到段表的下标的最大值为2^13=8192个，但是由于Linux内核使用了12个，那么剩余了8180个段表项可以被使用。(2)因为8086中的段寄存器已经被重新定义，所以80386扩充了新的寄存器LDTR,GDTR寄存器，用于存放段表的起始地址。 (3)段表项是如何定义的？接下来看段表项描述符:可以看到段表项大小为64位，即8字节大小。其中地址信息占用32位，描述段长度信息占用20，2^20=1M，但是具体能够描述多大的段，它的单位是由G位来决定的，G=0表示描述的单位是字节，即描述段大小位1MB。G=1表述描述的单位是一个页面4KB,此时1M*4KB=4GB，刚刚是32位下整个寻址空间大小。 x86保护模式下内存分段和内存分页的地址映射的工作流程： 1.通过段寄存右移三位，获得在段表中的下标。2.根据段寄存的TI判断使用GTRD或LDTR。3.从LDTR或GTRD中拿到段描述符表的起始地址。4.如TI=0使用GDT, GDTR[CS&gt;&gt;3].BaseAddress + IP(需要与length做比较，方式越界) = 线性地址，由于此处没有分页的机制，线性地址就是物理地址。可以直接进行访问了。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"x86体系早期的实模式下的内存分段的地址映射","slug":"x86体系早期的实模式下的内存分段的地址映射","date":"2020-03-13T06:05:30.000Z","updated":"2020-11-29T19:35:18.315Z","comments":true,"path":"2020/03/13/x86体系早期的实模式下的内存分段的地址映射/","link":"","permalink":"http://example.com/2020/03/13/x86%E4%BD%93%E7%B3%BB%E6%97%A9%E6%9C%9F%E7%9A%84%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/","excerpt":"","text":"实模式：程序员可以直接在物理地址上进行编写程序，此时还没有操作系统进行内存的管理。 实模式下的CPU架构为：8086，16位数据总线，20位的地址总线。可寻址空间大小为2^20=1M，但是由于数据总线仅仅支持16位，而由CPU法出的地址却是20位，为了使得地址位数为16。8086进行了这样的规定：物理内存的地址必须是16的倍数，也就是说经过分段，段大小在这个区间[16, 2^16=64k]。这样做的好处是，地址是16的倍数意味着地址的二进制形式其第四位是0，这样一来，多余的4位0可以不用表示，那么就可以用16位的数据总线来传输20位的物理内存地址。 8086常用的段寄存器(都是16位的): DS(数据段寄存器)，CS(代码段寄存器)，SS(堆栈段寄存器)。 实模式内存分段的管理：由于段寄存器都是16位的，在实际由CPU发出的地址是类似这样的，DS&lt;&lt;4 + IP = 物理地址， 通过这样的方式进行物理内存的访问。其中，DS&lt;&lt;4也称之为段基址，IP为偏移量，偏移地址，逻辑地址(它表示的在内存的一个段上的偏移量)。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"fork与缓冲区的问题","slug":"fork与缓冲区的问题","date":"2020-02-14T06:42:51.000Z","updated":"2020-11-29T19:35:18.919Z","comments":true,"path":"2020/02/14/fork与缓冲区的问题/","link":"","permalink":"http://example.com/2020/02/14/fork%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"(1)在分析这个问题之前，先得熟悉一下缓冲区以及标准I/O中printf相关的问题。printf行缓冲的概念以及刷新缓冲区的条件 (2)关于fork,在本例分析中只需要记住一点，fork之后子进程的地址空间中是拷贝了父进程的缓冲区的。 例1： 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;assert.h&gt;int main() &#123; for (int i&#x3D;0; i&lt;2; ++i) &#123; fork(); printf(&quot;A\\n&quot;); &#x2F;&#x2F;注意此处有\\n, 直接刷新到标准输出中 &#125; return 0;&#125; 执行结果：由执行结果，上述例1共输出六个A。下面我们来分析一下：由上图能够很直观看到为什么会输出六个A。 例2： 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;assert.h&gt;int main() &#123; for (int i&#x3D;0; i&lt;2; ++i) &#123; fork(); printf(&quot;A&quot;); \\\\注意此处未加换行符 &#125; return 0;&#125; 执行结果：看执行结果，相对于增加换行符的printf多输出了两个A，这是为什么？ 文章的开头已经提及，fork出来的子进程会拷贝父进程的缓冲区。只要能把握住这一点，就能分析出原因来。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"记录Linux编程中遇到的问题","slug":"记录Linux编程中遇到的问题","date":"2020-02-13T13:47:32.000Z","updated":"2020-11-29T19:35:18.851Z","comments":true,"path":"2020/02/13/记录Linux编程中遇到的问题/","link":"","permalink":"http://example.com/2020/02/13/%E8%AE%B0%E5%BD%95Linux%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"vim支持系统剪贴板sudo apt-get intall vim-gui-common gcc编译mysql程序gcc test.c -o test -L /usr/lib/mysql -lmysqlclient ubuntu安装MySQL开发的库和头文件sudo apt-get install libmysqlclient-dev vs查看类的内存布局 12cl -d1reportSingleClassLayout[类名称] xxx.cpp例如：cl -d1reportSingleClassLayoutB 继承和多态.cpp ubuntu查找需要按照的软件apt-cache search xxx","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"SGI STL二级空间配置器--内存池源码剖析","slug":"SGI STL二级空间配置器--内存池源码剖析","date":"2020-02-11T05:09:24.000Z","updated":"2020-11-29T19:35:18.919Z","comments":true,"path":"2020/02/11/SGI STL二级空间配置器--内存池源码剖析/","link":"","permalink":"http://example.com/2020/02/11/SGI%20STL%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8--%E5%86%85%E5%AD%98%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"一、STL容器一级空间配置器 通过SGI STL vector底层源码逐步分析内存池。事实上，在我们使用STL容器时，有一点没有关心到的是我们默认使用了标准库里边的空间配置器，当然标准这样的做法是为了减少学习成本，但是当我们深入学习时，就一定要明白这些容器底层是如何工作，才能注重效率，才能用好STL容器。正如侯捷先生所说”源码之后，了无秘密。”， 下面通过vector容器先看一级空间配置器： 在上图，可以看到在一级空间配置器中，construct和destroy,对容器对象的构造和析构，其中构造使用了定位new的方式，在指定的内存上进行对象的构造，construct调用了p-&gt;~T(),这是由于析构函数名和类型是一样的。而allocate和deallocate虽然又封装了一层_Alloc,但是通过源码我们可以发现，实际上一级空间配置器的底层还是malloc和free在做内存的开辟和释放。 二、二级空间配置器（内存池的分析）跟踪源码，到现在可以看到__default_alloc_template正是我们所要分析的二级空间配置器的管理类，下面首先给出管理类的源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113template &lt;bool threads, int inst&gt;class __default_alloc_template &#123;private: &#x2F;&#x2F; Really we should use static const int x &#x3D; N &#x2F;&#x2F; instead of enum &#123; x &#x3D; N &#125;, but few compilers accept the former.#if ! (defined(__SUNPRO_CC) || defined(__GNUC__)) enum &#123;_ALIGN &#x3D; 8&#125;; enum &#123;_MAX_BYTES &#x3D; 128&#125;; enum &#123;_NFREELISTS &#x3D; 16&#125;; &#x2F;&#x2F; _MAX_BYTES&#x2F;_ALIGN# endif static size_t _S_round_up(size_t __bytes) &#123; return (((__bytes) + (size_t) _ALIGN-1) &amp; ~((size_t) _ALIGN - 1)); &#125;__PRIVATE: union _Obj &#123; union _Obj* _M_free_list_link; char _M_client_data[1]; &#x2F;* The client sees this. *&#x2F; &#125;;private:# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC) static _Obj* __STL_VOLATILE _S_free_list[]; &#x2F;&#x2F; Specifying a size results in duplicate def for 4.1# else static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; # endif static size_t _S_freelist_index(size_t __bytes) &#123; return (((__bytes) + (size_t)_ALIGN-1)&#x2F;(size_t)_ALIGN - 1); &#125; &#x2F;&#x2F; Returns an object of size __n, and optionally adds to size __n free list. static void* _S_refill(size_t __n); &#x2F;&#x2F; Allocates a chunk for nobjs of size size. nobjs may be reduced &#x2F;&#x2F; if it is inconvenient to allocate the requested number. static char* _S_chunk_alloc(size_t __size, int&amp; __nobjs); &#x2F;&#x2F; Chunk allocation state. static char* _S_start_free; static char* _S_end_free; static size_t _S_heap_size;# ifdef __STL_THREADS static _STL_mutex_lock _S_node_allocator_lock;# endif &#x2F;&#x2F; It would be nice to use _STL_auto_lock here. But we &#x2F;&#x2F; don&#39;t need the NULL check. And we do need a test whether &#x2F;&#x2F; threads have actually been started. class _Lock; friend class _Lock; class _Lock &#123; public: _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125; ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125; &#125;;public: &#x2F;* __n must be &gt; 0 *&#x2F; static void* allocate(size_t __n) &#123; void* __ret &#x3D; 0; if (__n &gt; (size_t) _MAX_BYTES) &#123; __ret &#x3D; malloc_alloc::allocate(__n); &#125; else &#123; _Obj* __STL_VOLATILE* __my_free_list &#x3D; _S_free_list + _S_freelist_index(__n); &#x2F;&#x2F; Acquire the lock here with a constructor call. &#x2F;&#x2F; This ensures that it is released in exit or during stack &#x2F;&#x2F; unwinding.# ifndef _NOTHREADS &#x2F;*REFERENCED*&#x2F; _Lock __lock_instance;# endif _Obj* __RESTRICT __result &#x3D; *__my_free_list; if (__result &#x3D;&#x3D; 0) __ret &#x3D; _S_refill(_S_round_up(__n)); else &#123; *__my_free_list &#x3D; __result -&gt; _M_free_list_link; __ret &#x3D; __result; &#125; &#125; return __ret; &#125;; &#x2F;* __p may not be 0 *&#x2F; static void deallocate(void* __p, size_t __n) &#123; if (__n &gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else &#123; _Obj* __STL_VOLATILE* __my_free_list &#x3D; _S_free_list + _S_freelist_index(__n); _Obj* __q &#x3D; (_Obj*)__p; &#x2F;&#x2F; acquire lock# ifndef _NOTHREADS &#x2F;*REFERENCED*&#x2F; _Lock __lock_instance;# endif &#x2F;* _NOTHREADS *&#x2F; __q -&gt; _M_free_list_link &#x3D; *__my_free_list; *__my_free_list &#x3D; __q; &#x2F;&#x2F; lock is released here &#125; &#125; static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);&#125; ; 未完待续。。。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C++空间配置器","slug":"C++空间配置器","date":"2020-02-11T04:11:40.000Z","updated":"2020-11-29T19:35:18.919Z","comments":true,"path":"2020/02/11/C++空间配置器/","link":"","permalink":"http://example.com/2020/02/11/C++%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/","excerpt":"","text":"空间配置器的作用：（1）将对象构造和内存开辟进行分离。（2）将对象析构和内存释放进行分离。 空间配置器的主要函数：1.allocate：进行内存的开辟，底层调用的就是malloc。2.deallocate：进行内存的释放，底层调用的就是free。3.construct ：使用定位new来负责给容器中的对象进行构造。4.destroy：负责析构容器中的对象。p-&gt;~T()。 空间配置器的简单实现： 123456789101112131415161718192021222324template &lt;typename T&gt;class Allocator &#123;public: &#x2F;&#x2F; 负责内存开辟 T* allocate(size_t size) &#123; return (T*)malloc(sizeof(T) * size); &#125; &#x2F;&#x2F; 负责内存释放 void deallocate(void* p) &#123; free(p); &#125; &#x2F;&#x2F; 既可以接收左值也可以接收右值 template &lt;typename Ty&gt; void construct(T* p, Ty&amp;&amp; val) &#123; new (p) T(std::forward&lt;Ty&gt;(val)); &#125; &#x2F;&#x2F; 对象析构 void destroy(T* p) &#123; p-&gt;~T(); &#x2F;&#x2F; ~T() 代表了T类型的析构函数 &#125;&#125;;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"TCP三次握手","slug":"TCP三次握手","date":"2020-02-06T08:22:24.000Z","updated":"2020-11-29T19:35:18.899Z","comments":true,"path":"2020/02/06/TCP三次握手/","link":"","permalink":"http://example.com/2020/02/06/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"Linux-errno合集，各种errno对应的出错问题，方便查询","slug":"Linux-errno合集，各种errno对应的出错问题，方便查询","date":"2020-02-06T06:58:23.000Z","updated":"2020-11-29T19:46:17.803Z","comments":true,"path":"2020/02/06/Linux-errno合集，各种errno对应的出错问题，方便查询/","link":"","permalink":"http://example.com/2020/02/06/Linux-errno%E5%90%88%E9%9B%86%EF%BC%8C%E5%90%84%E7%A7%8Derrno%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%EF%BC%8C%E6%96%B9%E4%BE%BF%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#define EPERM 1 &#x2F;* Operation not permitted *&#x2F;#define ENOENT 2 &#x2F;* No such file or directory *&#x2F;#define ESRCH 3 &#x2F;* No such process *&#x2F;#define EINTR 4 &#x2F;* Interrupted system call *&#x2F;#define EIO 5 &#x2F;* I&#x2F;O error *&#x2F;#define ENXIO 6 &#x2F;* No such device or address *&#x2F;#define E2BIG 7 &#x2F;* Arg list too long *&#x2F;#define ENOEXEC 8 &#x2F;* Exec format error *&#x2F;#define EBADF 9 &#x2F;* Bad file number *&#x2F;#define ECHILD 10 &#x2F;* No child processes *&#x2F;#define EAGAIN 11 &#x2F;* Try again *&#x2F;#define ENOMEM 12 &#x2F;* Out of memory *&#x2F;#define EACCES 13 &#x2F;* Permission denied *&#x2F;#define EFAULT 14 &#x2F;* Bad address *&#x2F;#define ENOTBLK 15 &#x2F;* Block device required *&#x2F;#define EBUSY 16 &#x2F;* Device or resource busy *&#x2F;#define EEXIST 17 &#x2F;* File exists *&#x2F;#define EXDEV 18 &#x2F;* Cross-device link *&#x2F;#define ENODEV 19 &#x2F;* No such device *&#x2F;#define ENOTDIR 20 &#x2F;* Not a directory *&#x2F;#define EISDIR 21 &#x2F;* Is a directory *&#x2F;#define EINVAL 22 &#x2F;* Invalid argument *&#x2F;#define ENFILE 23 &#x2F;* File table overflow *&#x2F;#define EMFILE 24 &#x2F;* Too many open files *&#x2F;#define ENOTTY 25 &#x2F;* Not a typewriter *&#x2F;#define ETXTBSY 26 &#x2F;* Text file busy *&#x2F;#define EFBIG 27 &#x2F;* File too large *&#x2F;#define ENOSPC 28 &#x2F;* No space left on device *&#x2F;#define ESPIPE 29 &#x2F;* Illegal seek *&#x2F;#define EROFS 30 &#x2F;* Read-only file system *&#x2F;#define EMLINK 31 &#x2F;* Too many links *&#x2F;#define EPIPE 32 &#x2F;* Broken pipe *&#x2F;#define EDOM 33 &#x2F;* Math argument out of domain of func *&#x2F;#define ERANGE 34 &#x2F;* Math result not representable *&#x2F;#define EDEADLK 35 &#x2F;* Resource deadlock would occur *&#x2F;#define ENAMETOOLONG 36 &#x2F;* File name too long *&#x2F;#define ENOLCK 37 &#x2F;* No record locks available *&#x2F;#define ENOSYS 38 &#x2F;* Function not implemented *&#x2F;#define ENOTEMPTY 39 &#x2F;* Directory not empty *&#x2F;#define ELOOP 40 &#x2F;* Too many symbolic links encountered *&#x2F;#define EWOULDBLOCK EAGAIN &#x2F;* Operation would block *&#x2F;#define ENOMSG 42 &#x2F;* No message of desired type *&#x2F;#define EIDRM 43 &#x2F;* Identifier removed *&#x2F;#define ECHRNG 44 &#x2F;* Channel number out of range *&#x2F;#define EL2NSYNC 45 &#x2F;* Level 2 not synchronized *&#x2F;#define EL3HLT 46 &#x2F;* Level 3 halted *&#x2F;#define EL3RST 47 &#x2F;* Level 3 reset *&#x2F;#define ELNRNG 48 &#x2F;* Link number out of range *&#x2F;#define EUNATCH 49 &#x2F;* Protocol driver not attached *&#x2F;#define ENOCSI 50 &#x2F;* No CSI structure available *&#x2F;#define EL2HLT 51 &#x2F;* Level 2 halted *&#x2F;#define EBADE 52 &#x2F;* Invalid exchange *&#x2F;#define EBADR 53 &#x2F;* Invalid request descriptor *&#x2F;#define EXFULL 54 &#x2F;* Exchange full *&#x2F;#define ENOANO 55 &#x2F;* No anode *&#x2F;#define EBADRQC 56 &#x2F;* Invalid request code *&#x2F;#define EBADSLT 57 &#x2F;* Invalid slot *&#x2F;#define EDEADLOCK EDEADLK#define EBFONT 59 &#x2F;* Bad font file format *&#x2F;#define ENOSTR 60 &#x2F;* Device not a stream *&#x2F;#define ENODATA 61 &#x2F;* No data available *&#x2F;#define ETIME 62 &#x2F;* Timer expired *&#x2F;#define ENOSR 63 &#x2F;* Out of streams resources *&#x2F;#define ENONET 64 &#x2F;* Machine is not on the network *&#x2F;#define ENOPKG 65 &#x2F;* Package not installed *&#x2F;#define EREMOTE 66 &#x2F;* Object is remote *&#x2F;#define ENOLINK 67 &#x2F;* Link has been severed *&#x2F;#define EADV 68 &#x2F;* Advertise error *&#x2F;#define ESRMNT 69 &#x2F;* Srmount error *&#x2F;#define ECOMM 70 &#x2F;* Communication error on send *&#x2F;#define EPROTO 71 &#x2F;* Protocol error *&#x2F;#define EMULTIHOP 72 &#x2F;* Multihop attempted *&#x2F;#define EDOTDOT 73 &#x2F;* RFS specific error *&#x2F;#define EBADMSG 74 &#x2F;* Not a data message *&#x2F;#define EOVERFLOW 75 &#x2F;* Value too large for defined data type *&#x2F;#define ENOTUNIQ 76 &#x2F;* Name not unique on network *&#x2F;#define EBADFD 77 &#x2F;* File descriptor in bad state *&#x2F;#define EREMCHG 78 &#x2F;* Remote address changed *&#x2F;#define ELIBACC 79 &#x2F;* Can not access a needed shared library *&#x2F;#define ELIBBAD 80 &#x2F;* Accessing a corrupted shared library *&#x2F;#define ELIBSCN 81 &#x2F;* .lib section in a.out corrupted *&#x2F;#define ELIBMAX 82 &#x2F;* Attempting to link in too many shared libraries *&#x2F;#define ELIBEXEC 83 &#x2F;* Cannot exec a shared library directly *&#x2F;#define EILSEQ 84 &#x2F;* Illegal byte sequence *&#x2F;#define ERESTART 85 &#x2F;* Interrupted system call should be restarted *&#x2F;#define ESTRPIPE 86 &#x2F;* Streams pipe error *&#x2F;#define EUSERS 87 &#x2F;* Too many users *&#x2F;#define ENOTSOCK 88 &#x2F;* Socket operation on non-socket *&#x2F;#define EDESTADDRREQ 89 &#x2F;* Destination address required *&#x2F;#define EMSGSIZE 90 &#x2F;* Message too long *&#x2F;#define EPROTOTYPE 91 &#x2F;* Protocol wrong type for socket *&#x2F;#define ENOPROTOOPT 92 &#x2F;* Protocol not available *&#x2F;#define EPROTONOSUPPORT 93 &#x2F;* Protocol not supported *&#x2F;#define ESOCKTNOSUPPORT 94 &#x2F;* Socket type not supported *&#x2F;#define EOPNOTSUPP 95 &#x2F;* Operation not supported on transport endpoint *&#x2F;#define EPFNOSUPPORT 96 &#x2F;* Protocol family not supported *&#x2F;#define EAFNOSUPPORT 97 &#x2F;* Address family not supported by protocol *&#x2F;#define EADDRINUSE 98 &#x2F;* Address already in use *&#x2F;#define EADDRNOTAVAIL 99 &#x2F;* Cannot assign requested address *&#x2F;#define ENETDOWN 100 &#x2F;* Network is down *&#x2F;#define ENETUNREACH 101 &#x2F;* Network is unreachable *&#x2F;#define ENETRESET 102 &#x2F;* Network dropped connection because of reset *&#x2F;#define ECONNABORTED 103 &#x2F;* Software caused connection abort *&#x2F;#define ECONNRESET 104 &#x2F;* Connection reset by peer *&#x2F;#define ENOBUFS 105 &#x2F;* No buffer space available *&#x2F;#define EISCONN 106 &#x2F;* Transport endpoint is already connected *&#x2F;#define ENOTCONN 107 &#x2F;* Transport endpoint is not connected *&#x2F;#define ESHUTDOWN 108 &#x2F;* Cannot send after transport endpoint shutdown *&#x2F;#define ETOOMANYREFS 109 &#x2F;* Too many references: cannot splice *&#x2F;#define ETIMEDOUT 110 &#x2F;* Connection timed out *&#x2F;#define ECONNREFUSED 111 &#x2F;* Connection refused *&#x2F;#define EHOSTDOWN 112 &#x2F;* Host is down *&#x2F;#define EHOSTUNREACH 113 &#x2F;* No route to host *&#x2F;#define EALREADY 114 &#x2F;* Operation already in progress *&#x2F;#define EINPROGRESS 115 &#x2F;* Operation now in progress *&#x2F;#define ESTALE 116 &#x2F;* Stale NFS file handle *&#x2F;#define EUCLEAN 117 &#x2F;* Structure needs cleaning *&#x2F;#define ENOTNAM 118 &#x2F;* Not a XENIX named type file *&#x2F;#define ENAVAIL 119 &#x2F;* No XENIX semaphores available *&#x2F;#define EISNAM 120 &#x2F;* Is a named type file *&#x2F;#define EREMOTEIO 121 &#x2F;* Remote I&#x2F;O error *&#x2F;#define EDQUOT 122 &#x2F;* Quota exceeded *&#x2F;#define ENOMEDIUM 123 &#x2F;* No medium found *&#x2F;#define EMEDIUMTYPE 124 &#x2F;* Wrong medium type *&#x2F;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"进程通信（三）共享内存","slug":"进程通信（三）共享内存","date":"2020-02-02T03:26:14.000Z","updated":"2020-11-29T19:35:18.919Z","comments":true,"path":"2020/02/02/进程通信（三）共享内存/","link":"","permalink":"http://example.com/2020/02/02/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"一、共享内存 共享内存是操作系统直接在物理内存上开辟一段空间作为进程间通信的缓冲区域， 与管道、消息队列等其他进程通信方式相比较，共享内存拥有更高的效率，原因是共享内存的设计是基于物理内存的地址直接进行操作的，这样相比其他方式的IPC省去了重重的系统调用，因此在很大程度上提高了其效率。 二、共享内存原理 当不同进程的虚拟地址空间按照页面的大小加载到内存时，CPU发出的虚拟地址经过MMU(内存管理单元）的地址转换之后，就可以得到对应的物理地址，然后就可以进行访存等一系列操作，而共享内存API就是让不同的进程虚拟地址空间的某部分经过加载然后映射到的是同一块物理内存上，这样就可以使得不同的进程访问同一块物理内存，从而进行不同进程间的进程通信。需要注意的是：由于此时这块用于进程通信的物理内存成为临界区，因此当不同的进程访问时，可能会出现竞态条件，因此为了实现进程同步，当不同进程访问临区时，必须对进程实现互斥和同步操作。这点非常重要，希望能引起重视。 三、共享内存API分析 12345678910111213141516171819shm:share memory共享内存的简写1.shmget函数原型：int shmget(key_t key, size_t size, int shmflg);函数功能：创建新的或者已有的共享内存。参数key:key值，与消息队列所需要的key是一样的，如何得到？请看：(https:&#x2F;&#x2F;blog.csdn.net&#x2F;ASJBFJSB&#x2F;article&#x2F;details&#x2F;104122200)(1)如果key值没有对应的共享内存，创建出来一个新的共享内存，创建的过程实质上就是os在物理内存上划分出一块区域作为贡献内存的存储空间。(2)如果key值已经确定，说明已经有一个共享内存了，是由之前其他进程创建的，此时shmget就是获取该key对应的共享内存。参数size:指定共享内存的大小，一般是指定的是页面大小的整数倍(4k),如果不是，为了方便映射以及内存管理，api会自动将size调整为页面大小的整数倍。参数shmflg:指定权限以及IPC_CREAT。返回值：成功：返回共享内存的唯一标识符。失败：返回-1。 1234567891011121314151617182.shmat函数原型：void *shmat(int shmid, const void *shmaddr, int shmflg);功能：将shmid指向的共享内存的空间映射到当前进程的虚拟地址空间上，并且返回映射后的起始地址。得到这个地址，就可以在此地址上进行读写操作。参数shmid：shmid是由shmget得到标识共享内存的唯一标识符。参数shmaddr：指定映射的起始地址。（1）自己设置映射的起始地址（虚拟地址空间的地址），建议不要使用，因为你是搞不懂在虚拟地址空间中哪里用了，哪里可能还没有使用。（2）传NULL，由操作系统填写映射的地址。因为只有os才知道哪里能够映射，哪里不能映射。参数shmflg：指定映射条件。（1）0：以可读可写的方式进行共享内存的映射。（2）SHM_RDONLY：以只读的方式进行映射。返回值：成功：返回映射地址失败：返回(void*)-1 123453.shmdt函数原型：int shmdt(const void *shmaddr);功能：断开当前进程虚拟地址空间与shmaddr指向的共享内存的映射。参数shmaddr：指向共享内存的指针需要注意的是shmdt并不能进行共享内存区域的删除。需要使用shmctl或者ipcrm进行删除。 1234564.shmctl函数原型：int shmctl(int shmid, int cmd, struct shmid_ds* buf)；函数功能：与消息队列的msgctl功能几乎一样，shmctl也提供了三个命令。IPC_RMID:删除由shmid唯一标识的共享内存区。此时第三个参数不使用，传入NULL。IPC_SET:设置shmid_ds中的三个成员，分别是：shm_perm.uid,shm_perm.gid和shm_perm.mode。IPC_STAT:buf作为传出参数，获取shmid唯一标识的共享内存的shmid_ds结构。 四、共享内存实战代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F; 发送端进程#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define PAGESIZE 4096int main() &#123; int shmid &#x3D; shmget((key_t) 123, PAGESIZE, 0664|IPC_CREAT); assert(shmid !&#x3D; -1); char * p &#x3D; (char*)shmat(shmid, NULL, 0); assert(p !&#x3D; (char*)-1); while (1) &#123; printf(&quot;input: &quot;); fgets(p, PAGESIZE-1, stdin); if (strncmp(p, &quot;end&quot;, 3) &#x3D;&#x3D; 0) break; &#125; shmdt(p); return 0;&#125;&#x2F;&#x2F;接收端进程#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define PAGESIZE 4096int main() &#123; int shmid &#x3D; shmget((key_t) 123, PAGESIZE, 0664|IPC_CREAT); assert(shmid !&#x3D; -1); char * p &#x3D; (char*)shmat(shmid, NULL, 0); assert(p !&#x3D; (char*)-1); while (1) &#123; if (strncmp(p, &quot;end&quot;, 3) &#x3D;&#x3D; 0) break; printf(&quot;%s &quot;, p); sleep(1); &#125; shmdt(p); return 0;&#125; 五、进程安全的探讨 在上述的代码中，由于未对共享内存临界区做不同进程互斥的操作，当操作系统分配给进程的CPU时间片使用完成后，可能会出现当前进程还未完成任务，而另外的进程已经从共享内存中拿走了未完成任务的数据，这样的问题在进程通信中是非常致命的，那么如何解决进程在共享内存的通信过程中实现数据的同步和互斥，避免数据发生混乱的情况呢，请看下篇博客，信号量的使用。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"关于System V进程通信内核对象的删除","slug":"关于System V进程通信内核对象的删除","date":"2020-01-31T07:35:57.000Z","updated":"2020-11-29T19:35:18.827Z","comments":true,"path":"2020/01/31/关于System V进程通信内核对象的删除/","link":"","permalink":"http://example.com/2020/01/31/%E5%85%B3%E4%BA%8ESystem%20V%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A0%E9%99%A4/","excerpt":"","text":"System v ipc的缺点： 当进程结束时，不会自动删除进程通信的内核对象，并且能够使用ipcs命令查看内核对象，如下：由于进程通信内核对象也属于操作系统的资源，如果长期占用并且不使用确实是对操作系统资源的浪费，因此对于不再使用的进程通信内核对象应当及时删除，那么如何删除呢？ （1）重启OS，没啥大毛病，但是不方便。（2）当进程使用完毕后，调用相应的系统API进行删除，当然这里需要注意的是调用的时机，必须是使用完成后。（3）使用ipcs命令，是相对简单可行的方法： 12345678910(1)删除消息队列ipcrm -Q key &#x2F;&#x2F;按照key删除ipcrm -q msgid &#x2F;&#x2F;按照msgid删除(2)删除共享内存ipcrm -M key &#x2F;&#x2F;按照key删除ipcrm -m msgid &#x2F;&#x2F;按照标识符删除 (3)删除信号量ipcrm -S key &#x2F;&#x2F;按照key删除ipcrm -s msgid &#x2F;&#x2F;按照标识符删除 举例分别按key删除和按msgid删除的消息队列的过程:","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"Linux-ipcs命令，查看os进程通信的内核对象信息","slug":"Linux-ipcs命令,查看os进程通信的内核对象信息","date":"2020-01-31T06:43:18.000Z","updated":"2020-11-29T19:42:36.960Z","comments":true,"path":"2020/01/31/Linux-ipcs命令,查看os进程通信的内核对象信息/","link":"","permalink":"http://example.com/2020/01/31/Linux-ipcs%E5%91%BD%E4%BB%A4,%E6%9F%A5%E7%9C%8Bos%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/","excerpt":"","text":"ipcs --help 12345678910111213141516171819202122232425用法： ipcs [资源选项...] [输出选项] ipcs -m|-q|-s -i &lt;id&gt;显示 IPC 设施的信息。选项： -i, --id &lt;id&gt; 打印由&lt;id&gt;标识的资源的详细信息 -h, --help display this help -V, --version display version资源选项： -m, --shmems 共享内存段 -q, --queues 消息队列 -s, --semaphores 信号量 -a, --all 全部(默认)输出选项： -t, --time 显示附加、脱离和更改时间 -p, --pid 显示创建者和最后操作者的 PID -c, --creator 显示创建者和拥有者 -l, --limits 显示资源限制 -u, --summary 显示状态摘要 --human 以易读格式显示大小 -b, --bytes 以字节数显示大小","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux系统编程","slug":"linux系统编程","permalink":"http://example.com/tags/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}]},{"title":"进程通信（二）消息队列（System V 消息队列）","slug":"进程通信（二）消息队列（System V 消息队列）","date":"2020-01-31T06:41:34.000Z","updated":"2020-11-29T19:35:18.919Z","comments":true,"path":"2020/01/31/进程通信（二）消息队列（System V 消息队列）/","link":"","permalink":"http://example.com/2020/01/31/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88System%20V%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/","excerpt":"","text":"一、System V 消息队列简介 消息队列：消息队列的本质是由Linux内核创建用于存放消息的链表，并且其功能是用来存放消息的，所以又称之为消息队列。在Linux的不同进程中，包括有血缘的进程和无血缘的进程，都可以通过Linux消息队列API所得到的消息队列唯一标识符对消息队列进行操作。 二、分析消息队列的数据结构 Linux为了维护消息队列，为消息队列创建了数据结构，接下来我们来分析一下消息队列的结构以及消息队列节点的结构。 消息队列的结构: 123456789101112131415struct msqid_ds &#123; struct ipc_perm msg_perm; &#x2F;&#x2F;消息队列的读写权限和所有者 struct msg *msg_first; &#x2F;&#x2F;指向消息队列链表中的第一个节点 struct msg *msg_last; &#x2F;&#x2F;指向消息队列链表中的最后一个节点 long msg_stime; &#x2F;&#x2F;最近一次从消息队列中取出消息的时间 long msg_rtime; &#x2F;&#x2F;最近一次从消息队列中放入消息的时间 long msg_ctime; &#x2F;&#x2F;最近一次修改消息队列的时间 unsigned long msg_lcbytes; &#x2F;* Reuse junk fields for 32 bit *&#x2F; unsigned long msg_lqbytes; &#x2F;* ditto *&#x2F; unsigned short msg_cbytes; &#x2F;&#x2F;保存着队列总共占用内存的字节数 unsigned short msg_qnum; &#x2F;&#x2F;当前消息队列中消息的个数 unsigned short msg_qbytes; &#x2F;&#x2F;队列所占用内存的最大字节数。 int msg_lspid; &#x2F;&#x2F;最近一次向消息队列发送消息进程的pid int msg_lrpid; &#x2F;&#x2F;最近一次从消息队列接受消息进程的pid&#125;; 消息队列节点的结构： 1234567struct msg &#123; struct msg *msg_next; &#x2F;&#x2F;指向消息队列中下一个消息的指针 long msg_type;&#x2F;&#x2F;消息的类型 char *msg_spot; &#x2F;&#x2F;消息内容在内存中的地址 time_t msg_stime; short msg_ts; &#x2F;&#x2F;消息内容的长度&#125;; struct ipc_perm msg_perm的结构： 12345678910struct ipc_perm&#123; __kernel_key_t key; &#x2F;&#x2F;消息队列的key值 __kernel_uid_t uid; &#x2F;&#x2F;当前这一刻正在使用消息队列的用户 __kernel_gid_t gid; &#x2F;&#x2F;正在使用的用户所在的用户组 __kernel_uid_t cuid; &#x2F;&#x2F;创建消息队列的用户 __kernel_gid_t cgid; &#x2F;&#x2F;创建消息队列用户所在的用户组 __kernel_mode_t mode; &#x2F;&#x2F;读写权限 unsigned short seq; &#x2F;&#x2F;序列号，保证消息队列ID不会被&#125;; 由上边的几个关于消息队列的结构体，我们可以大致画出消息队列的样子：由上图可以直观的感受到Linux内核所设计消息队列的大致模样，这对于我们理解消息队列Linux API有着至关重要的作用。 三、消息队列API分析 12345678910msgget函数1.int msgget(key_t key, int oflag);返回值：唯一的标识符关于参数key和参数oflag,请看下图，参考与《Unix网络编程2.进程通信》key值的指定：(1)指定为IPC_PRIVATE，每次调用msgget都会创建一个新的消息队列，这样的开销比较大，一般情况下，只需要一个消息队列即可，因此此方法不建议使用。(2)指定一个(key_t)value,这个value只要未使用即可，可以通过ipcs -q命令查看已有消息队列的key值，以避免重复使用。(3)使用ftok生成key。 123456789frok函数简介#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;ipc.h&gt;key_t frok(const char *filename, int id);函数功能：ftok通过一个路径名和一个整型值，就可以返回一个唯一对应的key值。只要路径名和整形数不变，key就不变。filename+value(int) -&gt; key由于ftok只会使用整型数id的低八位，所以在使用时指定一个ascii码即可。 12345678910111213msgsnd函数2.int msgsnd(int msqid, const void *ptr, size_t length, int flag);参数msqid是由msgget返回的消息队列的唯一标识符const void* ptr是一个消息包的指针，消息包可以：struct msgbuf&#123; long mtype;&#x2F;&#x2F;消息类型必须大于0 char mtext[1];&#x2F;&#x2F;1个字节肯定是不够用的，因此可以自定义消息包&#125;;length:消息内容的大小flag:（1）0：阻塞发送消息，如果没有发送成功时，该函数会一直阻塞，直到发送成功。（2）IPC_NOWAIT：非阻塞的方式发送消息，无论是否发送成功，函数都会返回，即使发送不成功，函数也会返回。 12345678msgrcv函数3.ssize_t msgrcv(int msqid, void *ptr, size_t length, long type, int flag);参数ptr: 指定接受消息存放的位置。参数length:指定了由ptr指向的缓冲区中数据部分的大小，这是该函数能返回的最大数据量，该长度不包含整型类型字段。参数type:指定希望从所给定的队列中读出什么样的消息。参数flag:指定所请求类型的消息不在指定的队列中应该作何处理。（1）0：阻塞接受消息（2）IPC_NOWAIT:非阻塞接受消息，没有消息时，不阻塞。 1234567msgctl4.int msgctl(int msqid, int cmd, struct msqid_ds* buff);msgctl接口可以使得进程在msqid所标识的消息队列上进行各种控制操作。msgctl的三个命令cmd参数：（1）IPC_RMID：从系统中删除由msqid指定的消息队列。此时第三个参数缺省省略，这个命令可以理解为删除消息队列。（2）IPC_SET，给所指定的消息队列设置其msqid_ds结构体的以下4个成员：msg_perm.uid, msg_perm.gid,msg_perm.mode和msg_gbytes。此时需要自己创建msqid_ds结构体并初始化然后传入。（3）IPC_STAT，此时buff作为传出参数可以获取消息队列消息头中msg_perm结构体的在内核中的内容。 四、代码实战 （1）有血缘关系的进程间通信 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;msg.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;assert.h&gt;typedef struct msgbuf &#123; long mtype; char mtext[128];&#125; MSG;int main() &#123; int msgid &#x3D; msgget((key_t)1235, 0664|IPC_CREAT); assert(msgid !&#x3D; -1); pid_t pid &#x3D; fork(); assert(pid !&#x3D; -1); if (pid &gt; 0) &#123; MSG msg; memset(&amp;msg, 0, sizeof(msg)); msg.mtype &#x3D; 100; strcpy(msg.mtext, &quot;hello&quot;); msgsnd(msgid, &amp;msg, strlen(msg.mtext), 0); &#125; else if (pid &#x3D;&#x3D; 0) &#123; MSG msg; memset(&amp;msg, 0, sizeof(msg)); msgrcv(msgid, &amp;msg, 127, 100, 0); printf(&quot;msg.mtype: %ld\\n&quot;, msg.mtype); printf(&quot;msg.mtext: %s\\n&quot;, msg.mtext); &#125; return 0;&#125; （2）无血缘关系的进程间通信msg_send.c 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;sys&#x2F;msg.h&gt;typedef struct msgdata&#123; long mtype; &#x2F;&#x2F;消息类型 char mtext[128];&#125; MSG;int main() &#123; int id &#x3D; msgget((key_t)1234, IPC_CREAT | 0664); assert(id !&#x3D; -1); MSG msg; memset(&amp;msg, 0, sizeof(msg)); msg.mtype &#x3D; 100; strcpy(msg.mtext, &quot;hello world&quot;); msgsnd(id, &amp;msg, strlen(msg.mtext), 0); memset(&amp;msg, 0, sizeof(msg)); msg.mtype &#x3D; 200; strcpy(msg.mtext, &quot;ni hao, shi jian&quot;); msgsnd(id, &amp;msg, strlen(msg.mtext), 0); return 0;&#125; msg_send.c 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;msg.h&gt;#include &lt;string.h&gt;typedef struct msgdata&#123; long mtype; char mtext[128];&#125;MSG;int main() &#123; int id &#x3D; msgget((key_t)1234, 0664|IPC_CREAT); assert(id !&#x3D; -1); MSG msg; memset(&amp;msg, 0, sizeof(msg)); msgrcv(id, &amp;msg, 127, 200, 0); printf(&quot;msg.mtype: %ld\\n&quot;, msg.mtype); printf(&quot;msg.mtext: %s\\n&quot;, msg.mtext); return 0;&#125; （3）删除消息队列内核对象 1234567使用msgctl来删除消息队列内核对象void msgRemove(int msgid) &#123; int res &#x3D; msgctl(msgid, IPC_RMID, NULL); if (res &#x3D;&#x3D; -1) return -1; else return 0;&#125;","categories":[{"name":"linux 操作系统","slug":"linux-操作系统","permalink":"http://example.com/categories/linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"C++中的new有几种？","slug":"C++中的new有几种？","date":"2020-01-25T01:51:17.000Z","updated":"2020-11-29T19:35:19.139Z","comments":true,"path":"2020/01/25/C++中的new有几种？/","link":"","permalink":"http://example.com/2020/01/25/C++%E4%B8%AD%E7%9A%84new%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F/","excerpt":"","text":"1.普通new形式：int* p = new int;此时不能通过p是否为nullptr来判断内存是否开辟成功，而是需要通过bad_alloc来捕获异常。 2.(nothrow) new形式：int *p = new (nothrow) int(20);此时指针已经退化为C语言中通过malloc开辟内存得到的指针，是可以通过判空来验证是否成功开辟内存。 3.申请指向常量内存的指针的new形式：const int* p = new const int(20); 4.定位new形式：int data = 0;int *p = new (&amp;data) int(20);在已知的内存上进行new。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"具有n个节点的度为m的树的最大高度和最低高度推导","slug":"具有n个节点的度为m的树的最大高度和最低高度推导","date":"2019-11-29T04:23:03.000Z","updated":"2020-11-29T19:35:19.167Z","comments":true,"path":"2019/11/29/具有n个节点的度为m的树的最大高度和最低高度推导/","link":"","permalink":"http://example.com/2019/11/29/%E5%85%B7%E6%9C%89n%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%BA%A6%E4%B8%BAm%E7%9A%84%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6%E5%92%8C%E6%9C%80%E4%BD%8E%E9%AB%98%E5%BA%A6%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"一、最大高度 试想一下，若有n个节点的度为m的树，当只有最后一层有m个节点，其余层均只有一个节点，在所有含有nn个节点的度为m的树中一定是最高的。 二、最低高度 当每个非终端节点均含有m个孩子节点时间，此时整棵树在所有含有n个节点的度为m的树中是最矮胖的，此时这棵树的高度也是含有n个节点度为m的树中高度最低。在极限的状态下可以称之为满m叉树，因此可以推导不等式，得出最低高度。 结论：综上分析，对于一个含有n个节点的度为m的树的高度范围为：ceil(logm((m-1)*n + 1) &lt;= h &lt;= n-m+1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单源最短路径--floyd算法","slug":"单源最短路径--floyd算法","date":"2019-11-27T14:12:31.000Z","updated":"2020-11-29T19:35:19.151Z","comments":true,"path":"2019/11/27/单源最短路径--floyd算法/","link":"","permalink":"http://example.com/2019/11/27/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84--floyd%E7%AE%97%E6%B3%95/","excerpt":"","text":"1234567891011void floyd() &#123; for (int k&#x3D;1; k&lt;&#x3D;n; ++k) &#123; for (int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123; for (int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123; if (i &#x3D;&#x3D; j || i &#x3D;&#x3D; k || j &#x3D;&#x3D; k) continue; &#x2F;&#x2F;避免不必要的判断 提高程序效率 else g[i][j] &#x3D; min(g[i][j], g[i][k]+g[k][j]); &#125; &#125; &#125;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"四大查找ASL的总结","slug":"四大查找ASL的总结","date":"2019-11-26T12:54:44.000Z","updated":"2020-11-29T19:35:19.131Z","comments":true,"path":"2019/11/26/四大查找ASL的总结/","link":"","permalink":"http://example.com/2019/11/26/%E5%9B%9B%E5%A4%A7%E6%9F%A5%E6%89%BEASL%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、一般线性表的顺序查找ASL成功 = (n+1)/2ASL失败 = （n+1) 二、有序线性表的顺序查找ASL成功 = (n+1)/2ASL失败 = n/(n+1) + n/2 三、二分查找二分查找的ASL成功和ASL失败通过画出对应查找序列的判定树，进而进行计算。 四、索引查找ASL = I块内 + I块间其中块间可以使用二分查找。（1）ASL = (b+1)/2 + (s+1)/2 块内和块间均使用顺序查找，由于n = s*b,可以通过构建方程，得到当s = n^(1/2)。ASL最小为n^(1/2)+1 （2）ASL = (s+1)/2 + ceil(log2(b+1)) 块内顺序，块间二分","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构中“哨兵”的使用","slug":"数据结构中“哨兵”的使用","date":"2019-11-26T12:18:33.000Z","updated":"2020-11-29T19:35:19.139Z","comments":true,"path":"2019/11/26/数据结构中“哨兵”的使用/","link":"","permalink":"http://example.com/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E2%80%9C%E5%93%A8%E5%85%B5%E2%80%9D%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.顺序查找中的哨兵：通过引入哨兵，可以必满很多不必要的语句，从而提高程序效率。 2.直接插入排序的哨兵：免去查找过程中每一步都要检测整个查找表是否查找完毕，提高查找效率。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：在孩子兄弟链表表示的树中求叶子节点的个数","slug":"二叉树：在孩子兄弟链表表示的树中求叶子节点的个数","date":"2019-11-24T08:16:06.000Z","updated":"2020-11-29T19:35:19.159Z","comments":true,"path":"2019/11/24/二叉树：在孩子兄弟链表表示的树中求叶子节点的个数/","link":"","permalink":"http://example.com/2019/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%9C%A8%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%A0%91%E4%B8%AD%E6%B1%82%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"1234567891011121314typedef struct CSNode &#123; int val; CSNode *firstchild, *nextsibling;&#125; CSNode, *CSTree;int dfs(CSTree *root) &#123; if (!root) return 0; else if (!root-&gt;firstchild) return 1; else &#123; int left &#x3D; dfs(root-&gt;firstchild); int right &#x3D; dfs(root-&gt;nextsibling); return left + right; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"差分","slug":"差分","date":"2019-11-20T12:33:44.000Z","updated":"2020-11-29T19:35:19.115Z","comments":true,"path":"2019/11/20/差分/","link":"","permalink":"http://example.com/2019/11/20/%E5%B7%AE%E5%88%86/","excerpt":"","text":"题目描述：输入一个长度为n的整数序列。接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。请你输出进行完所有操作后的序列。 输入格式：第一行包含两个整数n和m。第二行包含n个整数，表示整数序列。接下来m行，每行包含三个整数l，r，c，表示一个操作。 输出格式：共一行，包含n个整数，表示最终序列。 数据范围：1≤n,m≤100000,1≤l≤r≤n,−1000≤c≤1000,−1000≤整数序列中元素的值≤1000 样例： 12345678输入样例：6 31 2 2 1 2 11 3 13 5 11 6 1输出样例：3 4 5 3 4 2 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e5+10;int a[N];int d[N];inline int read() &#123; int x &#x3D; 0; int f &#x3D; 1; char ch &#x3D; getchar(); while (!isdigit(ch)) &#123; if (ch &#x3D;&#x3D; &#39;-&#39;) f &#x3D; -1; ch &#x3D; getchar(); &#125; while (isdigit(ch)) &#123; x &#x3D; x*10 + ch-&#39;0&#39;; ch &#x3D; getchar(); &#125; return x * f;&#125;void show(int *a, int n) &#123; for (int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123; cout &lt;&lt; a[i]; if (i!&#x3D;n) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; int n&#x3D;read(), m&#x3D;read(); for (int i&#x3D;1; i&lt;&#x3D;n; ++i) a[i] &#x3D; read(); d[1] &#x3D; a[1]; for (int i&#x3D;1; i&lt;&#x3D;n; ++i) d[i] &#x3D; a[i] - a[i-1]; while (m --) &#123; int l&#x3D;read(), r&#x3D;read(), c&#x3D;read(); d[l] +&#x3D; c; d[r+1] -&#x3D; c; &#125; a[1] &#x3D; d[1]; for (int i&#x3D;2; i&lt;&#x3D;n; ++i) a[i] &#x3D; a[i-1] + d[i]; show(a, n); return 0;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"前缀和","slug":"前缀和","date":"2019-11-20T11:28:01.000Z","updated":"2020-11-29T19:35:19.183Z","comments":true,"path":"2019/11/20/前缀和/","link":"","permalink":"http://example.com/2019/11/20/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"问题描述，现在给定一个闭区间数组，求区间[l,r]的数据元素之和，询问m次，要求线性时间复杂度O(n)。比较常规的思路是使用循环遍历相加，但是一次循环的时间复杂度为O(n),m次询问最终的时间复杂度为O(n*m),显然是不满足要求的。我们可以采用空间换时间的策略，设置一个前缀和数组d,数组中任意位置i表示的是d[i] = a[1] + a[2] + … + a[i],经过这样的预处理，询问任意位置的前缀和的时间复杂度变为O(1),经过m次询问，时间复杂度为O(m)，符合要求。 代码实现： 12345678910111213141516171819202122232425262728293031323334#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e5+10;int a[N];int d[N];inline int read() &#123; int x &#x3D; 0; int f &#x3D; 1; char ch &#x3D; getchar(); while (!isdigit(ch)) &#123; if (ch &#x3D;&#x3D; &#39;-&#39;) f &#x3D; -1; ch&#x3D; getchar(); &#125; while (isdigit(ch)) &#123; x &#x3D; x*10 + ch-&#39;0&#39;; ch &#x3D; getchar(); &#125; return x * f;&#125;int main() &#123; int n &#x3D; read(), m &#x3D; read(); for (int i&#x3D;1; i&lt;&#x3D;n; ++i) a[i] &#x3D; read(); d[1] &#x3D; a[1]; for (int i&#x3D;2; i&lt;&#x3D;n; ++i) d[i] &#x3D; d[i-1] + a[i]; while (m --) &#123; int a&#x3D;read(), b&#x3D;read(); printf(&quot;%d\\n&quot;, d[b]-d[a-1]); &#125; return 0;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"快速读入的技巧","slug":"快速读入的技巧","date":"2019-11-20T06:37:21.000Z","updated":"2020-11-29T19:35:19.151Z","comments":true,"path":"2019/11/20/快速读入的技巧/","link":"","permalink":"http://example.com/2019/11/20/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E7%9A%84%E6%8A%80%E5%B7%A7/","excerpt":"","text":"在OJ上练习题目时，有些题目数据的输入非常大，即便是使用scanf()也会被卡常数，最后导致TLE。因此搜集网上的解决方案，常见的有以下两种： 一、当数据量不是特别大的时间，此时可以关闭stdio的同步，使得cin,cout与printf, scanf一样快。 123核心代码：ios::sync_with_stdio(false)&#x2F;&#x2F;此时注意在程序中不能再使用任何stdio的库函数，否则会造成混乱。 二、当数据量比较大时候采用读字符的形式读取，注意要忽略空格、回车等字符。 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F;写为内联函数 建议编译器不做函数调用，直接展开&#x2F;*毕竟数量大的时，需要一直调用read()读取，如果能成为内联则可以减少函数调用的开销，提高程序的执行效率*&#x2F;inline int read() &#123; int x &#x3D; 0; int f &#x3D; 1;&#x2F;&#x2F;f表示的是整数x的正负 f&#x3D;&#x3D;1表示x为正 f&#x3D;&#x3D;-1表示x为负 char ch &#x3D; getchar(); while (!isdigit(ch)) &#123; &#x2F;&#x2F;如果不是数字字符 只考虑其是否为符号，其他符号不考虑 if (ch &#x3D;&#x3D; &#39;-&#39;) f &#x3D; -1; ch &#x3D; getchar(); &#125; while (isdigit(ch) &#123; &#x2F;&#x2F;说明ch是数字字符 但是有能不是一个只有个数数的数字 x &#x3D; x*10 + ch -&#39;0&#39;; ch &#x3D; getchar(); &#125; return x*f;&#125;&#x2F;&#x2F;函数功能同上，只是直接读取到了引用参数x中template &lt;typename T&gt;inline void read(T &amp;x) &#123; int f &#x3D; 1; x &#x3D; 0; char ch &#x3D; getchar(); while (!isdigit(ch)) &#123; if (ch &#x3D;&#x3D; &#39;-&#39;) &#123; f &#x3D; -1; ch &#x3D; getchar(); &#125; &#125; while (isdigit(ch)) &#123; x &#x3D; x * 10 + ch - &#39;0&#39;; ch &#x3D; getchar(); &#125; x &#x3D; x*f;&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"求解逆序对的个数(由归并排序衍生出的O(nlogn)时间复杂度的算法)","slug":"求解逆序对的个数(由归并排序衍生出的O(nlogn)时间复杂度的算法)","date":"2019-11-19T03:55:40.000Z","updated":"2020-11-29T19:35:19.163Z","comments":true,"path":"2019/11/19/求解逆序对的个数(由归并排序衍生出的O(nlogn)时间复杂度的算法)/","link":"","permalink":"http://example.com/2019/11/19/%E6%B1%82%E8%A7%A3%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0(%E7%94%B1%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%A1%8D%E7%94%9F%E5%87%BA%E7%9A%84O(nlogn)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95)/","excerpt":"","text":"逆序：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。 一、暴力做法 123456789int count(int *a, int n) &#123; int res &#x3D; 0; for (int i&#x3D;0; i&lt;n-1; ++i) &#123; for (int j&#x3D;1; j&lt;n; ++j) &#123; if (a[i] &gt; a[j]) res ++; &#125; &#125; return res;&#125; 可以看到，上边算法的时间复杂度为O(n^2),有没有效率更高的算法呢，其实在归并排序中，当进行两个有序数组合并时就会两两元素的比较。此时会出现，当第一个数组的某元素a[i]大于第二数组中的某元素a[j]时，则一个数组处于[i, m]区间的所有元素都会大于第二个数组的当前元素a[j]。这样做的好处是不需要将数组中的元素依次进行两两比较，一次比较就能处理一个大区间，因此算法的效率得到了提升。 二、归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N&#x3D;1e5+10;ll a[N], t[N];ll res &#x3D; 0;void mergeSort(ll *a, int l, int r) &#123; if (l&gt;&#x3D;r) return; int m &#x3D; (r-l)&#x2F;2 + l; mergeSort(a, l, m); mergeSort(a, m+1, r); &#x2F;&#x2F;i为第一个区间的起始下标 第一个区间[l, m] &#x2F;&#x2F;j为第二个区间的起始下标 第二个区间[m+1, r] &#x2F;&#x2F;k为临时数组的起始下标 int i &#x3D; l, r &#x3D; m+1, k &#x3D; 0; while (i &lt;&#x3D; m &amp;&amp; j &lt;&#x3D; r) &#123; if (a[i] &lt;&#x3D; a[j]) t[k ++] &#x3D; a[i ++]; else &#123; &#x2F;&#x2F;a[i] &gt; a[j] &amp;&amp; i &lt; j 构成了逆序对 而此时 a[i]到a[m]的所有元素均大于a[j] &#x2F;&#x2F;a[i,....,m]的长度为 m-i+1 res +&#x3D; m-i+1; t[k ++] &#x3D; a[j ++]; &#125; &#125; while (i &lt;&#x3D; m) t[k ++] &#x3D; a[i ++]; while (j &lt;&#x3D; r) t[k ++] &#x3D; a[j ++]; for (int i&#x3D;l, k&#x3D;0; i&lt;&#x3D;r; ++i, ++k) a[i] &#x3D; t[k];&#125;int main() &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i&#x3D;0; i&lt;n; ++i) cin &gt;&gt; a[i]; mergeSort(a, 0, n-1); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"趣味编程 算法基础","slug":"趣味编程-算法基础","permalink":"http://example.com/categories/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"常见排序算法的时间复杂度和空间复杂度表","slug":"常见排序算法的时间复杂度和空间复杂度表","date":"2019-11-17T09:54:48.000Z","updated":"2020-11-29T19:35:19.415Z","comments":true,"path":"2019/11/17/常见排序算法的时间复杂度和空间复杂度表/","link":"","permalink":"http://example.com/2019/11/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"严格m叉树（正则m叉树）","slug":"严格m叉树（正则m叉树）","date":"2019-11-13T01:50:31.000Z","updated":"2020-11-29T19:35:19.427Z","comments":true,"path":"2019/11/13/严格m叉树（正则m叉树）/","link":"","permalink":"http://example.com/2019/11/13/%E4%B8%A5%E6%A0%BCm%E5%8F%89%E6%A0%91%EF%BC%88%E6%AD%A3%E5%88%99m%E5%8F%89%E6%A0%91%EF%BC%89/","excerpt":"","text":"严格m叉树：只有度为0的节点和度为m的节点。 如何构造正则m叉树：首先寻找N0节点的个数与Nm节点的个数之间的关系。（1）从节点个数看：N = N0 + Nm（2）从分支数看：N - 1 = mNm联立两个方程得：(m-1)*Nm = N0-1所以：Nm = (N0-1)/(m-1)开始时，有n个节点，即叶子节点有n个。计算Nm=(N0-1)%(m-1)，如果Nm=0则说明刚刚好可以构造成一棵正则m叉树，如果Nm不等于0，则需要设置虚段，虚段的个数是(m - Nm - 1)个。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"链地址法处理hash冲突建立Hash表代码练习","slug":"链地址法处理hash冲突建立Hash表代码练习","date":"2019-11-11T01:50:13.000Z","updated":"2020-11-29T19:35:20.455Z","comments":true,"path":"2019/11/11/链地址法处理hash冲突建立Hash表代码练习/","link":"","permalink":"http://example.com/2019/11/11/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E5%A4%84%E7%90%86hash%E5%86%B2%E7%AA%81%E5%BB%BA%E7%AB%8BHash%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/","excerpt":"","text":"给定一个数组x[] = {4, 1, 3, 7, 8, 22, 45, 75}, 哈希函数为H(key) = key*2 % 11，采用链地址法处理哈希冲突。建立哈希表： 123456789101112131415161718192021222324252627282930#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxsize &#x3D; 11;&#x2F;&#x2F;哈希函数int hash(int x) &#123;return x*2 % maxsize;&#125;struct node &#123; int val; node *next; node() &#123;&#125; node(int x, node *next) &#123; this-&gt;val &#x3D; x; this-&gt;next &#x3D; next; &#125;&#125;;node hashtable[maxsize];int x[] &#x3D; &#123;4, 1, 3, 7, 8, 22, 45, 75&#125;;void chain() &#123; for (int i&#x3D;0; i&lt;maxsize; ++i) hashtable[i].next &#x3D; NULL; int n &#x3D; sizeof(x) &#x2F; sizeof(int); for (int i&#x3D;0; i&lt;n; ++i) &#123; int addr &#x3D; hash(x[i]); auto p &#x3D; new node(x[i], hashtable[addr].next); hashtable[addr].next &#x3D; p; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"B-树查找算法的简单实现","slug":"B-树查找算法的简单实现","date":"2019-11-09T15:36:07.000Z","updated":"2020-11-29T19:35:19.411Z","comments":true,"path":"2019/11/09/B-树查找算法的简单实现/","link":"","permalink":"http://example.com/2019/11/09/B-%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"12345678910111213141516171819202122B-树节点类定义struct node &#123; int n; &#x2F;&#x2F;关键字个数 int key[maxsize]; &#x2F;&#x2F;关键字数组 node *ptr[maxsize+1]; &#x2F;&#x2F;指向孩子节点的指针的数组&#125;;&#x2F;&#x2F;在以root为根节点的B树中查找值为x的节点node *dfs(node *root, int x) &#123; if (!root) return NULL; else &#123; int i &#x3D; 0; while (i &lt; root-&gt;n &amp;&amp; x &gt; root-&gt;key[i]) i ++; &#x2F;&#x2F;在节点内查找 &#x2F;*退出while循环的两种情况 (1)i &#x3D;&#x3D; root-&gt;n 找到最后没找到 (2) 在当前节点内找到了一个关键字值小于等于 目标值x的节点 分情况讨论 *&#x2F; if (i &#x3D;&#x3D; root-&gt;n) return dfs(root-&gt;ptr[i], x); else if (x &#x3D;&#x3D; root-&gt;key[i]) return root; else return dfs(root-&gt;ptr[i], x); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"八皇后--回溯法","slug":"八皇后--回溯法","date":"2019-11-09T07:47:34.000Z","updated":"2020-11-29T19:35:19.419Z","comments":true,"path":"2019/11/09/八皇后--回溯法/","link":"","permalink":"http://example.com/2019/11/09/%E5%85%AB%E7%9A%87%E5%90%8E--%E5%9B%9E%E6%BA%AF%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;8;int chess[N][N];int cnt &#x3D; 0;void init() &#123; for (int i&#x3D;0; i&lt;N; ++i) &#123; for (int j&#x3D;0; j&lt;N; ++j) chess[i][j] &#x3D; 0; &#125;&#125;void print() &#123; for (int i&#x3D;0; i&lt;N; ++i) &#123; for (int j&#x3D;0; j&lt;N; ++j) &#123; cout &lt;&lt; chess[i][j]; if (j !&#x3D; N-1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;bool check(int row, int col) &#123; &#x2F;&#x2F;(1)判断同列是否有queen for (int i&#x3D;0; i&lt;N; ++i) &#123; if (i!&#x3D;row &amp;&amp; chess[i][col]) return false; &#125; &#x2F;&#x2F;(2)判断同行是否有queen for (int i&#x3D;0; i&lt;N; ++i) &#123; if (i!&#x3D;col &amp;&amp; chess[row][i]) return false; &#125; &#x2F;&#x2F;(3)检查左上对角线 for (int i&#x3D;row-1, j&#x3D;col-1; i&gt;&#x3D;0 &amp;&amp; j&gt;&#x3D;0; --i, --j) &#123; if (chess[i][j]) return false; &#125; &#x2F;&#x2F;(4)检查右上对角线 for (int i&#x3D;row-1, j&#x3D;col+1; i&gt;&#x3D;0 &amp;&amp; j&lt;&#x3D;N-1; i--, j++) &#123; if (chess[i][j]) return false; &#125; return true;&#125;void dfs(int row) &#123; if (row &#x3D;&#x3D; N) &#123; print(); cnt ++; return; &#125; else &#123; for (int i&#x3D;0; i&lt;N; ++i) &#123; chess[row][i] &#x3D; 1; if (check(row, i)) dfs(row + 1); chess[row][i] &#x3D; 0; &#125; &#125;&#125;int main() &#123; init(); dfs(0); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"前缀表达式(波兰表达式)的计算","slug":"前缀表达式(波兰表达式)的计算","date":"2019-11-09T01:55:27.000Z","updated":"2020-11-29T19:35:19.423Z","comments":true,"path":"2019/11/09/前缀表达式(波兰表达式)的计算/","link":"","permalink":"http://example.com/2019/11/09/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"","text":"波兰表达式也称之为前缀表达式，即运算符放置于操作数之前。计算波兰表达式的值的方法:（1）从后往前遍历表达式。（2）遇到数字直接入栈。（3）遇到运算符，取出两个数字，第一个作为操作数，第二作为被操作数，执行相应的运算。将运算的结果继续入栈。（4）当表达式遍历完时，此时栈顶元素即为计算结果。 123456789101112131415161718192021222324252627282930int cal(string s) &#123; stack&lt;int&gt; st; for (int i&#x3D;s.length()-1; i&gt;&#x3D;0; --i) &#123; if (isdigit(s[i])) &#123; st.push(s[i] - &#39;0&#39;); &#125; else if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123; int a &#x3D; st.top(); st.pop(); int b &#x3D; st.top(); st.pop(); st.push(a+b); &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123; int a &#x3D; st.top(); st.pop(); int b &#x3D; st.top(); st.pop(); st.push(a-b); &#125; else if (s[i] &#x3D;&#x3D; &#39;*&#39;) &#123; int a &#x3D; st.top(); st.pop(); int b &#x3D; st.top(); st.pop(); st.push(a*b); &#125; else if (s[i] &#x3D;&#x3D; &#39;&#x2F;&#39; ) &#123; int a &#x3D; st.top(); st.pop(); int b &#x3D; st.top(); st.pop(); st.push(a&#x2F;b); &#125; &#125; return st.top();&#125;int main() &#123; string s &#x3D; &quot;-+8*3-27&#x2F;42&quot;; cout &lt;&lt; cal(s) &lt;&lt; endl;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单链表：删除带头结点递增有序单链表中开区间(a,b)的所有节点","slug":"单链表：删除带头结点递增有序单链表中开区间(a,b)的所有节点","date":"2019-11-09T01:06:32.000Z","updated":"2020-11-29T19:35:19.415Z","comments":true,"path":"2019/11/09/单链表：删除带头结点递增有序单链表中开区间(a,b)的所有节点/","link":"","permalink":"http://example.com/2019/11/09/%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%88%A0%E9%99%A4%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%BC%80%E5%8C%BA%E9%97%B4(a,b)%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9/","excerpt":"","text":"123456789101112131415161718192021222324252627282930struct node &#123; int val; node *next;&#125;;void deleteBetweenMaxAndMin(node *head, int minv, int maxv) &#123; node *p &#x3D; head; node *q &#x3D; head-&gt;next; node *premin &#x3D; head, *premax &#x3D; head; node *pmin &#x3D; head-&gt;next, *pmax &#x3D; head-&gt;next; bool flag &#x3D; false; bool tag &#x3D; false; while (q) &#123; if (q-&gt;val &gt; minv &amp;&amp; !flag) &#123; pmin &#x3D; q; premin &#x3D; p; flag &#x3D; true; &#125; else if (q-&gt;val &lt; maxv &amp;&amp; !tag) &#123; pmax &#x3D; q; premax &#x3D; p; &#125; p &#x3D; p-&gt;next; q &#x3D; q-&gt;next; &#125; premin-&gt;next &#x3D; pmax-&gt;next;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：关于二叉树节点个数以及高度计算的相关问题以及其衍生问题","slug":"二叉树：关于二叉树节点个数以及高度计算的相关问题以及其衍生问题","date":"2019-11-08T15:44:02.000Z","updated":"2020-11-29T19:35:19.419Z","comments":true,"path":"2019/11/08/二叉树：关于二叉树节点个数以及高度计算的相关问题以及其衍生问题/","link":"","permalink":"http://example.com/2019/11/08/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.N个节点的二叉树的最低高度和最高高度？ 2.N个节点完全二叉树的最低高度或者最高高度？ 3.N个节点的m叉树的最小高度和最大高度？ 4.高度为h的完全二叉树最小有多少个节点，最多有多少个节点？ 5.给定完全二叉的节点个数，求完全二叉树叶子节点的个数？ 6.给定完全二叉树叶子节点的个数，求最多的节点个数？ 7.给定完全二叉树在某层有n个叶子节点，则完全二叉树的最多和最少节点个数？ 8.给定完全二叉树在某层的叶子节点个数，求完全二叉树总的节点个数？","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单链表：删除带头节点单链表中最小值所有在的节点","slug":"单链表：删除带头节点单链表中最小值所有在的节点","date":"2019-11-08T11:58:39.000Z","updated":"2020-11-29T19:35:19.427Z","comments":true,"path":"2019/11/08/单链表：删除带头节点单链表中最小值所有在的节点/","link":"","permalink":"http://example.com/2019/11/08/%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%88%A0%E9%99%A4%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%80%BC%E6%89%80%E6%9C%89%E5%9C%A8%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"思路：用两对前驱和后继节点，分别比较当前节点的前驱和后继以及最小值界定啊的前驱和后继。遍历完整个链表，删除最小值节点即可。 1234567891011121314151617181920212223struct node &#123; int val; node *next;&#125;;void deleteMin(node *head) &#123; node *p &#x3D; head, *q &#x3D; head-&gt;next; node *premin &#x3D; head, *pmin &#x3D; head-&gt;next; while (q) &#123; if (q-&gt;val &lt; pmin-&gt;val) &#123; pmin &#x3D; q; premin &#x3D; p; p &#x3D; p-&gt;next, q &#x3D; q-&gt;next; &#125; else &#123; p &#x3D; p-&gt;next; q &#x3D; q-&gt;next; &#125; node *del &#x3D; pmin; premin-&gt;next &#x3D; pmin-&gt;next; delete del; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：统计二叉树同时拥有左右孩子节点的个数","slug":"二叉树：统计二叉树同时拥有左右孩子节点的个数","date":"2019-11-08T03:00:06.000Z","updated":"2020-11-29T19:35:19.423Z","comments":true,"path":"2019/11/08/二叉树：统计二叉树同时拥有左右孩子节点的个数/","link":"","permalink":"http://example.com/2019/11/08/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8C%E6%97%B6%E6%8B%A5%E6%9C%89%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"二叉树遍历的应用 12345678910struct node &#123; int val; node *left, *right;&#125;;int dfs(node *root) &#123; if (!root) return 0; if (root-&gt;left &amp;&amp; root-&gt;right) return1; return dfs(root-&gt;left) + dfs(root-&gt;right);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：三元组的定义(考研)","slug":"数据结构：三元组的定义(考研)","date":"2019-11-08T02:17:38.000Z","updated":"2020-11-29T19:35:20.711Z","comments":true,"path":"2019/11/08/数据结构：三元组的定义(考研)/","link":"","permalink":"http://example.com/2019/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89(%E8%80%83%E7%A0%94)/","excerpt":"","text":"12345678910111213&#x2F;&#x2F;非零元素的节点类的定义struct triple &#123; int e; int col, row;&#125;;#define maxsize 100struct tripleMatrix &#123; triple data[maxsize + 1]; &#x2F;&#x2F;下标为0的位置不使用 int m;&#x2F;&#x2F;m行 int n;&#x2F;&#x2F;n列 int size;&#x2F;&#x2F;三元组中非零元素的总个数&#125;; 注意：三元组在存储稀疏矩阵时，只有当稀疏矩阵的稀疏因子小于33%时，采用三元组存储才是节省空间的。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：二叉树的最大路径和","slug":"二叉树：二叉树的最大路径和","date":"2019-11-07T12:23:59.000Z","updated":"2020-11-29T19:35:20.667Z","comments":true,"path":"2019/11/07/二叉树：二叉树的最大路径和/","link":"","permalink":"http://example.com/2019/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"二叉树的最大路径和，枚举二叉树的每一个节点，通过当前节点最大路径和是， 当前节点左子树的最大路径和+root-&gt;val+当前节点右子树的最大路径。 12345678910111213141516171819struct node &#123; int val; node *left, *right;&#125;;int ans &#x3D; MIN_MAX;&#x2F;&#x2F;用于维护最大路径和int dfs(node *root) &#123; if (!root) return 0; int left &#x3D; dfs(root-&gt;left); int right &#x3D; dfs(root-&gt;right); ans &#x3D; max(ans, max(root-&gt;val+left+right); return max(0, root-&gt;val + max(0, max(left, right)));&#125;int maxPathSum(node* root) &#123; dfs(root); return ans;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：二叉树的直径","slug":"二叉树：二叉树的直径","date":"2019-11-07T12:08:44.000Z","updated":"2020-11-29T19:35:20.679Z","comments":true,"path":"2019/11/07/二叉树：二叉树的直径/","link":"","permalink":"http://example.com/2019/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"","text":"二叉树直径的定义：二叉树中路径的最大长度二叉树中路径的最大长度，可以理解所有节点的左右子树高度之和的最大值。假设二叉树有n个节点，编号为{a1,a2,…,an}, 其对应的左右子树的高度之和为H = {h1,h2,h3,…,hn}, 则该二叉树的直径为max(H)。 123456789101112131415161718192021struct node &#123; int val; node *left, *right;&#125;;int ans &#x3D; 0;&#x2F;&#x2F; 用于维护任意节点左右子树高度和的最大值&#x2F;&#x2F;dfs()函数的返回值是当前节点的高度int dfs(node *root) &#123; if (!root) return 0; int left &#x3D; dfs(root-&gt;left); int right &#x3D; dfs(root-&gt;right); ans &#x3D; max(ans, left+right); return max(right, left) + 1;&#125;int diameterOfBinaryTree(node *root) &#123; dfs(root); return ans;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"算法：判断字符串是否为回文串的三种方法（递归，循环，使用栈模拟递归）（考研）","slug":"算法：判断字符串是否为回文串的三种方法（递归，循环，使用栈模拟递归）（考研）","date":"2019-11-07T06:01:29.000Z","updated":"2020-11-29T19:35:20.711Z","comments":true,"path":"2019/11/07/算法：判断字符串是否为回文串的三种方法（递归，循环，使用栈模拟递归）（考研）/","link":"","permalink":"http://example.com/2019/11/07/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%8C%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92%EF%BC%89%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"一、递归 12345bool ispalindrome(string s, int i, int j) &#123; if (i &gt;&#x3D; j) return true; if (s[i] &#x3D;&#x3D; s[j]) return ispalindrome(s, i+1, j-1); else return false;&#125; 二、使用栈模拟递归 12345678910bool ispalindrome(string s） &#123; int n &#x3D; s.length(); stack&lt;char&gt; st; for (int i&#x3D;0; i&lt;n; ++i) st.push(s[i]); for (int i&#x3D;0; i&lt;n&#x2F;2; ++i) &#123; char c &#x3D; st.top(); st.pop(); if (s[i] !&#x3D; c) return false; &#125; return true;&#125; 三、迭代 1234567bool ispalindrome(string s) &#123; int n &#x3D; s.length(); for (int i&#x3D;0; i&lt;n&#x2F;2; ++i) &#123; if (s[i] !&#x3D; s[n-1-i]) return false; &#125; return true;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：前序、中序和后序遍历的方便记忆和应试非递归写法（考研）","slug":"二叉树：前序、中序和后序遍历的方便记忆和应试非递归写法（考研）","date":"2019-11-07T00:48:07.000Z","updated":"2020-11-29T19:35:20.731Z","comments":true,"path":"2019/11/07/二叉树：前序、中序和后序遍历的方便记忆和应试非递归写法（考研）/","link":"","permalink":"http://example.com/2019/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E4%BE%BF%E8%AE%B0%E5%BF%86%E5%92%8C%E5%BA%94%E8%AF%95%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"前序遍历： 123456789101112131415161718192021struct node &#123; int val; node *left,*right; &#125;;vector&lt;int&gt; preorder(node *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;node*&gt; st; auto p &#x3D; root; while (p || st.size()) &#123; if (p) &#123; st.push(p); res.push_back(p-&gt;val); p &#x3D; p-&gt;left; &#125; else &#123; auto top &#x3D; st.top(); st.pop(); p &#x3D; top-&gt;right; &#125; &#125; return res;&#125; 中序遍历： 12345678910111213141516vector&lt;int&gt; inorder(node *root) &#123; vector&lt;int&gt; res; if (!root) return res; auto p &#x3D; root; stack&lt;node*&gt; st; while (p || st.size()) &#123; while (p) &#123; st.push(p); p &#x3D; p-&gt;left; &#125; p &#x3D; st.top(); st.pop(); res.push_back(p-&gt;val); p &#x3D; p-&gt;right; &#125; return res;&#125; 后序遍历： 1234567891011121314151617181920212223vector&lt;int&gt; postorder(node *root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;node*&gt; st; auto p &#x3D; root; node *tag; while (p || st.size()) &#123; while (p) &#123; st.push(p); p &#x3D; p-&gt;left; &#125; p &#x3D; st.top(); st.pop(); if (!p-&gt;right || p-&gt;right &#x3D;&#x3D; tag) &#123; res.push_back(p-&gt;val); tag &#x3D; p; p &#x3D; NULL; &#125; else &#123; st.push(p); p &#x3D; p-&gt;right; &#125; &#125; return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"合并两个有序数组，要求时间复杂度为O(n),空间复杂度为O(1)","slug":"合并两个有序数组，要求时间复杂度为O(n),空间复杂度为O(1)","date":"2019-11-03T12:50:23.000Z","updated":"2020-11-29T19:35:20.731Z","comments":true,"path":"2019/11/03/合并两个有序数组，要求时间复杂度为O(n),空间复杂度为O(1)/","link":"","permalink":"http://example.com/2019/11/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(n),%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(1)/","excerpt":"","text":"思路：因为数组已经是有序的，因此我们可以直接从两个数组的末位开始比较，将大的一个直接放到第一个数组的末尾，此时必须要求a数组的空间大小能够同时填充a数组和b数组的有效元素，然后依次比较两个数组元素的大小即可。 代码实现： 12345678910111213141516171819202122#include &lt;bits&#x2F;stdc++.h&gt;void merge(int *a, int n, int *b, int m) &#123; int i &#x3D; n-1;&#x2F;&#x2F;a数组的最后一个有效元素的下标 int j &#x3D; m-1;&#x2F;&#x2F;b数组的最后一个有效元素的下标 int index &#x3D; n+m-1; &#x2F;&#x2F;合并数组的最后一位的下标 while (index) &#123; if (i &amp;&amp; a[i]&gt;a[j]) a[index --] &#x3D; a[i --]; else a[index --] &#x3D; b[j --]; &#125;&#125;int main() &#123; int a[] &#x3D; &#123;1,3,5,7,9,0,0,0,0,0&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); int b[] &#x3D; &#123;2,4,6,8,10&#125;; int m &#x3D; sizeof(b)&#x2F;sizeof(int); merge(a, 5, b, m); for_each(a, a+n, [](int x) &#123;cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：将二叉树中的所有节点的左右子树进行交换","slug":"二叉树：将二叉树中的所有节点的左右子树进行交换","date":"2019-11-03T11:37:05.000Z","updated":"2020-11-29T19:35:20.711Z","comments":true,"path":"2019/11/03/二叉树：将二叉树中的所有节点的左右子树进行交换/","link":"","permalink":"http://example.com/2019/11/03/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"二叉树遍历的简单应用 1234567891011121314151617struct node &#123; int val; node *left, *right;&#125;;node *swapSubTree(node *root) &#123; if (!root) return NULL; else &#123; &#x2F;&#x2F;交换的过程 node *tmp &#x3D; root-&gt;left; root-&gt;left &#x3D; root-&gt;right; root-&gt;right &#x3D; tmp; swapSubTree(root-&gt;left); swapSubTree(root-&gt;right); &#125; return root;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单链表：在带头节点单链表中删除(minv, maxv)中的所有节点","slug":"单链表：在带头节点单链表中删除(minv, maxv)中的所有节点","date":"2019-11-03T11:20:44.000Z","updated":"2020-11-29T19:35:20.731Z","comments":true,"path":"2019/11/03/单链表：在带头节点单链表中删除(minv, maxv)中的所有节点/","link":"","permalink":"http://example.com/2019/11/03/%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%9C%A8%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4(minv,%20maxv)%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9/","excerpt":"","text":"链表节点删除，只有标记待删除节点的前驱节点即可;[注]：如果不是带有节点设置一个虚拟节点即可，返回时返回dummy-&gt;next。 1234567891011121314151617181920212223struct node &#123; int val; node *next;&#125;;void delInterval(node *head, int minx, int maxx) &#123; if (!head) return head; node *pre &#x3D; head; node *p &#x3D; pre-&gt;next; &#x2F;&#x2F;工作指针 while (p) &#123; if (minx &lt; p-&gt;val &amp;&amp; p-&gt;val &lt; maxx) &#123; &#x2F;&#x2F;满足条件，p为待删除节点 node *del &#x3D; p; pre-&gt;next &#x3D; p-&gt;next; p &#x3D; p-&gt;next; delete del; &#125; else &#123; pre &#x3D; pre-&gt;next; p &#x3D; p-&gt;next; &#125; &#125; return head;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：计算叶子节点个数","slug":"二叉树：计算叶子节点个数","date":"2019-11-03T11:04:05.000Z","updated":"2020-11-29T19:35:20.731Z","comments":true,"path":"2019/11/03/二叉树：计算叶子节点个数/","link":"","permalink":"http://example.com/2019/11/03/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","excerpt":"","text":"叶子节点的特征：左右孩子均为NULL 123456789101112struct node &#123; int val; node *left, *right;&#125;;int countLeaf(node *root) &#123; if (!root) return 0; else &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) return 1; return countLeaf(root-&gt;left) + countLeaf(root-&gt;right); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二叉树：前序与后序、前序与中序以及中序与后序相同、相反的特征","slug":"二叉树：前序与后序、前序与中序以及中序与后序相同、相反的特征","date":"2019-11-01T23:35:47.000Z","updated":"2020-11-29T19:35:20.731Z","comments":true,"path":"2019/11/02/二叉树：前序与后序、前序与中序以及中序与后序相同、相反的特征/","link":"","permalink":"http://example.com/2019/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%89%8D%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E3%80%81%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E7%9B%B8%E5%90%8C%E3%80%81%E7%9B%B8%E5%8F%8D%E7%9A%84%E7%89%B9%E5%BE%81/","excerpt":"","text":"一、前序序列与后序序列1.前序序列和后序序列相同空树或者只有根节点的二叉树。 2.前序序列和后序序列相反(1)当且仅当二叉树中只有一个叶子节点。(2)二叉树的高度和其节点个数相同。 二、前序序列与中序序列1.前序序列和中序序列相同空树或缺左子树的单支二叉树。 2.前序序列和中序序列相反(1)二叉树为空或者只有一个节点。(2)若二叉树不为空，则任意节点不能同时用于左孩子和右孩子。(3)若二叉树不为空，则任意节点没有右孩子。 三、中序序列与后序序列1.中序序列和后序序列相同空树或者缺右子树的单支二叉树。 2.中序序列和后序序列相反任意节点没有左孩子节点。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"判断两棵二叉树是否相同","slug":"判断两棵二叉树是否相同","date":"2019-11-01T02:04:52.000Z","updated":"2020-11-29T19:35:20.963Z","comments":true,"path":"2019/11/01/判断两棵二叉树是否相同/","link":"","permalink":"http://example.com/2019/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/","excerpt":"","text":"12345678910111213struct node &#123; int val; node *left, *right;&#125;;bool isSame(node *a, node *b) &#123; if (!a &amp;&amp; !b) return true; if ((!a &amp;&amp; b) || (!b &amp;&amp; a)) return false; if (a-&gt;val &#x3D;&#x3D; b-&gt;val) return isSame(a-&gt;left, b-&gt;left) &amp;&amp; isSame(a-&gt;right, b-&gt;right); else return false;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"在单链表中删除值相同的多余节点的算法","slug":"在单链表中删除值相同的多余节点的算法","date":"2019-10-31T05:48:43.000Z","updated":"2020-11-29T19:35:20.963Z","comments":true,"path":"2019/10/31/在单链表中删除值相同的多余节点的算法/","link":"","permalink":"http://example.com/2019/10/31/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E5%A4%9A%E4%BD%99%E8%8A%82%E7%82%B9%E7%9A%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"思路：分别使用两个指针p和q, 因为可能q-&gt;val==p-&gt;val时，此时要删除q所指向的节点，所以需要一个s指针记录q,防止发生断链。 123456789101112131415161718192021struct node &#123; int val; node *next;&#125;;void delDuplication(node *head) &#123; for (node *p&#x3D;head-&gt;next; p; p-&gt;next) &#123; for (node *q&#x3D;p-&gt;next, *s&#x3D;q; q) &#123; if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123; &#x2F;&#x2F;删除q s-&gt;next &#x3D; q-&gt;next; delete q; q &#x3D; s-&gt;next; &#125; else &#123; s &#x3D; q; q &#x3D; q-&gt;next; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"判断二叉树是否为满二叉树","slug":"判断二叉树是否为满二叉树","date":"2019-10-30T12:42:41.000Z","updated":"2020-11-29T19:35:20.951Z","comments":true,"path":"2019/10/30/判断二叉树是否为满二叉树/","link":"","permalink":"http://example.com/2019/10/30/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"满二叉树的定义：一个高度为h，并且含有2^h - 1个节点的二叉树称为满二叉树，下文称呼满二叉树为FBT。 根据满二叉树的高度与节点个数之间的关系，很容易判断一棵树是否为FBT，只需要求树其树高和节点个数即可。 代码实现： 12345678910111213141516171819202122232425262728struct node &#123; int val; node *left, *right;&#125;;int height(node *root) &#123; if (!root) return 0; int left &#x3D; height(root-&gt;left); int right &#x3D; height(root-&gt;right); return max(left, right) + 1; &#125;void count(node *root, int &amp;sum) &#123; if (root) &#123; sum +&#x3D; 1; count(root-&gt;left); count(root-&gt;right); &#125;&#125;bool isFBT(node *root) &#123; if (!root) return 1; int sum &#x3D; 0; int h &#x3D; height(root); count(root, sum); return sum &#x3D;&#x3D; pow(2, h) - 1;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"判断二叉树是否为完全二叉树","slug":"判断二叉树是否为完全二叉树","date":"2019-10-30T12:34:29.000Z","updated":"2020-11-29T19:35:20.995Z","comments":true,"path":"2019/10/30/判断二叉树是否为完全二叉树/","link":"","permalink":"http://example.com/2019/10/30/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"完全二叉树的定义（王道）：设一棵高度为h,有n个节点的二叉树，当且仅当其中每一个节点都与高度为h的满二叉树编号为1~n的节点一一对应时，称为完全二叉树。下文称呼完全二叉树为CBT。 由定义可知，CBT可以不是满树，但其叶子节点只能出现在最后两层。利用这个性质来判断完全二叉树，使用层序遍历，我们依次将节点入队，而不考虑当前节点的左右孩子节点是否为空而直接入队，这样当我们在出队时发现有空节点，此时判断队列中是否还有非空节点，如果有，则说明此树是CBT。 代码实现： 123456789101112131415161718192021222324252627#include &lt;queue&gt;using namespace std;struct node &#123; int val; node *next;&#125;;bool isCBT(node *root) &#123; if (!root) return true; queue&lt;node*&gt; q; q,push(root); while (!q.empty()) &#123; node *top &#x3D; q.top();q.pop(); if (top) &#123; q.push(top-&gt;left); q.push(top-&gt;right); &#125; else &#123; &#x2F;&#x2F;说明取出的top节点是空节点，此时看队列中是否还有非空节点 while (!q.empty()) &#123; top &#x3D; q.top();q.pop(); if (top) return false; &#125; &#125; &#125; return true;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"判断二叉树是否为排序二叉树","slug":"判断二叉树是否为排序二叉树","date":"2019-10-30T12:17:25.000Z","updated":"2020-11-29T19:35:20.959Z","comments":true,"path":"2019/10/30/判断二叉树是否为排序二叉树/","link":"","permalink":"http://example.com/2019/10/30/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"排序二叉树的递归定义：（1）空树。（2）是由根节点、左子树和右子树组成。满足左子树上的所有节点的值都小于根节点的值，右子树上的所有节点的值都大于根节点的值。同时左子树和右子树都是排序二叉树（递归定义）。 老套路，还是根据定义来判断。首先如果一个树是空树，其必是一棵BST。如果不为空树，看是否满足条件二，如果满足则递归的看其两棵子树是否满足BST的定义。 代码实现： 1234567891011121314151617class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if (!root) return true; TreeNode *left &#x3D; root-&gt;left; TreeNode *right &#x3D; root-&gt;right; while (left) &#123; if (root-&gt;val &lt;&#x3D; left-&gt;val) return false; left &#x3D; left-&gt;right; &#125; while (right) &#123; if (root-&gt;val &gt;&#x3D; right-&gt;val) return false; right &#x3D; right-&gt;left; &#125; return isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right); &#125;&#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"判断二叉树是否为平衡二叉树","slug":"判断二叉树是否为平衡二叉树","date":"2019-10-30T11:45:33.000Z","updated":"2020-11-29T19:35:20.975Z","comments":true,"path":"2019/10/30/判断二叉树是否为平衡二叉树/","link":"","permalink":"http://example.com/2019/10/30/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"平衡二叉树的递归定义:(1)空树。(2)他的左子树和右子树都是平衡二叉树，并且左子树和右子树的高度差的绝对值不会超过1(&lt;=1)。 根据平衡二叉树的定义，可以很容易的判断一棵二叉树是否为平衡二叉树，首先是空树，满足条件。如果不是空树，需要检验它的两棵子树高度差的绝对值，这里需要一个辅助程序，求解一棵二叉树的高度。如果不满足条件(2)即不是平衡二叉树，如果满足，递归的判断其左右子树是否同时满足为平衡二叉树的条件。 代码实现: 123456789101112131415161718struct node &#123; int val; node *left, *right;&#125;;int height(node *root) &#123; if (!root) return 0; int left &#x3D; height(root-&gt;left); int right &#x3D; height(root-&gt;right); return max(left, right) +1;&#125;bool isAVL(node *root) &#123; if (!root) return 1; if (abs(height(root-&gt;left)-height(root-&gt;right)) &gt;1) return 0; return isAVL(root-&gt;left) &amp;&amp; isAVL(root-&gt;right);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"判断带头结点单链表是否递增有序","slug":"判断带头结点单链表是否递增有序","date":"2019-10-30T11:23:52.000Z","updated":"2020-11-29T19:35:20.975Z","comments":true,"path":"2019/10/30/判断带头结点单链表是否递增有序/","link":"","permalink":"http://example.com/2019/10/30/%E5%88%A4%E6%96%AD%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F/","excerpt":"","text":"1234567891011121314151617#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F;节点类struct node &#123; int val; node *next;&#125;;bool isSorted(node *head) &#123; &#x2F;&#x2F;如果单链表为空 或者只有一个节点 如需要进行判断，直接返回为true if (!head || !head-&gt;next) return 1; node *p &#x3D; head-&gt;next; &#x2F;&#x2F;p指向单链表中的第一个节点 for (node *t&#x3D;p; t-&gt;next; t&#x3D;t-&gt;next) if (t-&gt;val &gt; t-&gt;next-&gt;val) return false; return true;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单链表插入排序","slug":"单链表插入排序","date":"2019-10-30T09:18:20.000Z","updated":"2020-11-29T19:35:20.967Z","comments":true,"path":"2019/10/30/单链表插入排序/","link":"","permalink":"http://example.com/2019/10/30/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"单链表的插入排序在思路上与顺序表是一致的，它的难点在于如何对链表进行操作，包括链表的插入以及防止访问空节点。只有能够保证思路清晰，写出也是不难的。 12345678910111213141516171819202122232425#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;node *insertSort(node *head) &#123; &#x2F;&#x2F;表空或者只有一个节点 不需要进行排序 直接返回 if (!head || !head-&gt;next) return head; node *dummy &#x3D; new noed(0);&#x2F;&#x2F;创建虚拟节点 dummy-&gt;next &#x3D; head; &#x2F;&#x2F;将链表分为有序区域和无序区 有序区初始只有一个节点 node *p &#x3D; dummy-&gt;next-&gt;next;&#x2F;&#x2F; p初始指向无序表的第一个节点 dymmy-&gt;next-&gt;next &#x3D; NULL;&#x2F;&#x2F;断链 while (p) &#123; node *q &#x3D; p-&gt;next; &#x2F;&#x2F;保存p-&gt;next, 因为插入过程可能改变p-&gt;next node *pre &#x3D; dummy; &#x2F;&#x2F;当有序表不到最后一个节点并且有序表的元素小于等于无序表的元素 pre &#x3D; pre-&gt;next while (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt;&#x3D; p-&gt;val) pre &#x3D; pre-&gt;next; &#x2F;&#x2F;插入无序表中此时p指向的节点到有序表中 p-&gt;next &#x3D; pre-&gt;next; pre-&gt;next &#x3D; p p &#x3D; q; &#125; return dummy-&gt;next;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"单链表归并排序","slug":"单链表归并排序","date":"2019-10-30T09:03:54.000Z","updated":"2020-11-29T19:35:20.975Z","comments":true,"path":"2019/10/30/单链表归并排序/","link":"","permalink":"http://example.com/2019/10/30/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"单链表归并排序需要掌握的知识点。1.归并排序的思想2.如何合并两个有序的单链表3.如何找到一个链表的中间节点，这里是为了断链。将链表一分为二。 （1）合并两个有序的链表，主要有两种思路。递归和迭代递归方法的代码： 12345678910111213141516struct node &#123; int val; node *next;&#125;;&#x2F;&#x2F;注意此时链表a和链表b均为递增有序的单链表node *merge(node *a, node *b) &#123; if (!a) return b; if (!b) return a; if (a-&gt;val &lt;&#x3D; b-&gt;val) &#123; a-&gt;next &#x3D; merge(a-&gt;next, b); return a; &#125; else &#123; b-&gt;next &#x3D; merge(b-&gt;next, a); return b; &#125;&#125; 迭代方法的代码： 123456789101112131415161718node *merge(node *a, node *b) &#123; node *dummy &#x3D; new node(0);&#x2F;&#x2F;建立虚拟节点 node *p &#x3D; dummy; while (a &amp;&amp; b) &#123; if (a-&gt;val &lt;&#x3D; b-&gt;val) &#123; p-&gt;next &#x3D; a; a &#x3D; a-&gt;next; &#125; else &#123; p-&gt;next &#x3D; b; b &#x3D; b-&gt;next; &#125; p &#x3D; p-&gt;next; &#125; &#x2F;&#x2F;退出while循环 可能是a&#x3D;&#x3D;NULL 或者 b&#x3D;&#x3D;NULL 或者 a&#x3D;&#x3D;NULL &amp;&amp; b&#x3D;&#x3D;NULL &#x2F;&#x2F;但是我们需要把不空的那条链继续连上 p-&gt;next &#x3D; (a!&#x3D;NULL)?a:b; return dummy-&gt;next;&#125; （2) 链表的归并排序，其实也是递归的处理两个子链，最后合并两个有序的链表。这里主要的难点是如何找到链表的中点进行断链。 123456789101112131415161718192021222324node *_mergeSort(node *head) &#123; if (!head-&gt;next) return head; &#x2F;&#x2F;如果链表中只有一个节点， 即为递归出口，直接返回 &#x2F;* 使用快慢指针，（1）慢指针规规矩矩每次只走一步 （2）快指针每次走两步 *&#x2F; node *slow &#x3D; head;&#x2F;&#x2F;最终指向第二条链的第一个节点 node *fast &#x3D; head; node *pre &#x3D; NULL;&#x2F;&#x2F;最终指向第一条链的最后一个节点 while (fast &amp;&amp; fast-&gt;next) &#123; pre &#x3D; p; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; pre-&gt;next &#x3D; NULL;&#x2F;&#x2F;这一步很关键 就是在断链 node *left &#x3D; mergeSort(head);&#x2F;&#x2F;递归的排序以head为头指针的第一条链 node *right &#x3D; mergeSort(slow); return merge(left, right);&#125;node *mergeSort(node *head) &#123; if (!head) return NULL; else return _mergeSort(head); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"使用C++优先级队列求解Huffman树带权路径长度","slug":"使用C++优先级队列求解Huffman树带权路径长度","date":"2019-10-30T07:58:28.000Z","updated":"2020-11-29T19:35:20.967Z","comments":true,"path":"2019/10/30/使用C++优先级队列求解Huffman树带权路径长度/","link":"","permalink":"http://example.com/2019/10/30/%E4%BD%BF%E7%94%A8C++%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E6%B1%82%E8%A7%A3Huffman%E6%A0%91%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/","excerpt":"","text":"123456789101112131415161718#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; int a[] &#x3D; &#123;2,3,5,7,9&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); for (int i&#x3D;0; i&lt;n; ++i) pq.push(a[i]); int res &#x3D; 0; while (pq.size() &gt; 1) &#123; int a &#x3D; pq.top();pq.pop(); int b &#x3D; pq.top();pq.pop(); res +&#x3D; (a+b); &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：带头节点双向循环链表的实现（考研）","slug":"数据结构：带头节点双向循环链表的实现（考研）","date":"2019-10-29T02:30:48.000Z","updated":"2020-11-29T19:35:21.211Z","comments":true,"path":"2019/10/29/数据结构：带头节点双向循环链表的实现（考研）/","link":"","permalink":"http://example.com/2019/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class DoubleLinkedCircleList&#123;private: struct node &#123; int val; node *next, *prev; node (int x) &#123;this-&gt;val &#x3D; x;&#125; node () &#123;&#125; &#125;; node *head; int size;public: DoubleLinkedCircleList() &#123; head &#x3D; new node(); head-&gt;next &#x3D; head-&gt;prev &#x3D; head; size &#x3D; 0; &#125; ~DoubleLinkedCircleList() &#123; while (head-&gt;next!&#x3D;head &amp;&amp; head-&gt;prev!&#x3D;head) delTail(); delete head; &#125; void insert(int index, int x) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return; &#125; &#x2F;&#x2F; p是待删除节点的前去节点 node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *q &#x3D; new node(x); q-&gt;next &#x3D; p-&gt;next; if (p-&gt;next) p-&gt;next-&gt;prev &#x3D; q; q-&gt;prev &#x3D; p; p-&gt;next &#x3D; q; size ++; &#125; void insertHead(int x) &#123;insert(0, x);&#125; void insertTail(int x) &#123;insert(size, x);&#125; int del(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (isEmpty()) &#123; cout &lt;&lt; &quot;the DoubleLinkedCircleList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *q &#x3D; p-&gt;next; int res &#x3D; q-&gt;val; q-&gt;next-&gt;prev &#x3D; p; p-&gt;next &#x3D; q-&gt;next; delete q; q &#x3D; NULL; size --; &#125; int delHead() &#123;return del(0);&#125; int delTail() &#123;return del(size-1);&#125; int search(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (head-&gt;next &#x3D;&#x3D; head &amp;&amp; head-&gt;prev &#x3D;&#x3D; head) &#123; cout &lt;&lt; &quot;the DoubleLinkedCircleList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head-&gt;next; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; return p-&gt;val; &#125; int searchHead() &#123;return search(0);&#125; int searchTail() &#123;return search(size-1);&#125; void show() &#123; node *p &#x3D; head-&gt;next; while (p &amp;&amp; p!&#x3D;head) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl; &#125; bool isEmpty() &#123;return head-&gt;next&#x3D;&#x3D;head &amp;&amp; head-&gt;prev&#x3D;&#x3D;head;&#125; int getSize() &#123;return size;&#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); DoubleLinkedCircleList list &#x3D; DoubleLinkedCircleList(); for (int i&#x3D;0; i&lt;n; ++i) list.insertTail(a[i]); list.show(); list.delHead(); list.show(); cout &lt;&lt; &quot;size:&quot; &lt;&lt; list.getSize() &lt;&lt; endl; list.delTail(); list.show(); list.del(2); list.show(); cout &lt;&lt; list.searchHead() &lt;&lt; endl; cout &lt;&lt; list.searchTail() &lt;&lt; endl; cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl; cout &lt;&lt; list.search(2) &lt;&lt; endl; cout &lt;&lt; list.search(0) &lt;&lt; endl; cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl; cout &lt;&lt; list.search(1) &lt;&lt; endl; list.show(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：带头结点双向链表的实现（考研）","slug":"数据结构：带头结点双向链表的实现（考研）","date":"2019-10-29T02:29:44.000Z","updated":"2020-11-29T19:35:21.211Z","comments":true,"path":"2019/10/29/数据结构：带头结点双向链表的实现（考研）/","link":"","permalink":"http://example.com/2019/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class DoubleLinkedList &#123;private: struct node &#123; int val; node *next, *prior; node() &#123;&#125; node(int x) &#123; this-&gt;val &#x3D; x; &#125; &#125;; node *head; int size; public: DoubleLinkedList() &#123; head &#x3D; new node(); head-&gt;next &#x3D; head-&gt;prior &#x3D; NULL; size &#x3D; 0; &#125; ~DoubleLinkedList() &#123; while (head-&gt;next!&#x3D;NULL &amp;&amp; head-&gt;prior!&#x3D;NULL) &#123; delTail(); &#125; delete head; &#125; void insert(int index, int x) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; &#x2F;* node *q &#x3D; new node(q) q-&gt;next &#x3D; p-&gt;next; p-&gt;next可能是NULL指针 *&#x2F; node *q &#x3D; new node(x); q-&gt;next &#x3D; p-&gt;next; if (p-&gt;next) p-&gt;next-&gt;prior &#x3D; q; q-&gt;prior &#x3D; p; p-&gt;next &#x3D; q; size ++; &#125; void insertHead(int x) &#123;insert(0, x);&#125; void insertTail(int x) &#123;insert(size, x);&#125; int del(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (head-&gt;next&#x3D;&#x3D;NULL &amp;&amp; head-&gt;prior&#x3D;&#x3D;NULL) &#123; cout &lt;&lt; &quot;the DoubleLinkedList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *del &#x3D; p-&gt;next; int res &#x3D; del-&gt;val; if (del-&gt;next) &#123; del-&gt;next-&gt;prior &#x3D; p; p-&gt;next &#x3D; del-&gt;next; delete del; &#125; else &#123; p-&gt;next &#x3D; NULL; delete del; &#125; size --; return res; &#125; int delHead() &#123;del(0);&#125; int delTail() &#123;del(size-1);&#125; int get(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (head-&gt;next&#x3D;&#x3D;NULL &amp;&amp; head-&gt;prior&#x3D;&#x3D;NULL) &#123; cout &lt;&lt; &quot;the DoubleLinkedList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head-&gt;next; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; return p-&gt;val; &#125; int getHead() &#123;return get(0);&#125; int getTail() &#123;return get(size-1);&#125; void show() &#123; node *p &#x3D; head-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl; &#125; bool isEmpty() &#123; return head-&gt;next&#x3D;&#x3D;NULL &amp;&amp; head-&gt;prior&#x3D;&#x3D;NULL; &#125;&#125;; int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); DoubleLinkedList l &#x3D; DoubleLinkedList(); for (int i&#x3D;0; i&lt;n; ++i) l.insertTail(a[i]); l.show(); l.delHead(); l.show(); l.delTail(); l.show(); cout &lt;&lt; l.getHead() &lt;&lt; endl; cout &lt;&lt; l.getTail() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：基于带头结点单链表实现链队列以及链栈（考研）","slug":"数据结构：基于带头结点单链表实现链队列以及链栈（考研）","date":"2019-10-29T02:28:19.000Z","updated":"2020-11-29T19:35:21.235Z","comments":true,"path":"2019/10/29/数据结构：基于带头结点单链表实现链队列以及链栈（考研）/","link":"","permalink":"http://example.com/2019/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%93%BE%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E9%93%BE%E6%A0%88%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"一.带头结点单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class LinkedList &#123;private: struct node &#123; int val; node *next; node(int x, node *next) &#123; this-&gt;val &#x3D; x; this-&gt;next &#x3D; next; &#125; &#125;; node *head; int size; public: LinkedList() &#123; head &#x3D; new node(0, NULL); size &#x3D; 0; &#125; int getSize() &#123;return size;&#125; bool isEmpty() &#123;return size &#x3D;&#x3D; 0;&#125; &#x2F;&#x2F;[0,size] void insert(int index, int x) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *q &#x3D; new node(x, p-&gt;next); p-&gt;next &#x3D; q; size ++; &#125; void insertTail(int x) &#123; insert(size, x); &#125; void insertHead(int x) &#123; insert(0, x); &#125; &#x2F;&#x2F;[0,size-1] int del(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid&quot; &lt;&lt; endl; return -1; &#125; if (isEmpty()) &#123; cout &lt;&lt; &quot;the LinkedList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *del &#x3D; p-&gt;next; p-&gt;next &#x3D; del-&gt;next; int res &#x3D; del-&gt;val; delete del; size --; return res; &#125; int delFirst() &#123;return del(0);&#125; int delLast() &#123;return del(size-1);&#125; int get(int index) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (isEmpty()) &#123; cout &lt;&lt; &quot;the LinkedList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head-&gt;next; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; return p-&gt;val; &#125; int getLast() &#123;return get(size-1);&#125; int getFirst() &#123;return get(0);&#125; void show() &#123; node *p &#x3D; head-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#125;; 二.链栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;LinkedList.h&quot;class LinkedListStack &#123;private: LinkedList list; public: stack() &#123; list &#x3D; LinkedList(); &#125; bool isEmpty() &#123; return list.isEmpty(); &#125; void push(int x) &#123; list.insertHead(x); &#125; int pop() &#123; return list.delFirst(); &#125; int top() &#123; return list.getFirst(); &#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); LinkedListStack s; for (int i&#x3D;0; i&lt;n; ++i) s.push(a[i]); while (!s.isEmpty()) &#123; cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;; s.pop(); &#125; return 0;&#125; 三.链队列 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;LinkedList.h&quot;class LinkedListQueue &#123;private: LinkedList list; public: LinkedListQueue() &#123; list &#x3D; LinkedList(); &#125; bool isEmpty() &#123;return list.isEmpty();&#125; void push(int x) &#123; list.insertTail(x); &#125; int front() &#123; return list.getFirst(); &#125; int pop() &#123; return list.delFirst(); &#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); LinkedListQueue q; for (int i&#x3D;0; i&lt;n; ++i) q.push(a[i]); while (!q.isEmpty()) &#123; cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; q.pop(); &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：带头节点单循环链表类的实现（C++）（考研）","slug":"数据结构：带头节点单循环链表类的实现（C++）（考研）","date":"2019-10-29T02:24:32.000Z","updated":"2020-11-29T19:35:21.295Z","comments":true,"path":"2019/10/29/数据结构：带头节点单循环链表类的实现（C++）（考研）/","link":"","permalink":"http://example.com/2019/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88C++%EF%BC%89%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class LinkedCircleList &#123;private: struct node &#123; int val; node *next; node() &#123;&#125; node(int x, node *next) &#123; this-&gt;val &#x3D; x; this-&gt;next &#x3D; next; &#125; &#125;; int size; node *head; public: LinkedCircleList() &#123; this-&gt;size &#x3D; 0; head &#x3D; new node; head-&gt;next &#x3D; head; &#125; ~LinkedCircleList() &#123; while (head!&#x3D;head-&gt;next) &#123; delTail(); &#125; delete head; &#125; void insert(int index, int x) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *q &#x3D; new node(x, p-&gt;next); p-&gt;next &#x3D; q; size ++; &#125; void insertHead(int x) &#123;insert(0, x);&#125; void insertTail(int x) &#123;insert(size, x);&#125; int del(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (head-&gt;next &#x3D;&#x3D; head) &#123; cout &lt;&lt; &quot;the LinkedCircleList is null！&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *del &#x3D; p-&gt;next; p-&gt;next &#x3D; del-&gt;next; int res &#x3D; del-&gt;val; delete del; size --; return res; &#125; int delTail() &#123;del(size-1);&#125; int delHead() &#123;del(0);&#125; int get(int index) &#123; if (index &lt; 0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (head-&gt;next &#x3D;&#x3D; head) &#123; cout &lt;&lt; &quot;the LinkedCircleList is null！&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head-&gt;next; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; return p-&gt;val; &#125; int getHead() &#123;get(0);&#125; int getTail() &#123;get(size-1);&#125; void show() &#123; node *p &#x3D; head-&gt;next; while (p!&#x3D;head) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl; &#125; bool isEmpty() &#123;return head-&gt;next &#x3D;&#x3D; head;&#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); LinkedCircleList list &#x3D; LinkedCircleList(); for (int i&#x3D;0; i&lt;n; ++i) list.insertTail(a[i]); list.show(); cout &lt;&lt; list.getHead() &lt;&lt; endl; cout &lt;&lt; list.getTail() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：带头结点单链表实现--一种非常好的写法（考研）","slug":"数据结构：带头结点单链表实现--一种非常好的写法（考研）","date":"2019-10-28T15:27:52.000Z","updated":"2020-11-29T19:35:21.227Z","comments":true,"path":"2019/10/28/数据结构：带头结点单链表实现--一种非常好的写法（考研）/","link":"","permalink":"http://example.com/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0--%E4%B8%80%E7%A7%8D%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;struct node &#123; int val; node *next; node(int x, node *next) &#123; this-&gt;val &#x3D; x; this-&gt;next &#x3D; next; &#125;&#125;; node *head;int size &#x3D; 0;int getSize() &#123;return size;&#125;bool isEmpty() &#123;return size &#x3D;&#x3D; 0;&#125;&#x2F;&#x2F;[0,size] void insert(int index, int x) &#123; if (index&lt;0 || index&gt;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *q &#x3D; new node(x, p-&gt;next); p-&gt;next &#x3D; q; size ++; &#125;void insertTail(int x) &#123; insert(size, x);&#125;void insertHead(int x) &#123; insert(0, x);&#125;&#x2F;&#x2F;[0,size-1]void del(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid&quot; &lt;&lt; endl; return; &#125; if (isEmpty()) &#123; cout &lt;&lt; &quot;the LinkedList is null!&quot; &lt;&lt; endl; return; &#125; node *p &#x3D; head; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; node *del &#x3D; p-&gt;next; p-&gt;next &#x3D; del-&gt;next; delete del; size --;&#125;void delFirst() &#123;del(0);&#125;void delLast() &#123;del(size-1);&#125;&#x2F;&#x2F;[0,size-1]int get(int index) &#123; if (index&lt;0 || index&gt;&#x3D;size) &#123; cout &lt;&lt; &quot;the index is invalid!&quot; &lt;&lt; endl; return -1; &#125; if (isEmpty()) &#123; cout &lt;&lt; &quot;the LinkedList is null!&quot; &lt;&lt; endl; return -1; &#125; node *p &#x3D; head-&gt;next; for (int i&#x3D;0; i&lt;index; ++i) p &#x3D; p-&gt;next; return p-&gt;val;&#125;int getLast() &#123;return get(size-1);&#125;int getFirst() &#123;return get(0);&#125;void show() &#123; node *p &#x3D; head-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl;&#125;int main() &#123; head &#x3D; new node(0, NULL); int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof(a)&#x2F;sizeof(int); for (int i&#x3D;0; i&lt;n; ++i) insertTail(a[i]); show(); delFirst(); show(); delLast(); show(); cout &lt;&lt; get(2) &lt;&lt; endl; cout &lt;&lt; getFirst() &lt;&lt; endl; cout &lt;&lt; getLast() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"占位1024","slug":"占位1024","date":"2019-10-24T13:25:05.000Z","updated":"2020-11-29T19:35:21.235Z","comments":true,"path":"2019/10/24/占位1024/","link":"","permalink":"http://example.com/2019/10/24/%E5%8D%A0%E4%BD%8D1024/","excerpt":"","text":"写什么，还没想好","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"XJT软件考研真题：判断xx年xx月xx日是当年的第几天","slug":"XJT软件考研真题：判断xx年xx月xx日是当年的第几天","date":"2019-09-30T08:54:16.000Z","updated":"2020-11-29T19:35:21.227Z","comments":true,"path":"2019/09/30/XJT软件考研真题：判断xx年xx月xx日是当年的第几天/","link":"","permalink":"http://example.com/2019/09/30/XJT%E8%BD%AF%E4%BB%B6%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98%EF%BC%9A%E5%88%A4%E6%96%ADxx%E5%B9%B4xx%E6%9C%88xx%E6%97%A5%E6%98%AF%E5%BD%93%E5%B9%B4%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/","excerpt":"","text":"123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int month[2][13] &#x3D; &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int x) &#123;return (x%400&#x3D;&#x3D;0) || (x%4&#x3D;&#x3D;0 &amp;&amp; x%100!&#x3D;0);&#125;int main() &#123; cin.tie(0); ios::sync_with_stdio(false); int yy, mm, dd; cin &gt;&gt; yy &gt;&gt; mm &gt;&gt; dd; int cnt &#x3D; 0; for (int i&#x3D;0; i&lt;mm; ++i) &#123; cnt +&#x3D; month[isLeapYear(yy)][i]; &#125; cnt +&#x3D; dd; cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125;","categories":[{"name":"趣味编程","slug":"趣味编程","permalink":"http://example.com/categories/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"邻接表和逆邻接表","slug":"邻接表和逆邻接表","date":"2019-09-16T07:03:39.000Z","updated":"2020-11-29T19:35:21.255Z","comments":true,"path":"2019/09/16/邻接表和逆邻接表/","link":"","permalink":"http://example.com/2019/09/16/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"邻接表作为图的一种存储方式，在存储稀疏图上相对于邻接矩阵有相当大的空间节省。如一个稀疏图的顶点个个数为n，边数为e。用邻接矩阵存储需要n^2空间，而真正进行存储的只有2e个空间， 剩下的n^2-2e都浪费了。但是对于邻接表来讲，存储空间只需要n+2e个，相对于邻接矩阵减少了很多。邻接表虽然在空间上有很大的优势，但是对于一个有向图，如果需要查找每个顶点的入度就需要遍历整个邻接表，在效率上很低下的。因此才有了逆邻接表的诞生。 邻接表：反映的是顶点出度的情况。逆邻接表：反映的是顶点的入度情况。 下面举一个例子：邻接表：逆邻接表：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"汉诺塔问题的求解","slug":"汉诺塔问题的求解","date":"2019-09-10T03:29:38.000Z","updated":"2020-11-29T19:35:21.211Z","comments":true,"path":"2019/09/10/汉诺塔问题的求解/","link":"","permalink":"http://example.com/2019/09/10/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3/","excerpt":"","text":"代码实现： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void move(char a, char c) &#123;cout &lt;&lt; a &lt;&lt; &quot;-&gt;&quot; &lt;&lt; c &lt;&lt; endl;&#125;void hanoi(int n, char a, char b, char c) &#123; &#x2F;&#x2F;如果只有一个盘子 直接从a移动到c if (n &#x3D;&#x3D; 1) move(a, c); else &#123; &#x2F;&#x2F;将n个盘子看成两个部分 1 和 n-1 首先需要借助c柱将n-1和盘子从a移动到b hanoi(n-1, a, c, b); &#x2F;&#x2F;将剩下的一个盘子直接从a移动到c move(a, c); &#x2F;&#x2F;将在b柱上的n-1个盘子借助a柱从b移动到c hanoi(n-1, b, a, c); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; hanoi(n, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;); return 0;&#125; 时间复杂度：","categories":[{"name":"趣味编程","slug":"趣味编程","permalink":"http://example.com/categories/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"标志位法实现循环队列","slug":"标志位法实现循环队列","date":"2019-09-06T07:22:37.000Z","updated":"2020-11-29T19:35:21.215Z","comments":true,"path":"2019/09/06/标志位法实现循环队列/","link":"","permalink":"http://example.com/2019/09/06/%E6%A0%87%E5%BF%97%E4%BD%8D%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"为了解决顺序队列假溢出的问题，提出了循环队列。使得内存的利用率得到了很大的提升。但是在判断循环队列空和满这两种状态任然存在问题，因为对于一个循环队列，不做任何判空和判满的机制。判空和判满的条件都是：q-&gt;rear == q-&gt;front。带来的问题就是当出现上述条件时不能区分循环队列到底是空还是满，因此为了解决上述问题。人们提出以下两种方案来解决：（1）牺牲一个位置用作判断的条件 队空：q-&gt;rear == q-&gt;front队满：(q-&gt;rear + 1）% N = q-&gt;front，其中N为最大队列容量 （2）设置标志位来区分队空和队满，这样就不需要牺牲空间，使得循环队列的空间得到了最大的利用。缺点是需要做很多的逻辑判断来处理标志位。 队空：q-&gt;rear == q-&gt;front &amp;&amp; q-&gt;tag == 0队满：q-&gt;rear == q-&gt;front &amp;&amp; q-&gt;tag == 1此外，在标志位实现循环队列的机制下，需要几个计数器来统计当前队列中元素的个数，方便处理q-&gt;tag。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;using namespace std;#define N 5typedef struct node &#123; int data[N]; int rear, front; bool tag;&#125;queue;int cnt &#x3D; 0;bool isEmpty(queue *q) &#123; return q-&gt;rear &#x3D;&#x3D; q-&gt;front &amp;&amp; q-&gt;tag &#x3D;&#x3D; 0;&#125;bool isFull(queue *q) &#123; return q-&gt;rear &#x3D;&#x3D; q-&gt;front &amp;&amp; q-&gt;tag &#x3D;&#x3D; 1;&#125;void init(queue *q) &#123; q-&gt;rear &#x3D; q-&gt;front &#x3D; 0; q-&gt;tag &#x3D; 0;&#125;void push(queue *q, int x) &#123; if (isFull(q)) &#123; cout &lt;&lt; &quot;full&quot; &lt;&lt; endl; return ; &#125; else&#123; q-&gt;data[q-&gt;rear] &#x3D; x; q-&gt;rear &#x3D; (q-&gt;rear+1) % N; cnt ++; if (cnt &#x3D;&#x3D; N) q-&gt;tag &#x3D; 1; &#125;&#125;void pop(queue *q) &#123; if (isEmpty(q)) &#123; cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl; return; &#125; else &#123; cnt --; if (cnt &#x3D;&#x3D; 0) q-&gt;tag &#x3D; 0; q-&gt;front &#x3D; (q-&gt;front + 1) % N; &#125;&#125;int front(queue *q) &#123; if (isEmpty(q)) &#123; cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl; return -1; &#125; else &#123; int res &#x3D; q-&gt;data[q-&gt;front]; q-&gt;front &#x3D; (q-&gt;front + 1) % N; cnt --; if (cnt &#x3D;&#x3D; 0) q-&gt;tag &#x3D; 0; return res; &#125;&#125;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); queue q; init(&amp;q); for (int i&#x3D;0; i&lt;n; ++i) &#123; push(&amp;q, a[i]); &#125; while (!isEmpty(&amp;q))&#123; cout &lt;&lt; front(&amp;q) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"栈的应用：进制转换","slug":"栈的应用：进制转换","date":"2019-09-06T06:15:13.000Z","updated":"2020-11-29T19:35:21.527Z","comments":true,"path":"2019/09/06/栈的应用：进制转换/","link":"","permalink":"http://example.com/2019/09/06/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;#define N 100#define type inttype st[N];int top &#x3D; -1;bool isEmpty() &#123; return top &#x3D;&#x3D; -1;&#125;bool isFull() &#123; return top &#x3D;&#x3D; N - 1;&#125;void push(int x) &#123; if (!isFull()) st[++ top] &#x3D; x; else cout &lt;&lt; &quot;full&quot; &lt;&lt; endl; &#125;void pop() &#123; if (!isEmpty()) -- top; else cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;&#125;int peek() &#123; if (!isEmpty()) return st[top]; cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;&#125;map&lt;int, char&gt; mp&#123; &#123;10,&#39;A&#39;&#125;,&#123;11,&#39;B&#39;&#125;,&#123;12,&#39;C&#39;&#125;,&#123;13,&#39;D&#39;&#125;,&#123;14,&#39;E&#39;&#125;,&#123;15,&#39;F&#39;&#125; &#125;; void conversion(int x, int base) &#123; while (x) &#123; push(x % base); x &#x2F;&#x3D; base; &#125; while (!isEmpty()) &#123; int res &#x3D; peek();pop(); if (res &gt;&#x3D; 10) cout &lt;&lt; mp[res] &lt;&lt; &quot; &quot;; else cout &lt;&lt; res &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; int a &#x3D; 1000; conversion(a, 16); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"栈的应用：括号匹配(C++)","slug":"栈的应用：括号匹配(C++)","date":"2019-09-06T05:34:11.000Z","updated":"2020-11-29T19:35:21.559Z","comments":true,"path":"2019/09/06/栈的应用：括号匹配(C++)/","link":"","permalink":"http://example.com/2019/09/06/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D(C++)/","excerpt":"","text":"一.要点（1）利用栈先进后出的特点，当遇到左括号”[“,”{“,””(“时，直接入栈。（2）当遇到右括号”)”,”}”,”]”时，如果此时空的，那么成对的括号一定不能进行匹配，直接返回false即可。（3）可以出栈的情况，当栈顶的左括号与当前的右括号匹配时，出栈。（4）遍历过程中出现的其他情况都是错误的。比如栈顶为左括号，当前遍历到也是左括号。（5）当遍历完成时，如果栈不空，说明还有未进行匹配的左括号，也就意味括号匹配失败，直接返回false即可。二.代码实现 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;bool isValid(string s) &#123; stack&lt;char&gt; st; for (auto x : s) &#123; if (x &#x3D;&#x3D; &#39;[&#39; || x &#x3D;&#x3D; &#39;(&#39; || x &#x3D;&#x3D; &#39;&#123;&#39;) st.push(x); else if (st.empty()) return false; else if ( (st.top() &#x3D;&#x3D; &#39;(&#39; &amp;&amp; x &#x3D;&#x3D; &#39;)&#39;) || (st.top () &#x3D;&#x3D; &#39;[&#39; &amp;&amp; x &#x3D;&#x3D; &#39;]&#39;) || (st.top() &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; x &#x3D;&#x3D; &#39;&#125;&#39;) ) st.pop(); else return false; &#125; return st.empty();&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; isValid(s) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"中缀表达式转后缀表达式以及计算后缀表达式的值(C++)","slug":"中缀表达式转后缀表达式以及计算后缀表达式的值(C++)","date":"2019-09-06T01:05:42.000Z","updated":"2020-11-29T19:35:21.547Z","comments":true,"path":"2019/09/06/中缀表达式转后缀表达式以及计算后缀表达式的值(C++)/","link":"","permalink":"http://example.com/2019/09/06/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC(C++)/","excerpt":"","text":"1.中缀转后缀的要点(1)遇到数字需要直接输出，但是有时数字可能不只是一个个位数，因此需要遍历表达式，获取该值。(2)如果运算符栈为空，如果遇到运算符，直接入栈。(3)如果遇到”(“，直接入栈。(4)如果遇到”)”，连续出栈，一直到栈顶元素是”(“，然后出栈”(“。(5)如果遇到运算符且运算符栈不为空，此时需要比较当前运算符和栈顶运算符的优先级。分两种情况：1.当前运算符优先级大于栈顶运算符优先级，直接入栈。2.当前运算符优先小于栈顶运算符优先级，需要一直出栈，直到栈顶运算符优先小于当前运算符，将当前运算符入栈。 2.代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;sstream&gt;using namespace std;#define ERROR 0x3f3fstring cto_string(char c) &#123; stringstream stream; stream &lt;&lt; c; return stream.str();&#125;int cmp(char a, char b) &#123; if (a&#x3D;&#x3D;&#39;+&#39;) &#123; if (b &#x3D;&#x3D; &#39;-&#39; || b &#x3D;&#x3D; &#39;+&#39;) return 0; else if (b &#x3D;&#x3D; &#39;*&#39; || b &#x3D;&#x3D; &#39;&#x2F;&#39;) return -1; else if (b &#x3D;&#x3D; &#39;(&#39;) return 1; &#125; else if (a &#x3D;&#x3D; &#39;-&#39;) &#123; if (b &#x3D;&#x3D; &#39;-&#39; || b &#x3D;&#x3D; &#39;+&#39;) return 0; else if (b &#x3D;&#x3D; &#39;*&#39; || b &#x3D;&#x3D; &#39;&#x2F;&#39;) return -1; else if (b &#x3D;&#x3D; &#39;(&#39;) return 1; &#125; else if (a &#x3D;&#x3D; &#39;*&#39;) &#123; if (b &#x3D;&#x3D; &#39;*&#39; || b &#x3D;&#x3D; &#39;&#x2F;&#39;) return 0; else if(b &#x3D;&#x3D; &#39;+&#39; || b &#x3D;&#x3D; &#39;-&#39; || b &#x3D;&#x3D; &#39;(&#39;) return 1; &#125; else if (a &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; if (b &#x3D;&#x3D; &#39;*&#39; || b &#x3D;&#x3D; &#39;&#x2F;&#39;) return 0; else if(b &#x3D;&#x3D; &#39;+&#39; || b &#x3D;&#x3D; &#39;-&#39; || b &#x3D;&#x3D; &#39;(&#39;) return 1; &#125; else &#123; cout &lt;&lt; &quot;invalid sign&quot; &lt;&lt; endl; return ERROR; &#125;&#125; vector&lt;string&gt; res;vector&lt;string&gt; InfixToSuffix(string infix) &#123; stack&lt;char&gt; st; int i &#x3D; 0; while (i &lt; infix.length()) &#123; if (infix[i] &#x3D;&#x3D; &#39;(&#39;) &#123; st.push(infix[i]); i ++; &#125; else if (infix[i] &#x3D;&#x3D; &#39;)&#39;) &#123; while (!st.empty()) &#123; char op &#x3D; st.top();st.pop(); if (op &#x3D;&#x3D; &#39;(&#39;) break; else res.push_back(cto_string(op)); i ++; &#125; &#125; else if (isdigit(infix[i])) &#123; int n &#x3D; infix[i ++] - &#39;0&#39;; while (i &lt; infix.length() &amp;&amp; isdigit(infix[i])) &#123; n &#x3D; n * 10 + (infix[i ++] - &#39;0&#39;); &#125; res.push_back(to_string(n)); &#125; else &#123; if (st.empty()) st.push(infix[i]); else &#123; if (cmp(infix[i], st.top()) &gt; 0) st.push(infix[i]); else if (cmp(infix[i], st.top()) &lt;&#x3D; 0) &#123; while (!st.empty()) &#123; char op &#x3D; st.top();st.pop(); res.push_back(cto_string(op)); if (cmp(infix[i], op) &gt; 0) break; &#125; st.push(infix[i]); &#125; &#125; i ++; &#125; &#125; while (!st.empty()) &#123; res.push_back(cto_string(st.top())); st.pop(); &#125; return res;&#125; &#x2F;&#x2F;计算后缀表达式的值 int calculate(vector&lt;string&gt;&amp; a) &#123; stack&lt;int&gt; st; for (auto x : a) &#123; if (x &#x3D;&#x3D; &quot;+&quot;) &#123; int a &#x3D; st.top();st.pop(); int b &#x3D; st.top();st.pop(); st.push(b + a); &#125; else if (x &#x3D;&#x3D; &quot;-&quot;) &#123; int a &#x3D; st.top();st.pop(); int b &#x3D; st.top();st.pop(); st.push(b - a); &#125; else if (x &#x3D;&#x3D; &quot;*&quot;) &#123; int a &#x3D; st.top();st.pop(); int b &#x3D; st.top();st.pop(); st.push(b * a); &#125; else if (x &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123; int a &#x3D; st.top();st.pop(); int b &#x3D; st.top();st.pop(); st.push(b &#x2F; a); &#125; else &#123; st.push(stoi(x)); &#125; &#125; return st.top();&#125;void print(string a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125; int main() &#123;; string s; cin &gt;&gt; s; vector&lt;string&gt; t &#x3D; InfixToSuffix(s); for_each(t.begin(), t.end(), print);cout &lt;&lt; endl; int ans &#x3D; calculate(t); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"推导B树的最大高度和最小高度得出B树的高度范围","slug":"推导B树的最大高度和最小高度得出B树的高度范围","date":"2019-08-28T03:17:08.000Z","updated":"2020-11-29T19:35:21.539Z","comments":true,"path":"2019/08/28/推导B树的最大高度和最小高度得出B树的高度范围/","link":"","permalink":"http://example.com/2019/08/28/%E6%8E%A8%E5%AF%BCB%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6%E5%92%8C%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E5%BE%97%E5%87%BAB%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E8%8C%83%E5%9B%B4/","excerpt":"","text":"前提条件：n&gt;=1，则对于任意一棵包含n个关键字、高度为h、阶数为m的B树。 一、最小高度： 对于任意树类型的数据结构，如果其每层节点能够分布的足够满，其高度也会随之变得足够的低。基于这个思路，对于B树无外乎也是一种树，B树的关键字数以及儿子节点个数满足这样的条件(ceil代表向上取整)： 1234567&#x2F;&#x2F;根节点 儿子节点个数[2, m]关键字个数[1, m-1]&#x2F;&#x2F;非根节点儿子节点个数[ceil(m&#x2F;2), m]关键字个数[ceil(m&#x2F;2)-1, m-1] 为了使得B树高度最低，也就是每层的节点数达到最大，看如下的计算过程：二、最大高度： 要使得B树的高度达到最大，也就意味着在每个节点中，关键字的个数达到最小，这样在容纳相同个数的关键字的B树中，其高度可以达到最大。有了上边我们对最小关键字大小把控，下面来推到B树的最大高度：总结： 由一和二可知，通过寻找B树的两种极限的存在，推出B树的高度范围为：logm(n+1)&lt;= h &lt;=log(ceil(m/2)) (n+1)/2 + 1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"最短路径：dijkstra算法","slug":"最短路径：dijkstra算法","date":"2019-08-24T14:34:59.000Z","updated":"2020-11-29T19:35:21.551Z","comments":true,"path":"2019/08/24/最短路径：dijkstra算法/","link":"","permalink":"http://example.com/2019/08/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra%E7%AE%97%E6%B3%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;#define N 510#define INF 0x3f3f3f3int g[N][N];int dist[N];bool st[N];int n, m;&#x2F;&#x2F;返回值为1到n的路径长度int dijkstra() &#123; memset(dist, INF, sizeof dist); dist[1] &#x3D; 0;&#x2F;&#x2F;初始路径长度为0 自己到自己 for(int i&#x3D;0; i&lt;n; ++i) &#123; int t &#x3D; -1; for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123; if(!st[j] &amp;&amp; (t&#x3D;&#x3D;-1 || dist[j] &lt; dist[t]) t &#x3D; j; &#125; st[t] &#x3D; 1; &#x2F;&#x2F;松弛操作 for(int j&#x3D;1; j&lt;&#x3D;n; ++j) dist[j] &#x3D; min(dist[j], dist[t] +g[t][j]); &#125; if(dist[n] &#x3D;&#x3D; INF) return -1; else return dist[n];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123; for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123; if(i &#x3D;&#x3D; j) g[i][j] &#x3D; 0; else g[i][j] &#x3D; INF; &#125; &#125; while(m --) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] &#x3D; min(g[a][b], c); &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构 图论","slug":"数据结构-图论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"共享栈的实现&两个栈实现一个队列&两个队列实现一个栈","slug":"共享栈的实现&两个栈实现一个队列&两个队列实现一个栈","date":"2019-08-24T06:21:27.000Z","updated":"2020-11-29T19:36:13.179Z","comments":true,"path":"2019/08/24/共享栈的实现&两个栈实现一个队列&两个队列实现一个栈/","link":"","permalink":"http://example.com/2019/08/24/%E5%85%B1%E4%BA%AB%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0&%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97&%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/","excerpt":"","text":"1.共享栈的实现 共享栈能够更加有效的节省内存空间，其实现比较简单，就是再同一个数组上存放两个栈，这就需要两个栈顶指针来标记。判断栈满, 一般当两个栈顶指针相距为1时，就认为共享栈此时已经满了，其实就是牺牲了一个存储空间用来判断满。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace stdl#define N 100 &#x2F;&#x2F;共享栈数组的大小int s[N];int top1 &#x3D; -1;&#x2F;&#x2F;左栈栈顶指针初始化为-1 是一个无效索引int top2 &#x3D; N;&#x2F;&#x2F;右栈栈顶指针初始化为N，同样也是一个无效的索引&#x2F;&#x2F;无论是左边的栈顶指针还是右边在栈顶指针其范围都是在[0...N-1]这个闭区间中，因此他俩的初始值选择-1和N是合适的bool isFull() &#123;return top2 - top1 &#x3D;&#x3D; 1;&#125;&#x2F;&#x2F;idx表示向哪个栈入栈 idx&#x3D;&#x3D;1 表示左栈 idx&#x3D;&#x3D;2表示右栈 &#x2F;&#x2F;在下边top()和pop()实现的中，idx的含义和此处相同void push(int x, int idx) &#123; if(isFull()) &#123; cout &lt;&lt; &quot;full!&quot; &lt;&lt; endl; &#125; assert(idx &#x3D;&#x3D; 1 || idx &#x3D;&#x3D; 2); if(idx &#x3D;&#x3D; 1) &#123; s[++ top1] &#x3D; x; &#125; else if(idx &#x3D;&#x3D; 2) &#123; s[-- top2] &#x3D; x; &#125;&#125; void pop(int idx) &#123; if(idx &#x3D;&#x3D; 1) &#123; if(top1&#x3D;&#x3D;-1) &#123; cout &lt;&lt; &quot;empty! can&#39;t pop!&quot; &lt;&lt; endl; &#125; -- top1; &#125;else if(idx &#x3D;&#x3D; 2) &#123; if(top2 &#x3D;&#x3D; N) &#123; cout &lt;&lt; &quot;empty! can&#39;t pop!&quot; &lt;&lt; endl; &#125; ++ top2; &#125;&#125;int top(int idx) &#123; if(idx &#x3D;&#x3D; 1) &#123; if(top1 &#x3D;&#x3D; -1) &#123; cout &lt;&lt; &quot;empty!&quot; &lt;&lt; endl; return -1; &#125; return s[top1]; &#125; else if(idx &#x3D;&#x3D; 2) &#123; if(top2 &#x3D;&#x3D; N) &#123; cout &lt;&lt; &quot;empty!&quot; &lt;&lt; endl; return -1; &#125; return s[top2]; &#125;&#125; 2.两个栈实现一个队列 一个栈用来存储数据，另外一个栈作为辅助。front();//存放数据的栈先转换到辅助栈中，刚好就是给数据栈的顺序逆置了，这个时候获取辅助栈的栈顶元素，即为队头元素pop();//方法同上，只需要将辅助栈进行pop()，即是完成对队列的pop()empty();//只需要判断数据栈是否为空，就能说明队列是否为空，因此只需要调用数据栈的empty()函数即可这里需要一个重要的辅助函数，其功能就是将a栈的数据转化到b栈，元素的顺序关系刚好是逆置的，如下图所示：具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stack&gt;#include &lt;iostream&gt;using namespace std;class Queue&#123;private: stack&lt;int&gt; data, aux;public: void push(int x) &#123;data.push(x);&#125; int front() &#123; inverse(data, aux); int res &#x3D; aux.top(); inverse(aux, data); return res; &#125; void pop() &#123; inverse(data, aux); aux.pop(); inverse(aux, data); &#125; bool empty() &#123;return data.empty();&#125; &#x2F;&#x2F;最重要的一个方法 &#x2F;&#x2F;将a栈中数据转到b栈中 数据元素的顺序刚好发生了改变 void inverse(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b) &#123; while(!a.empty()) &#123; b.push(a.top());a.pop(); &#125; &#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); Queue q; for(int i&#x3D;0; i&lt;n; ++i) q.push(a[i]); while(!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;q.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; 执行结果： 3.两个队列实现一个栈 由于栈先进后出的特性，用队列来实现栈时，当我们需要对这个封装的栈进行pop()和top()操作时，一定是对最后一个进队列的元素进行操作，一种是出栈即为队列的pop()，另外一种是获取栈顶元素即为队列front()，基于这个特点我们很好写top()和pop()操作。 具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;class Stack&#123;private: queue&lt;int&gt; data, aux;&#x2F;&#x2F;aux队列用来保存在data队列中除了最后一个元素外的其他所有元素public: void push(int x) &#123;data.push(x);&#125; void pop() &#123; while(data.size() &gt; 1) &#123; aux.push(data.front()); data.pop(); &#125; data.pop(); while(!aux.empty()) &#123; data.push(aux.front()); aux.pop(); &#125; &#125; int top() &#123; while(data.size() &gt; 1) &#123; aux.push(data.front());data.pop(); &#125; int res &#x3D; data.front(); aux.push(data.front()); data.pop(); while(!aux.empty()) &#123; data.push(aux.front()); aux.pop(); &#125; return res; &#125; bool empty() &#123;return data.empty();&#125;&#125;;int main() &#123; int a[] &#x3D; &#123;1,2,3,4,5&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); Stack s; for(int i&#x3D;0; i&lt;n; ++i) s.push(a[i]); while(!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;; s.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; 执行结果：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"拓扑排序","slug":"拓扑排序","date":"2019-08-24T02:33:29.000Z","updated":"2020-11-29T19:35:21.567Z","comments":true,"path":"2019/08/24/拓扑排序/","link":"","permalink":"http://example.com/2019/08/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"AcWing848.有向图的拓扑序列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N&#x3D;1e5+10;int n, m;vector&lt;int&gt; G[N];int indegree[N];vector&lt;int&gt; ans;bool topSort() &#123; int cnt &#x3D; 0; queue&lt;int&gt; q; for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123; if(indegree[i] &#x3D;&#x3D; 0) &#123; q.push(i); &#125; &#125; while(!q.empty()) &#123; int u &#x3D; q.front();q.pop(); ans.push_back(u); for(int i&#x3D;0; i&lt;G[u].size(); ++i) &#123; int v &#x3D; G[u][i]; indegree[v] --; if(indegree[v] &#x3D;&#x3D; 0) q.push(v); &#125; G[u].clear(); cnt ++; &#125; return cnt &#x3D;&#x3D; n;&#125;int main() &#123; memset(indegree, 0, sizeof indegree); cin &gt;&gt; n &gt;&gt; m; while(m --) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); indegree[b] ++; &#125; if(!topSort())cout &lt;&lt; -1 &lt;&lt; endl; else&#123; for(int i&#x3D;0; i&lt;ans.size(); ++i) &#123; cout &lt;&lt; ans[i]; if(i!&#x3D;ans.size()-1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构 图论","slug":"数据结构-图论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"数据结构：归并排序（自顶向下和自底向上）递归和非递归","slug":"数据结构：归并排序（自顶向下和自底向上）递归和非递归","date":"2019-08-23T01:42:47.000Z","updated":"2020-11-29T19:35:21.567Z","comments":true,"path":"2019/08/23/数据结构：归并排序（自顶向下和自底向上）递归和非递归/","link":"","permalink":"http://example.com/2019/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%EF%BC%89%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92/","excerpt":"","text":"1.自顶向下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;合并两个有序数组的操作&#x2F;&#x2F;索引m是第二区间的左边界void merge(int *a, int l, int m, int r) &#123; int LEFT_SZIE &#x3D; m - l; int RIGHT_SIZE &#x3D; r - m + 1; int *left &#x3D; new int[LEFT_SIZE]; int *right &#x3D; new int[RIGHT_SIZE]; for(int i&#x3D;l; i&lt;m; ++i) left[i-l] &#x3D; a[i]; for(int i&#x3D;m; i&lt;&#x3D;r; ++i) right[i-m] &#x3D; a[i]; int i&#x3D;0, j&#x3D;0, k&#x3D;l; while(i &lt; LEFT_SZIE &amp;&amp; j &lt; RIGHT_SIZE) &#123; if(left[i] &lt; right[j]) a[k ++] &#x3D; left[i ++]; ekse a[k ++] &#x3D; right[j ++]; &#125; while(i &lt; LEFT_SIZE) a[k ++] &#x3D; left[i ++]; while(j &lt; RIGHT_SIZE) a[k ++] &#x3D; right[j ++]; delete[] left; delete[] right;&#125;void _mergeSort(int *a, int l, int r) &#123; if(l &gt;&#x3D; r) return; int m &#x3D; (r - l) &#x2F; 2 + l; _mergeSort(a, l, m); _mergeSort(a, m+1, r); merge(a, l, m+1, r);&#125;void mergeSort(int *a, int n) &#123; _mergeSort(a, 0, n-1);&#125;int main() &#123; int a[] &#x3D; &#123;4, 1, 8, 0, 3, 5, 7, 6, 2&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); cout &lt;&lt; n &lt;&lt; endl; mergeSort(a, n); for_each(a, a+n, [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;); cout &lt;&lt; endl; return 0;&#125; 2.自底向上 12345678910111213141516171819202122232425&#x2F;&#x2F;merge操作和上边是一样的&#x2F;&#x2F;这种实现方式参考算法四的实现void _mergeSortBU(int *a, int n) &#123; for(int sz&#x3D;1; sz&lt;n; sz+&#x3D;sz) &#x2F;&#x2F;对a[i...i+sz-1]和a[i+sz....i+2*sz-1]进行归并 &#x2F;*(1)为了保证由两个归并段i+sz &lt; n (2)为了保证不越界 min(i+2*sz-1, n-1)*&#x2F; for(int i&#x3D;0; i+sz&lt;n; i+&#x3D;sz+sz) merge(a, i, i+sz, min(i+sz+sz-1, n-1));&#125;void mergeSortBU(int *a, int n) &#123; _mergeSortBU(a, n);&#125;int main() &#123; int a[] &#x3D; &#123;4, 1, 8, 0, 3, 5, 7, 6, 2&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); cout &lt;&lt; n &lt;&lt; endl; mergeSortBU(a, n); for_each(a, a+n, [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;); cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构：快速排序的两种常见的partition操作以及非递归形式","slug":"数据结构：快速排序的两种常见的partition操作以及非递归形式","date":"2019-08-23T00:37:42.000Z","updated":"2020-11-29T19:35:21.555Z","comments":true,"path":"2019/08/23/数据结构：快速排序的两种常见的partition操作以及非递归形式/","link":"","permalink":"http://example.com/2019/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84partition%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/","excerpt":"","text":"1.递归形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int partition(int *a, int l, int r) &#123; swap(a[l], a[rand() % (r-l+1) + l]); int j &#x3D; l; int e &#x3D; a[l]; for(int i&#x3D;l+1; i&lt;&#x3D;r; ++i) &#123; if(a[i] &lt; e) &#123; swap(a[j+1], a[i]); j ++; &#125; &#125; swap(a[j], a[l]); return j;]int partition1(int *a, int l, int r) &#123; swap(a[l], a[rand() % (r-l+1) + l]); int e &#x3D; a[l]; while(l &lt; r) &#123; while(l &lt; r &amp;&amp; a[r] &gt; e) r --; a[l] &#x3D; a[r]; while(l &lt;r &amp;&amp; a[l] &lt;&#x3D; e) l ++; a[r] &#x3D; a[l]; &#125; a[l] &#x3D; e; return l;&#125;void _quickSort(int *a, int l, int r) &#123; jf(l &gt;&#x3D; r) return ; int p &#x3D; partition(a, l, r); _quickSort(a, l, p-1); _quickSort(a, p+1, r);&#125;&#x2F;&#x2F;统一接口void quickSort(int *a, int n) &#123; _quickSort(a, 0, n-1);&#125;int main() &#123; int a[] &#x3D; &#123;4, 0, 9, 7, 1, 2, 3, 6, 8, 2&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); quickSort(a, n); for_each(a, a+n, [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot; ;&#125;);cout &lt;&lt; endl; return 0;&#125; 2.非递归形式 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;划分操作和上边一样#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt; &#x2F;&#x2F;非递归需要使用栈来保存区间端点的索引using namespace std;void _quickSort(int *a, int l, int r) &#123; stack&lt;int&gt; st; st.push(l); st.push(r). while(!st.empty()) &#123; int right &#x3D; st.top(); st.pop(); int left &#x3D; st.top(); st.pop(); &#x2F;&#x2F;进行一次划分 int p &#x3D; partition(a, left, right); &#x2F;&#x2F;说明左区间还未划分 if(left &lt; p-1) &#123; q.push(left); q.push(p-1); &#125; &#x2F;&#x2F;说明右区间还未划分 if(p+1 &lt; right) &#123; q.push(p+1); q.push(right); &#125; &#125;&#125;void quickSort(int *a, int l, int r) &#123; _quickSort(a, 0, n-1);&#125;int main() &#123; int a[] &#x3D; &#123;4, 0, 9, 7, 1, 2, 3, 6, 8, 2&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); quickSort(a, n); for_each(a, a+n, [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot; ;&#125;);cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构：最小生成树算法模板prim和kruskal（考研）","slug":"数据结构：最小生成树算法模板prim和kruskal（考研）","date":"2019-08-22T09:34:15.000Z","updated":"2020-11-29T19:35:21.511Z","comments":true,"path":"2019/08/22/数据结构：最小生成树算法模板prim和kruskal（考研）/","link":"","permalink":"http://example.com/2019/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BFprim%E5%92%8Ckruskal%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"1.prim 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorihtm&gt;using namespace std;const int N&#x3D;510;const int INF&#x3D;0x3f3f3f3f;int dist[N];&#x2F;&#x2F;保存距离bool st[N];&#x2F;&#x2F;标记点是否已经被访问过int g[N][N];&#x2F;&#x2F;邻接矩阵存储图int n, m;&#x2F;&#x2F;返回值为最小生成树的权值int prim() &#123; memset(dist, INF, sizeof(dist)); int res &#x3D; 0; for(int i&#x3D;0; i&lt;n; ++i) &#123; int t &#x3D; -1; &#x2F;&#x2F;寻找当前权值最小的边 并将其所连接的边并入的MST中 for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123; &#x2F;&#x2F;这里包含了两种情况 &#x2F;&#x2F;（1）初始状态t&#x3D;&#x3D;-1 （2）其他边的权值更小并且所连接的点没有被访问过 if(!st[j] &amp;&amp; (t&#x3D;&#x3D;-1 || dist[j] &lt; dist[t]) t &#x3D; j; &#125; if(i &amp;&amp; dist[t]&#x3D;&#x3D;INF) return INF; if(i) res +&#x3D; dist[t];&#x2F;&#x2F; 因为t&#x3D;&#x3D;0的时候res&#x3D;0 不需要你进行相加 st[t] &#x3D; true;&#x2F;&#x2F;标记访问过了 &#x2F;&#x2F;以t顶点作为媒介 更新侯选边的权值 for(int j&#x3D;1; j&lt;&#x3D;n; ++j) dist[j] &#x3D; min(dist[j], g[t][j]); &#125; return res;&#125; 2.kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N&#x3D;510;const int M&#x3D;1000;const int INF&#x3D;0x3f3f3f3f;int father[N];int find(int x) &#123; int a &#x3D; x; while(x !&#x3D; father[x]) x &#x3D; father[x]; while(a !&#x3D; father[a]) &#123; int z &#x3D; a; father[z] &#x3D; x; a &#x3D; father[a]; &#125; return x;&#125;void Union(int a, int b) &#123; int fa &#x3D; find(a); int fb &#x3D; find(b); if(fa !&#x3D; fb) father[fa] &#x3D; fb;&#125;&#x2F;&#x2F;边类struct Edge&#123; int a, b; int weight;&#125;edges[M];&#x2F;&#x2F;返回值为MST的权值int kruskal() &#123; int res &#x3D; 0; int cnt &#x3D; 0; sort(edges, edges+m, [](const Edge &amp;a, const Edge&amp; b) &#123;return a.weight &lt; b.weight;&#125;); for(int i&#x3D;1; i&lt;&#x3D;n; ++i) father[i] &#x3D; i;&#x2F;&#x2F;初始化并查集数组 &#x2F;&#x2F;遍历边集 已经按照权值由小到大排好序了 for(int i&#x3D;0; i&lt;m; ++i) &#123; int a &#x3D; edges[i].a; int b &#x3D; edges[i].b; &#x2F;&#x2F;为了保证添加进去edges[i]这条边后不形成回路 &#x2F;&#x2F;所以首先要判断这条边的两个顶点是否在 不同的连通分量中 if(find(a) !&#x3D; find(b)) &#123; &#x2F;&#x2F;证明两个顶点在不同的连通分量中 res +&#x3D; edges[i].weight; Union(a, b); cnt ++; &#125; &#125; &#x2F;&#x2F;如果最后得到的MST的边数 小于 n-1 证明不是最小生成树 if(cnt &lt; n-1) return INF; return res;&#125;","categories":[{"name":"数据结构 图论","slug":"数据结构-图论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"基数排序的简单实现","slug":"基数排序的简单实现","date":"2019-08-20T09:00:00.000Z","updated":"2020-11-29T19:35:21.847Z","comments":true,"path":"2019/08/20/基数排序的简单实现/","link":"","permalink":"http://example.com/2019/08/20/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"基数排序是基于分配和收集来进行的，而通常内部排序是基于比较进行的，这一点需要注意。基数排序里涉及到多次的除法和模运算，因此基数排序是的执行时间较长。这里使用STL中的queue来作为桶，不需要单独去实现队列。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;&#x2F;&#x2F;这里选择基数位10 对10进制的数字进行基数排序&#x2F;&#x2F;获取10进制数的第i位 i从0开始&#x2F;*比如987， 第0位为7， 第一位为8， 第二位为9*&#x2F;int getBit(int x, int i) &#123; while(i --) x &#x2F;&#x3D; 10; return x %&#x3D; 10;&#125;&#x2F;&#x2F;基数排序要求数组中的每一个数字的位数相同 d表示位数 void radixSort(int *a, int n, int d) &#123; queue&lt;int&gt; q[10];&#x2F;&#x2F;10进制数需要10个桶 &#x2F;&#x2F;d位的数字需要进行 d趟的收集与分配 for(int i&#x3D;0; i&lt;d; ++i) &#123; &#x2F;&#x2F;分配 for(int j&#x3D;0; j&lt;n; ++j) q[getBit(a[j], i)].push(a[j]); &#x2F;&#x2F;收集 for(int j&#x3D;0, k&#x3D;0; j&lt;10; ++j) &#123; while(! q[j].empty()) &#123; a[k ++] &#x3D; q[j].front(); q[j].pop(); &#125; &#125; &#125;&#125;int main() &#123; int a[] &#x3D; &#123;33, 44, 11, 88, 22, 77, 99, 66, 55&#125;; int n &#x3D; sizeof a&#x2F;sizeof(int); radixSort(a, n, 2); for_each(a, a+n, [](int a)&#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;); return 0;&#125; 执行结果：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：选择类型排序的总结（考研）","slug":"数据结构：选择类型排序的总结（考研）","date":"2019-08-20T01:08:14.000Z","updated":"2020-11-29T19:35:21.915Z","comments":true,"path":"2019/08/20/数据结构：选择类型排序的总结（考研）/","link":"","permalink":"http://example.com/2019/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%80%89%E6%8B%A9%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"选择排序包括：选择排序，双选择排序以及堆排序。选择排序的核心是每一趟排序中查找最小值或者最大值的索引，然后与边界的位置进行交换。例如当前待排序的元素值为a[i]，设置最小值所对应的索引为minIndex，初始值就为i。这样一次循环后，minIndex的值可能会变，也可能不变，只有当变化的时候我们交换一下即可。下面看一下常见的选择类型的排序。 (1)选择排序 1234567891011void selectSort(int *a, int n) &#123; for(int i&#x3D;0; i&lt;n; ++i) &#123; int minIndex &#x3D; i;&#x2F;&#x2F;记录最小值所对应的索引 初始值为i &#x2F;&#x2F;查找最小值所对应的索引 for(int j&#x3D;i+1; j&lt;n; ++j) &#123; if(a[j] &lt; a[minIndex]) minIndex &#x3D; j; &#125; &#x2F;&#x2F;最小值索引发生了改变 我们就交换他俩 if(i !&#x3D; minIndex) swap(a[i], a[minIndex]); &#125;&#125; (2)双选择排序 双选择排序本质上还是选择排序，可以说只是对直接选择排序做了优化。双选择排序每趟循环中同时找到最大值和最小值的索引，最大值和最小值初始的索引为待排序数组的两个边界，当一趟查找结束后，如果有索引发生了变化，就进行交换。 1234567891011121314151617void biSelectSort(int *a, int n) &#123; int left&#x3D;0, right&#x3D;n-1;&#x2F;&#x2F;待排序数组的两个边界 &#x2F;&#x2F;只有当数组中还有两个元素时才需要进行排序 只有一个时数组已经有序 while(left &lt; right) &#123; int minIndex&#x3D;left, maxIndex&#x3D;right; &#x2F;&#x2F;保证最小值一定小于最大值 if(a[minIndex] &lt; a[maxIndex]) swap(a[minIndex], a[maxIndex]); &#x2F;&#x2F;在[left+1, right-1]闭区间中 查找最大值和最小值的索引 for(int i&#x3D;left+1; i&lt;right; ++i) &#123; if(a[i] &lt; a[minIndex) minIndex &#x3D; i; else if(a[i] &gt; a[maxIndex]) maxIndex &#x3D; i; &#125; swap(a[left], a[minIndex]); swap(a[right], a[maxIndex]); left ++, right --;&#x2F;&#x2F;缩小范围 &#125; &#125; (3)堆排序 堆排序在底层中使用了堆这样的数据结构，堆维护的性质是，若为大根堆，则任意根节点的值大于其左右孩子节点的值。堆同时是一完全二叉树的的逻辑结构，堆很方便的可以使用数组来实现，因此是一种线性的存储结构，方便编程，主要利用到是完全二叉树的性质： 1.若任意节点的索引为j,若其左右孩子都存在，则它们的索引分别是2 * j和2*j+1。2.任意节点的父亲节点的索引为j/2，满足这样关系的前提条件是数组下标从1开始，否则若根节点的下标从0开始判断比较麻烦，需要讨论奇偶性。所以在实现的时候我们需要多开辟一个存储空间，因为鼠标下标为0的位置不使用。下面来看堆排序的简单实现： 12345void heapSort(int *a, int n) &#123; Heap&lt;int&gt; heap(n); for(int i&#x3D;0; i&lt;n; ++i) heap.insert(a[i]); for(int i&#x3D;0; i&lt;n; ++i) a[i] &#x3D; extractMin();&#125; 时间复杂度的分析：在heapSort的实现过程中，insert方法中会涉及shitfUp操作，shiftUp操作的时间复杂度为O(logn)，外层循环的时间复杂度为O(n)，因此第一层总的时间复杂度为O(n * logn), 同样第二层循环，外层循环的时间复杂度为O(n)， 内层extractMin()函数会涉及到shiftDown操作， shiftDown操作的时间复杂度为O(logn), 因此总的时间复杂度也为O(n * logn), 所以最终总的时间复杂度任为O(n * logn)。下面来看小根堆的简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#Include &lt;cassert&gt;using namespace std;template &lt;typename T&gt;class Heap&#123;private: int cnt;&#x2F;&#x2F;当前堆中的节点个数 int capacity;&#x2F;&#x2F;堆的容量 T *data;&#x2F;&#x2F;存放数据的线性结构 void shiftDown(int k) &#123; while(2 * k &lt;&#x3D; cnt) &#123; int j &#x3D; 2 * k;&#x2F;&#x2F;j此时为左孩子节点的索引 &#x2F;&#x2F;有孩子节点存在 并且有孩子节点比左孩子节点还小 j++ if(j + 1 &lt;&#x3D; cnt &amp;&amp; data[j+1] &lt; data[j]) j ++; if(data[k] &lt;&#x3D; data[j]) break;&#x2F;&#x2F;如果根节点比min(data[j], data[j+1])更小，break掉 swap(a[k], a[j]); k &#x3D; j; &#125; &#125; void shiftUp(int k) &#123; while(k&gt;1 &amp;&amp; data[k&#x2F;2] &gt; data[k]) &#123; swap(data[k&#x2F;2], data[k]); jk &#x2F;&#x3D; 2; &#125; &#125;public: Heap(int capacity) &#123; this-&gt;cnt &#x3D; 0;&#x2F;&#x2F;初始堆中没有节点，初始化为0 this-&gt;capacity &#x3D; capacity; &#x2F;&#x2F;注意这里很重要， data中下标为0位置并不使用，因此需要多开辟一个存储空间 data &#x3D; new T[capacity + 1]; &#125; ~Heap() &#123;delete [] data;&#125; void insert(int x) &#123; assert(cnt + 1 &lt;&#x3D; capacity); data[cnt + 1] &#x3D; x; shiftUp(cnt + 1); cnt ++; &#125; T extractMin() &#123; assert(cnt &gt; 0); T res &#x3D; data[1]; swap(data[1], data[cnt]); cnt --; shiftDown(1); return res; &#125;&#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构：插入类型排序的总结（考研）","slug":"数据结构：插入类型排序的总结（考研）","date":"2019-08-17T13:26:18.000Z","updated":"2020-11-29T19:35:21.807Z","comments":true,"path":"2019/08/17/数据结构：插入类型排序的总结（考研）/","link":"","permalink":"http://example.com/2019/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8F%92%E5%85%A5%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"插入类排序包括直接插入排序，折半插入排序以及希尔排序。插入排序默认第一个位置（下标为0）的元素是有序的，需要将在[2…..n-1]这个区间中剩下的n-1个元素在有序的位置区间寻找一个合适的位置进行插入。 （1）直接插入排序 例如：初始状态闭区间[0…i-1]这个区间中的元素是有序的，排序的开始需要在[0…i-1]这个闭区间中寻找索引为i的元素合适的插入位置。 12345int v &#x3D; a[i];&#x2F;&#x2F;记录当前需要被排序元素的值，因为之后可能会被覆盖&#x2F;&#x2F;因为比较的过程可能有元素的移动 需要处理边界 j&gt;&#x3D;1 a[j] &#x3D; a[j-1]此时就不会发生越界的错误for(int j&#x3D;i; j&gt;&#x3D;1 &amp;&amp; a[j-1] &gt; v; --j) a[j] &#x3D; a[j-1];&#x2F;&#x2F;此时，索引j所指向的位置就是v合适的插入位置a[j] &#x3D; v; 12345678void insertSort(int *a, int n) &#123; for(int i&#x3D;1; i&lt;n; ++i) &#123; int j; int v &#x3D; a[i]; for(j&#x3D;i; j&gt;&#x3D;1 &amp;&amp; a[j-1]&gt;v; --j) a[j] &#x3D; a[j-1]; a[j] &#x3D; v; &#125;&#125; （2）折半插入排序 折半插入排序利用了二分查找的特性，（支持随机访问和顺序表有序），降低查找位置的时间复杂度，因为已排序好的部分已经有序。 123456789101112131415void binInsertSort(int *a, int n) &#123; for(int i&#x3D;1; i&lt;n; ++i) &#123; &#x2F;&#x2F;二分的两个边界 ，注意有序的右边界的索引是i-1 待排序元素的索引是i int left&#x3D;0, righjt&#x3D;i-1; int v &#x3D; a[i];&#x2F;&#x2F;记录待排序元素 while(left &lt;&#x3D; right) &#123; int mid &#x3D; (right - left) &#x2F; 2 + left; if(v &lt;&#x3D; a[mid]) right &#x3D; mid - 1; else left &#x3D; mid + 1; &#125; &#x2F;&#x2F;此时已经找到合适的插入位置， 移动元素 for(int j&#x3D;i; j&gt;&#x3D;left+1; --j) a[j] &#x3D; a[j-1] a[j] &#x3D; v; &#125;&#125; （3）希尔排序 希尔排序本质上还是插入排序，但是希尔排序按照增量分组多次进行插入排序，提高了局部的有序性。当增量d==1时，此时只需要在进行一次插入排序即可完成排序。一般选取希尔排序的增量d=3。希尔排序的时间复杂约为O(n^1.3)，但是希尔排序不是一种稳定的排序方法。 1234567891011121314151617void shellSort(int *a, int n) &#123; &#x2F;&#x2F;根据待排序数组的大小获取初始的增量d int d &#x3D; 1; while(d &lt; n&#x2F;3) d &#x3D; d*3 + 1; &#x2F;&#x2F;可循环的条件d&gt;&#x3D;1 当d&#x3D;&#x3D;1的时候，此时进行的是直接插入排序 while(d &gt;&#x3D; 1) &#123; &#x2F;&#x2F;默认a[0]已经有序 for(int i&#x3D;d; i&lt;n; ++i) &#123; int j; int v &#x3D; a[i]; for(j&#x3D;i; j&gt;&#x3D;h &amp;&amp; a[j-h]&gt;v; j-&#x3D;h) a[j] &#x3D; a[j-h]; a[j] &#x3D; v; &#125; d &#x2F;&#x3D; 3; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"使用数组模拟队列、循环队列和栈","slug":"使用数组模拟队列、循环队列和栈","date":"2019-08-12T09:23:49.000Z","updated":"2020-11-29T19:35:21.831Z","comments":true,"path":"2019/08/12/使用数组模拟队列、循环队列和栈/","link":"","permalink":"http://example.com/2019/08/12/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/","excerpt":"","text":"在一些考试题中以及笔试面试的过程中，在需要使用stack和queue的时候，可能被要求不能使用STL中相关的库函数，也就意味着我们需要使用纯C进行编程。但是如果在考试中或者笔试面试中，为了要使用栈和队列，而去写一个完整的数据结构是比较大费周章，况且在时间上也不一定允许，因此，使用数组来模拟栈和队列的实现是一种明智的选择，原因有两个：一、使用数组模拟队列和栈可以简化编程的复杂度，节省时间，比如在dfs()和bfs()可以花更多的时间来思考这两个逻辑的实现。二、使用数组模拟的栈和队列在效率上比标准库的容器类高很多,可以使得程序执行的速度更快。 1.数组模拟栈的实现数组模拟栈的的实现，在栈顶指针的处理上，一般有两种处理方式top=-1,和top=0,也就意味着在这两种情况下对栈的操作是不相同的。(1)top=-1 1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAX 100 &#x2F;&#x2F;定义栈的大小int s[MAX];int top &#x3D; -1;&#x2F;&#x2F;初始的栈顶指针为-1void push(int x) &#123; if(isFull()) return; else s[++ top] &#x3D; x;&#125;void pop() &#123; if(isEmpty()) return; else top --;&#125;int top() &#123; if(isEmpty()) return -1; else return s[top];&#125;bool isEmpty() &#123;return top &#x3D;&#x3D; -1;&#125;bool isFull() &#123;return top &#x3D;&#x3D; MAX-1;&#125; (1)top=0 1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAX 100 &#x2F;&#x2F;定义栈的大小int s[MAX];int top &#x3D; 0;&#x2F;&#x2F;初始的栈顶指针为0void push(int x) &#123; if(isFull()) return; else s[top ++] &#x3D; x;&#125;void pop() &#123; if(isEmpty()) return; else top --;&#125;int top() &#123; if(isEmpty()) return -1; else return s[top-1];&#125;bool isEmpty() &#123;return top &#x3D;&#x3D; 0;&#125;bool isFull() &#123;return top &#x3D;&#x3D; MAX;&#125; 至于选择哪种来使用，看大家的习惯。 2.数组模拟栈的实现 12345678910111213141516#include &lt;stdio.h&gt;#define N 100int q[N];int f&#x3D;-1, r&#x3D;-1;&#x2F;&#x2F;初始定义队头和队尾指针均为-1void push(int x) &#123; if(isFull()) return; q[++ r] &#x3D; x;&#125;int front() &#123; if(isEmpty()) return -1; return q[++ f];&#125;bool isEmpty() &#123;return f&#x3D;&#x3D;r;&#125;bool isFull() &#123;return r&#x3D;&#x3D;N-1;&#125; 3.数组模拟循环队列的实现 循环队列本质上是为了解决队列假溢出的问题，假溢出可能会造成大量的存储空间的浪费。循环队列虽然能够解决上述的问题，但是在判断队列空和队列满的两种状态上需要处理的比较好，非则也会出现不知队列是空还是满。目前比较常用的方式是：牺牲一个位置存储空间来判别队列的两种状态。 1234567891011121314151617181920#include &lt;stdio.h&gt;#define N 6int q[N];int hh&#x3D;0, tt&#x3D;0void push(int x) &#123; if(isFull()) return; q[tt ++] &#x3D; x; tt &#x3D; (tt + 1) % N;&#125;int front() &#123; if(isEmpty()) return -1; int res &#x3D; q[hh]; hh &#x3D; (hh + 1) % N; return res;&#125;bool isEmpty() &#123;return hh&#x3D;&#x3D;tt;&#125;bool isFull() &#123;return (tt + 1) % N &#x3D;&#x3D; hh;&#125; int length() &#123;return (tt - hh + N) % N;&#125;","categories":[{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构：树相关的一些知识点（考研）","slug":"数据结构：树相关的一些知识点（考研）","date":"2019-07-20T16:00:26.000Z","updated":"2020-11-29T19:35:21.839Z","comments":true,"path":"2019/07/21/数据结构：树相关的一些知识点（考研）/","link":"","permalink":"http://example.com/2019/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E8%80%83%E7%A0%94%EF%BC%89/","excerpt":"","text":"1.叶子节点和度为二节点个数之间的关系从两方面考虑。（1）节点个数：在二叉树中，由度为0，1，2三种节点组成，因此其总的节点个数:n=n0+n1+n2。（2）从分支考虑，n个节点中除了根节点没有前驱节点，其他节点有且仅有一个前驱节点。因此构成了n-1条边，这n-1条边是由度为0，1，2的节点扩散出来的，同时它们的扩散的边也为0，1，2，因此可以得到第二个方程:n-1 = 0*n0 + 1*n1 + 2*n2 2.树中节点总的个数等于所有节点的度加1。可以这样理解，在树中，除了根节点之外，其余节点(n-1个)有且仅有一个前驱节点，也构成了n-1条边。考察树中每一个节点的度数之和，正是这n-1条边。因此n-1=树中所有节点的度之和，立即推n=所有节点度之和+1。 3.度为m的树中在第k层最大节点个数为m^(k-1) 4.高度为h的m叉树至多有(m^h-1)/(m-1)个节点。换句话说，就是高度为h的m叉满树节点个数为多少。其实就是求解等比数列的前n项和1, m, m^2, m^3,...,m^h-1 5.具有n个节点的m叉树的最小高度为：ceil(logm[n*(m-1) + 1])，最大高度为n-m+1。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"LeetCode 66.加一（C++ 大数相加）","slug":"LeetCode 66.加一（C++ 大数相加）","date":"2019-06-06T00:08:14.000Z","updated":"2020-11-29T19:35:21.839Z","comments":true,"path":"2019/06/06/LeetCode 66.加一（C++ 大数相加）/","link":"","permalink":"http://example.com/2019/06/06/LeetCode%2066.%E5%8A%A0%E4%B8%80%EF%BC%88C++%20%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%89/","excerpt":"","text":"思路：1.由于题目未给定数字的长度，因此需要字符串模拟来表示大整数，用C/C++基本类型是表示不出来的，我试过long long过了大概50个样例，就溢出了。2.模拟大数相加，在本题中，就是一个大数加1。AC代码（C++）： 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits)&#123; string s,t&#x3D;&quot;1&quot;; for(int i&#x3D;0; i&lt;digits.size(); ++i)&#123; s +&#x3D; to_string(digits[i]); &#125; reverse(s.begin(), s.end()); for(int i&#x3D;0; i&lt;s.length()-1; ++i)&#123; t +&#x3D; &quot;0&quot;; &#125; &#x2F;&#x2F;大数相加 int c &#x3D; 0; string r; for(int i&#x3D;0; i&lt;s.length() || i&lt;t.length(); ++i)&#123; int temp &#x3D; s[i]-&#39;0&#39; + t[i] - &#39;0&#39; + c; r +&#x3D; to_string(temp % 10); c &#x3D; temp &#x2F; 10; &#125; if(c!&#x3D;0) r +&#x3D; to_string(c); vector&lt;int&gt; res; for(int i&#x3D;r.length()-1; i&gt;&#x3D;0; --i)&#123; res.push_back(r[i]-&#39;0&#39;); &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 125.验证回文串（C++）","slug":"LeetCode 125.验证回文串（C++）","date":"2019-06-05T11:10:03.000Z","updated":"2020-11-29T19:35:21.811Z","comments":true,"path":"2019/06/05/LeetCode 125.验证回文串（C++）/","link":"","permalink":"http://example.com/2019/06/05/LeetCode%20125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88C++%EF%BC%89/","excerpt":"","text":"AC代码（C++）：思路：1.去除不合法的字符，题目中只有大小写字母和数字为合法的字符。2.将大写统一处理为小写，方便处理。3.进行回文判断。 123456789101112131415161718192021class Solution &#123;public: bool isPalindrome(string s) &#123; string t; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(isalpha(s[i]) || isdigit(s[i])) t +&#x3D; s[i]; &#125; for(int i&#x3D;0; i&lt;t.length(); ++i)&#123; if(isupper(t[i])) t[i] ^&#x3D; 32; &#125; for(int i&#x3D;0; i&lt;t.length()&#x2F;2; ++i)&#123; if(t[i]!&#x3D;t[t.length()-1-i]) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 38.报数","slug":"LeetCode 38.报数","date":"2019-06-04T11:13:00.000Z","updated":"2020-11-29T19:35:21.839Z","comments":true,"path":"2019/06/04/LeetCode 38.报数/","link":"","permalink":"http://example.com/2019/06/04/LeetCode%2038.%E6%8A%A5%E6%95%B0/","excerpt":"","text":"AC代码（C++）： 12345678910111213141516171819202122232425262728class Solution &#123;public: string countAndSay(int n) &#123; string a&#x3D;&quot;1&quot;; while(-- n)&#123; string ans; int cnt &#x3D; 0; char c &#x3D; a[0]; for(int i&#x3D;0; i&lt;a.length(); ++i)&#123; if(a[i]&#x3D;&#x3D;c) cnt ++; else&#123; ans +&#x3D; cnt+&#39;0&#39;; ans +&#x3D; c; c &#x3D; a[i]; cnt &#x3D; 1; &#125; &#125; if(cnt &gt; 0)&#123; ans +&#x3D; cnt+&#39;0&#39;; ans +&#x3D; c; &#125; a &#x3D; ans; &#125; return a; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 70.爬楼梯","slug":"LeetCode 70.爬楼梯","date":"2019-06-04T10:23:06.000Z","updated":"2020-11-29T19:35:21.835Z","comments":true,"path":"2019/06/04/LeetCode 70.爬楼梯/","link":"","permalink":"http://example.com/2019/06/04/LeetCode%2070.%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"","text":"AC代码（C++）：简单的一维dp，可以用递推的方式或记忆化搜索的方式。本题本质是求fibonacci数列的第n项： 12345678910class Solution &#123;public: int climbStairs(int n) &#123; int dp[n+1]; dp[0]&#x3D;dp[1]&#x3D;1; for(int i&#x3D;2; i&lt;&#x3D;n; ++i) dp[i] &#x3D; dp[i-1]+dp[i-2]; return dp[n]; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 58.最后一个单词的长度","slug":"LeetCode 58.最后一个单词的长度","date":"2019-06-04T06:49:45.000Z","updated":"2020-11-29T19:35:21.855Z","comments":true,"path":"2019/06/04/LeetCode 58.最后一个单词的长度/","link":"","permalink":"http://example.com/2019/06/04/LeetCode%2058.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"","text":"AC代码（C++）： 12345678910111213141516171819class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(!s.c_str()) return 0; &#x2F;&#x2F;去除末尾的空格 int i&#x3D;s.length()-1; while(s[i]&#x3D;&#x3D;&#39; &#39; &amp;&amp; i&gt;&#x3D;0) i --; &#x2F;&#x2F;如果全是空格，提前退出， 这行代码也可以不写 &#x2F;*if(i&lt;0) return 0;*&#x2F; &#x2F;&#x2F;计算最后一个单词的长度 int cnt &#x3D; 0; while(s[i]!&#x3D;&#39; &#39; &amp;&amp; i&gt;&#x3D;0) cnt ++, i--; return cnt; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 9.回文数（C++）","slug":"LeetCode 9.回文数（C++）","date":"2019-06-03T14:24:00.000Z","updated":"2020-11-29T19:35:22.155Z","comments":true,"path":"2019/06/03/LeetCode 9.回文数（C++）/","link":"","permalink":"http://example.com/2019/06/03/LeetCode%209.%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88C++%EF%BC%89/","excerpt":"","text":"AC代码（C++）： 1234567891011class Solution &#123;public: bool isPalindrome(int x) &#123; string s &#x3D; to_string(x); for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(s[i]!&#x3D;s[s.length()-1-i]) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"LeetCode 7.整数反转（C++）","slug":"LeetCode 7.整数反转（C++）","date":"2019-06-03T11:23:01.000Z","updated":"2020-11-29T19:35:22.175Z","comments":true,"path":"2019/06/03/LeetCode 7.整数反转（C++）/","link":"","permalink":"http://example.com/2019/06/03/LeetCode%207.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88C++%EF%BC%89/","excerpt":"","text":"AC代码（C++）： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: &#x2F;&#x2F;将x转化为一个对应的字符串并且去除前导0 string res(int x)&#123; string s &#x3D; to_string(x), ans; &#x2F;&#x2F;反转字符串 for(int i&#x3D;0; i&lt;s.length()&#x2F;2; ++i)&#123; swap(s[i], s[s.length()-1-i]); &#125; &#x2F;&#x2F;去除前导0 int pos &#x3D; 0; while(s[pos]&#x3D;&#x3D;&#39;0&#39;) pos ++; &#x2F;&#x2F;获取答案 for(int i&#x3D;pos; i&lt;s.length(); ++i) ans +&#x3D; s[i]; return ans; &#125; int reverse(int x)&#123; &#x2F;&#x2F;考虑整型溢出的问题 将x转换为long long int long long int t &#x3D; x; if(t&#x3D;&#x3D;0) return 0; string s; if(t&lt;0)&#123; s +&#x3D; &quot;-&quot;; t &#x3D; -t; &#125; s +&#x3D; res(t); long long int res &#x3D; stoll(s); &#x2F;&#x2F;INT_MAX 和 INT_MIN是两个C库函数 #include &lt;climits&gt; &#x2F;&#x2F;表示整型的最大值和最小值 if(res &lt; INT_MIN || res &gt; INT_MAX) return 0; else return stoi(s); &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"PAT（甲级）1005.Spell It Right（20）","slug":"PAT（甲级）1005.Spell It Right（20）","date":"2019-05-19T14:50:34.000Z","updated":"2020-11-29T19:35:22.147Z","comments":true,"path":"2019/05/19/PAT（甲级）1005.Spell It Right（20）/","link":"","permalink":"http://example.com/2019/05/19/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891005.Spell%20It%20Right%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1002.A+B for Polynomials (25)Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. 输入格式：Each input file contains one test case. Each case occupies one line which contains an N (≤10^100​​). 输出格式：For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. 输入样例： 112345 输出样例： 1one five 题目分析:首先注意题目的数据范围我用红色高亮了，N (≤10^100​​)，而在C++中最大的整数是unsigned long long int是 2^64-1(18446744073709551615‬)显然是表示不了这么大（10^100）的数字的，对于大整数此时应该选择字符串或字符数组表示。对于C/C++中基本数据的最大最小值，大家可以使用#include&lt;climits&gt;这个函数库。AC代码： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namesapce std;map&lt;int, string&gt; mp &#x3D; &#123;&#123;0,&quot;zero&quot;&#125;,&#123;1,&quot;one&quot;&#125;,&#123;2,&quot;two&quot;&#125;,&#123;3,&quot;three&quot;&#125;,&#123;4,&quot;four&quot;&#125;,&#123;5,&quot;five&quot;&#125;,&#123;6,&quot;six&quot;&#125;,&#123;7,&quot;seven&quot;&#125;,&#123;8,&quot;eight&quot;&#125;,&#123;9,&quot;nine&quot;&#125;&#125;;int main()&#123; string s; cin &gt;&gt; s; int sum &#x3D; 0; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; sum +&#x3D; s[i]-&#39;0&#39;; &#125; s &#x3D; to_string(sum); for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; printf(&quot;%s&quot;,mp[s[i]-&#39;0&#39;].c_str()); if(i!&#x3D;s.length()-1) printf(&quot; &quot;); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1004.Counting Leaves（30）","slug":"PAT（甲级）1004.Counting Leaves（30）","date":"2019-05-19T14:21:45.000Z","updated":"2020-11-29T19:35:22.139Z","comments":true,"path":"2019/05/19/PAT（甲级）1004.Counting Leaves（30）/","link":"","permalink":"http://example.com/2019/05/19/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891004.Counting%20Leaves%EF%BC%8830%EF%BC%89/","excerpt":"","text":"PAT 1004.Counting Leaves（30）A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. 输入格式：Each input file contains one test case. Each case starts with a line containing 0&lt;N&lt;100, the number of nodes in a tree, and M (&lt;N), the number of non-leaf nodes. Then M lines follow, each in the format:ID K ID[1] ID[2] ... ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID&#39;s of its children. For the sake of simplicity, let us fix the root ID to be 01.The input ends with N being 0. That case must NOT be processed. 输出格式：For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1leaf node. Then we should output 0 1 in a line. 输入样例： 122 101 1 02 输出样例： 10 1 题目分析：输出多叉树中每层中叶子节点的数目。可以使用dfs或bfs。由于题目中提示了节点编号，可以使用静态树结构，使用邻接表的方式存储每个节点的孩子节点的编号。其实也是一种hash的思想，hash[parentIndex] = {}，只不过其对应的是一个集合。 使用bfs时，当前队列中的元素即为当前层上的所有节点，只需要枚举每个节点是否有孩子，如果有就将其所有孩子都继入队列，如果没有在则当前层的叶子节点个数+1。 AC代码（bfs）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; tree[100];&#x2F;&#x2F;邻接表存储树int floor[100];&#x2F;&#x2F;每层叶子节点的个数int index&#x3D;0;&#x2F;&#x2F;根节点在第0层void bfs(int root)&#123; queue&lt;int&gt; q; q.push()； while(!q.empty())&#123; int size &#x3D; q.size(); &#x2F;&#x2F;注意不能写成for(int i&#x3D;0; i&lt;q.size(); ++i)这样q.size()是会改变的 &#x2F;&#x2F;因为每次枚举一个队首元素 都会出队 所以q.size() -&#x3D; 1; for(int i&#x3D;0; i&lt;size; ++i)&#123; int front &#x3D; q.front();q.pop(); if(!tree[front].size())&#123; &#x2F;&#x2F;没有孩子节点 说明是叶子节点 floor[index] ++; &#125; else&#123; &#x2F;&#x2F;不是叶子节点 将其所有的孩子节点入队 for(int j&#x3D;0; j&lt;tree[front].size(); ++j)&#123; q.push(tree[front][j]); &#125; &#125; &#125; index ++;&#x2F;&#x2F;下一层 &#125;&#125;int main()&#123; int n, m, k, p, c; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d %d&quot;, &amp;p, &amp;k); while(k --)&#123; scanf(&quot;%d&quot;, &amp;c); tree[p].push_back(c); &#125; &#125; bfs(1); for(int i&#x3D;0; i&lt;index; ++i)&#123; printf(&quot;%d&quot;, floor[i]); if(i!&#x3D;index-1)printf(&quot; &quot;); &#125; return 0;&#125; AC代码(dfs)： 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; tree[100];int floor[100];int maxDepth&#x3D;-1;&#x2F;&#x2F;这个变量用于确定该树有几层&#x2F;&#x2F;dfs需要传入的参数 当前节点的索引 当前节点所在的深度void dfs(int p, int depth)&#123; &#x2F;&#x2F;递归出口 &#x2F;&#x2F;没有孩子节点 说明找到一个叶子节点 if(!tree[p].size())&#123; floor[depth] ++;&#x2F;&#x2F;当前层叶子节点个数+1 &#x2F;&#x2F;更新最大的深度 maxDepth &#x3D; max(depth, maxDepth); return ; &#125; else&#123; &#x2F;&#x2F;不是叶子节点，枚举其所有孩子节点是否为叶子节点 for(int i&#x3D;0; i&lt;tree[p].size(); ++i) dfs(tree[p][i], depth+1); &#x2F;&#x2F;孩子节点的深度比当前节点的深度大1 &#125;&#125;int main()&#123; int n, m, k, p, c; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d %d&quot;, &amp;p, &amp;k); while(k --)&#123; scanf(&quot;%d&quot;, &amp;c); tree[p].push_back(c); &#125; &#125; dfs(1, 0);&#x2F;&#x2F;根节点的索引为1 根节点所在层为0 for(int i&#x3D;0; i&lt;&#x3D;maxDepth; ++i)&#123; printf(&quot;%d&quot;, floor[i]); if(i!&#x3D;maxDepth)printf(&quot; &quot;); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1002.A+B for Polynomials (25)","slug":"PAT（甲级）1002.A+B for Polynomials (25)","date":"2019-05-19T12:24:01.000Z","updated":"2020-11-29T19:35:22.139Z","comments":true,"path":"2019/05/19/PAT（甲级）1002.A+B for Polynomials (25)/","link":"","permalink":"http://example.com/2019/05/19/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891002.A+B%20for%20Polynomials%20(25)/","excerpt":"","text":"PAT 1002.A+B for Polynomials (25)This time, you are supposed to find A+B where A and B are two polynomials. 输入格式：Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:K N1​​ a​N1 ​N​2 a​N​2... NK a​N​K​​​​where K is the number of nonzero terms in the polynomial,N​i anda​N​i(i=1,2,⋯,K) are the exponents(指数) and coefficients(系数),respectively. It is given that 1≤K≤10，0≤N​K​​ &lt;⋯&lt;N2 &lt;N1​​ ≤1000.输出格式：For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. 输入样例： 122 1 2.4 0 3.22 2 1.5 1 0.5 输出样例： 13 2 1.5 1 2.9 0 3.2 题目分析：计算两个多项表达式的和，输出格式与输入格式相同。如样例： 123452 1 2.4 0 3.2 两项 y1&#x3D;2.4x^1 + 3.2x^02 2 1.5 1 0.5 两项 y2&#x3D;1.5x^2 + 0.5x^1y3 &#x3D; y1+y2 1.5x^2+2.9x^1+3.2x^0y3有三项输出：3 2 1.5 1 2.9 0 3.2 系数的范围：[0,1000]即1001项，可以使用数组hash,hash[exp]=coeffient, 下表exp中存储的是其对应的系数，如3.2x^100, hash[100]=3.2,所以开辟两个大小为1001的hash数组分别存储多项表达式y1和y2的系数的指数哈希数组进行预处理即可，之后分别相加系数不为0对应的hash项即可，同时统计不为0的个数。注意：输出中末行不能有空格。 AC代码： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;double a[1001], b[1001];int main()&#123; int exp, k, cnt&#x3D;0; scanf(&quot;%d&quot;, &amp;k); while(k --)&#123; scanf(&quot;%d&quot;, &amp;exp); scanf(&quot;%lf&quot;, &amp;a[exp]); &#125; scanf(&quot;%d&quot;, &amp;k); while(k --)&#123; scanf(&quot;%d&quot;, &amp;exp); scanf(&quot;%lf&quot;, &amp;b[exp]); &#125; for(int i&#x3D;0; i&lt;&#x3D;1000; ++i)&#123; a[i] +&#x3D; b[i]; if(a[i]) cnt ++; &#125; printf(&quot;%d&quot;,cnt); for(int i&#x3D;1000; i&gt;&#x3D;0; --i)&#123; if(a[i])&#123; printf(&quot; %d %.1lf&quot;, i,a[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1001. A+B Format (20)","slug":"PAT（甲级）1001. A+B Format (20)","date":"2019-05-19T11:19:08.000Z","updated":"2020-11-29T19:35:22.155Z","comments":true,"path":"2019/05/19/PAT（甲级）1001. A+B Format (20)/","link":"","permalink":"http://example.com/2019/05/19/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891001.%20A+B%20Format%20(20)/","excerpt":"","text":"PAT 1001. A+B Format (20)Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). 输入格式：Each input file contains one test case. Each case contains a pair of integers a and b where −10​^6 ≤ a , b ≤ 10​^6​​.The numbers are separated by a space. 输出格式：For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. 输入样例： 1-1000000 9 输出样例： 1-999,991 题目分析：按照指定的格式输出a+b的和，每三个数字一组，中间用逗号隔开，注意：不能输出前导0。 AC代码1（非递归）：算是一种投机的方法，题目中给出的数据范围是[10^-6, 10^6]意味着abs(sum(a+b))这个最大值是2*10^6=2 000 000,也就是说在这个题目中sum最多分三组。所以直接根据规律输出即可 1234567891011121314151617&#x2F;&#x2F;c&#x2F;1000000 取得第一组的三位&#x2F;&#x2F;(c&#x2F;1000)去掉低三位 (c&#x2F;1000)%1000 获得去掉第三位中所得到的数字的低三位&#x2F;&#x2F;c%1000 获取c的低三位&#x2F;&#x2F;如1234567 分成三组为 1，234，567 &#x2F;&#x2F;c&#x2F;1000000 得到1&#x2F;&#x2F;c&#x2F;1000即为 1234 （c&#x2F;1000）%1000即为234&#x2F;&#x2F;c%1000直接得到最低的三位int main()&#123; int a &#x3D; 1234567; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;a&#x2F;1000000 &#x3D; &quot; &lt;&lt; a&#x2F;1000000 &lt;&lt; endl; cout &lt;&lt; &quot;a&#x2F;1000 &#x3D; &quot; &lt;&lt; a&#x2F;1000 &lt;&lt; endl; cout &lt;&lt; &quot;(a&#x2F;1000)%1000 &#x3D; &quot; &lt;&lt; (a&#x2F;1000)%1000 &lt;&lt; endl; cout &lt;&lt; &quot;a%1000 &#x3D; &quot; &lt;&lt; a%1000 &lt;&lt; endl; return 0;&#125; 执行结果： 123456789101112131415161718#include &lt;cstdio&gt;int main()&#123; int a, b, c; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); c &#x3D; a+b; &#x2F;&#x2F;统一将a+b的和处理为正数，方便逻辑的判断 if(c &lt; 0)&#123; printf(&quot;-&quot;); c &#x3D; -c; &#125; if(c&gt;&#x3D;1000000)&#x2F;&#x2F;分三组 printf(&quot;%d,%03d,%03d&quot;, c&#x2F;1000000, (c&#x2F;1000)%1000, c%1000); else if(c&gt;&#x3D;1000)&#x2F;&#x2F;分两组 printf(&quot;%d,%03d&quot;, c&#x2F;1000, c%1000); else&#x2F;&#x2F;分一组 printf(&quot;%d&quot;, c);&#125; AC代码2（递归）： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;void dfs(int n)&#123; &#x2F;&#x2F;如果n&lt;1000则说明位数小于等于3位 [0,999]直接输出即可 &#x2F;&#x2F;n&lt;1000只有两种可能：（1）这个数字小于1000 （2）n是某个数字的高三位 &#x2F;&#x2F;注意不能输出前导0 如&quot;032&quot;, 这样是错误的 if(n &lt; 1000)&#123; printf(&quot;%d&quot;, n); return; &#125; else&#123; &#x2F;&#x2F;如果一个数字大于三位 [1000, infinite) &#x2F;&#x2F;分成两个部分 高三位和其余位置 &#x2F;&#x2F;高三位 n&#x2F;1000 最后三位 n%1000 dfs(n &#x2F; 1000);&#x2F;&#x2F;输出高三位 &#x2F;&#x2F;所有的高三位都输出了，回溯回来 输出低三位即可 printf(&quot;%3d&quot;, n % 1000);&#x2F;&#x2F;注意此时的输出格式 &quot;%03d&quot;, 不足三位需要用0补足 &#125;&#125;int main()&#123; int a, b, c; c &#x3D; a+b; if(c&lt;0)&#123; printf(&quot;-&quot;); c &#x3D; -c; &#125; dfs(c); return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1030.Travel Plan（30）","slug":"PAT（甲级）1030.Travel Plan（30）","date":"2019-04-10T12:17:58.000Z","updated":"2020-11-29T19:35:22.155Z","comments":true,"path":"2019/04/10/PAT（甲级）1030.Travel Plan（30）/","link":"","permalink":"http://example.com/2019/04/10/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891030.Travel%20Plan%EF%BC%8830%EF%BC%89/","excerpt":"","text":"PAT 1030.Travel Plan（30）A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. 输入格式：Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:City1 City2 Distance Costwhere the numbers are all integers no more than 500, and are separated by a space. 输出格式：For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. 输入样例： 1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 输出样例： 10 2 3 3 40 题目分析：dijkstra+dfs模板题。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int maxv &#x3D; 510;const int inf &#x3D; 0x3fffffff;struct Node&#123; int v,dis; Node(int v, int dis)&#123; this-&gt;v &#x3D; v; this-&gt;dis &#x3D; dis; &#125;&#125;;bool visited[maxv];int weight[maxv][maxv];int cost[maxv];int d[maxv];int pre[maxv];vector&lt;Node&gt; G[maxv];int n,m,st,ed;void dijkstra(int s)&#123; for(int i&#x3D;0; i&lt;maxv; ++i)&#123; pre[i] &#x3D; i; cost[i] &#x3D; 0; visited[i] &#x3D; false; d[i] &#x3D; inf; cost[i] &#x3D; inf; &#125; d[s] &#x3D; 0; cost[s] &#x3D; 0; for(int i&#x3D;0; i&lt;n; ++i)&#123; int u&#x3D;-1,MIN&#x3D;inf; for(int j&#x3D;0; j&lt;n; ++j)&#123; if(visited[j]&#x3D;&#x3D;false &amp;&amp; d[j]&lt;MIN)&#123; MIN &#x3D; d[j]; u &#x3D; j; &#125; &#125; if(u&#x3D;&#x3D;-1)return ; visited[u] &#x3D; true; for(int j&#x3D;0; j&lt;G[u].size(); ++j)&#123; int v &#x3D; G[u][j].v; if(visited[v]&#x3D;&#x3D;false &amp;&amp; G[u][j].dis+d[u]&lt;d[v])&#123; d[v] &#x3D; G[u][j].dis + d[u]; cost[v] &#x3D; weight[u][v] + cost[u]; pre[v] &#x3D; u; &#125; else if(visited[v]&#x3D;&#x3D;false &amp;&amp; G[u][j].dis+d[u]&#x3D;&#x3D;d[v])&#123; if(cost[u] + weight[u][v] &lt; cost[v])&#123; cost[v] &#x3D; weight[u][v] + cost[u]; pre[v] &#x3D; u; &#125; &#125; &#125; &#125;&#125;void dfs(int v)&#123; if(v&#x3D;&#x3D;st)&#123; printf(&quot;%d &quot;,v); return; &#125; dfs(pre[v]); printf(&quot;%d &quot;,v);&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed); int u,v,wt,c; for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;wt,&amp;c); G[u].push_back(Node(v,wt)); G[v].push_back(Node(u,wt)); weight[u][v] &#x3D; c; weight[v][u] &#x3D; c; &#125; dijkstra(st); dfs(ed); printf(&quot;%d %d\\n&quot;, d[ed], cost[ed]); return 0;&#125;","categories":[{"name":"PAT甲级题解 图论","slug":"PAT甲级题解-图论","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3-%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"PAT（甲级）1003.Emergency（25）","slug":"PAT（甲级）1003.Emergency（25）","date":"2019-04-10T09:53:17.000Z","updated":"2020-11-29T19:35:22.155Z","comments":true,"path":"2019/04/10/PAT（甲级）1003.Emergency（25）/","link":"","permalink":"http://example.com/2019/04/10/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891003.Emergency%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1003.Emergency（25）As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. 输入格式：Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C​1​​ and C​2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c​1​​ , c​2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C​1 to C​2. 输出格式：For each test case, print in one line two numbers: the number of different shortest paths between C1 and C​2​​ , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. 输入样例： 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 输出样例： 12Case #1:2 4 题目分析：求解单源最短路径的条数，以及在某条路径上的最大点权之和。本题的图是无向图，如果代码里写成了有向图会出现测试点错误。代码参考晴神的模板。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxv &#x3D; 510;const int inf &#x3D; 0x3fffffff;int weight[maxv];int d[maxv],num[maxv],w[maxv];bool visited[maxv] &#x3D; &#123;false&#125;;int n, m;struct Node&#123; int v, dis; Node(int v, int dis)&#123; this-&gt;v &#x3D; v; this-&gt;dis &#x3D; dis; &#125;&#125;;vector&lt;Node&gt; G[maxv];void dijkstra(int s)&#123; for(int i&#x3D;0; i&lt;maxv; ++i)&#123; d[i] &#x3D; inf; w[i] &#x3D; 0; num[i] &#x3D; 0; &#125; d[s] &#x3D; 0; w[s] &#x3D; weight[s]; num[s] &#x3D; 1; for(int i&#x3D;0; i&lt;n; ++i)&#123; int u&#x3D;-1,MIN&#x3D;inf; for(int j&#x3D;0; j&lt;n; ++j)&#123; if(visited[j]&#x3D;&#x3D;false &amp;&amp; d[j]&lt;MIN)&#123; MIN &#x3D; d[j]; u &#x3D; j; &#125; &#125; if(u&#x3D;&#x3D;-1)return; visited[u] &#x3D; true; for(int j&#x3D;0; j&lt;G[u].size(); ++j)&#123; int v &#x3D; G[u][j].v; if(visited[v]&#x3D;&#x3D;false &amp;&amp; d[u] + G[u][j].dis &lt; d[v])&#123; d[v] &#x3D; d[u]+G[u][j].dis; w[v] &#x3D; w[u] + weight[v]; num[v] &#x3D; num[u]; &#125; else if(visited[v]&#x3D;&#x3D;false &amp;&amp; d[u]+G[u][j].dis&#x3D;&#x3D;d[v])&#123; if(w[u]+weight[v] &gt; w[v]) w[v] &#x3D; w[u] + weight[v]; num[v] +&#x3D; num[u]; &#125; &#125; &#125;&#125;int main()&#123; int st,ed;&#x2F;&#x2F;源点和汇点 scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;weight[i]); &#125; int u,v,we; for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;we); G[u].push_back(Node(v,we)); G[v].push_back(Node(u,we)); &#125; dijkstra(st); printf(&quot;%d %d\\n&quot;,num[ed], w[ed]); return 0;&#125;","categories":[{"name":"PAT甲级题解 图论","slug":"PAT甲级题解-图论","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3-%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"PAT（甲级）1055.The World's Richest（25）","slug":"PAT（甲级）1055.The World's Richest（25）","date":"2019-04-08T15:21:26.000Z","updated":"2020-11-29T19:35:22.175Z","comments":true,"path":"2019/04/08/PAT（甲级）1055.The World's Richest（25）/","link":"","permalink":"http://example.com/2019/04/08/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891055.The%20World's%20Richest%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1055.The World’s Richest（25）Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages. 输入格式：Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤10^5) - the total number of people, and K (≤10^​3) - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [−10^​6 ,10^​6​​ ]) of a person. Finally there are K lines of queries, each contains three positive integers: M (≤100) - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space. 输出格式：For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin, Amax]. Each person’s information occupies a line, in the format:Name Age Net_WorthThe outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None. 输入样例： 123456789101112131415161712 4Zoe_Bill 35 2333Bob_Volk 24 5888Anny_Cin 95 999999Williams 30 -22Cindy 76 76000Alice 18 88888Joe_Mike 32 3222Michael 5 300000Rosemary 40 5888Dobby 24 5888Billy 24 5888Nobody 5 04 15 454 30 354 5 951 45 50 输出样例： 12345678910111213141516Case #1:Alice 18 88888Billy 24 5888Bob_Volk 24 5888Dobby 24 5888Case #2:Joe_Mike 32 3222Zoe_Bill 35 2333Williams 30 -22Case #3:Anny_Cin 95 999999Michael 5 300000Alice 18 88888Cindy 76 76000Case #4:None 题目分析：排序，使用数组存储，使用vector测试点二会超时。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int maxn &#x3D; 100010;using namespace std;struct people&#123; char name[10]; int age; int money;&#125;;people arr[maxn];bool cmp(people a, people b)&#123; if(a.money !&#x3D; b.money) return a.money &gt; b.money; else if(a.age!&#x3D;b.age) return a.age &lt; b.age; else return strcmp(a.name, b.name)&lt;0;&#125;int main()&#123; int n, k; scanf(&quot;%d%d&quot;,&amp;n, &amp;k); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%s %d %d&quot;,arr[i].name, &amp;arr[i].age, &amp;arr[i].money); &#125; sort(arr,arr+n,cmp); int m,Amin,Amax; for(int i&#x3D;0; i&lt;k; ++i)&#123; printf(&quot;Case #%d:\\n&quot;, i+1); scanf(&quot;%d%d%d&quot;,&amp;m, &amp;Amin, &amp;Amax); bool flag &#x3D; false; for(int j&#x3D;0; j&lt;n &amp;&amp; m&gt;0; ++j)&#123; if(arr[j].age&lt;&#x3D;Amax &amp;&amp; arr[j].age&gt;&#x3D;Amin)&#123; printf(&quot;%s %d %d\\n&quot;,arr[j].name, arr[j].age, arr[j].money); m --; flag &#x3D; true; &#125; &#125; if(!flag) printf(&quot;None\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1105.Spiral Maxtrix（25）","slug":"PAT（甲级）1105.Spiral Maxtrix（25）","date":"2019-04-08T14:10:09.000Z","updated":"2020-11-29T19:35:22.159Z","comments":true,"path":"2019/04/08/PAT（甲级）1105.Spiral Maxtrix（25）/","link":"","permalink":"http://example.com/2019/04/08/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891105.Spiral%20Maxtrix%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1105 Spiral Matrix（25）This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values. 输入格式：Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^​4. The numbers in a line are separated by spaces. 输出格式：For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. 输入样例： 121237 76 20 98 76 42 53 95 60 81 58 93 输出样例： 123498 95 9342 37 8153 20 7658 60 76 题目分析：模拟题。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; v;int main(void)&#123; int k, tmp; scanf(&quot;%d&quot;, &amp;k); for(int i&#x3D;0; i&lt;k; ++i)&#123; scanf(&quot;%d&quot;, &amp;tmp); v.push_back(tmp); &#125; sort(v.begin(), v.end(), [](int a, int b)&#123;return a&gt;b;&#125;); int n &#x3D; floor(sqrt(1.0*k)); while(k % n!&#x3D;0)n--; int m &#x3D; k &#x2F; n; int arr[m][n]; bool st[m][n]; fill(st[0],st[0]+n*m,false); fill(arr[0],arr[0]+n*m,0); int idx &#x3D; 0; int dx[4] &#x3D; &#123;-1,0,1,0&#125;,dy[4] &#x3D; &#123;0,1,0,-1&#125;; int x&#x3D;0,y&#x3D;0,d&#x3D;1; for(int i&#x3D;0; i&lt;n*m; ++i)&#123; arr[x][y] &#x3D; v[idx ++]; st[x][y] &#x3D; true; int a&#x3D;x+dx[d], b&#x3D;y+dy[d]; if(a&lt;0 || a&gt;&#x3D;m || b&lt;0 || b&gt;&#x3D;n || st[a][b])&#123; d &#x3D; (d+1)%4; a &#x3D; x+dx[d],b&#x3D;y+dy[d]; &#125; x&#x3D;a,y&#x3D;b; &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; printf(&quot;%d&quot;,arr[i][j]); if(j!&#x3D;n-1)printf(&quot; &quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1137.Fianl Grading（25）","slug":"PAT（甲级）1137.Fianl Grading（25）","date":"2019-04-07T10:11:48.000Z","updated":"2020-11-29T19:35:22.399Z","comments":true,"path":"2019/04/07/PAT（甲级）1137.Fianl Grading（25）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891137.Fianl%20Grading%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1137.Fianl Grading（25）For a student taking the online course “Data Structures” on China University MOOC (http://www.icourse163.org/), to be qualified for a certificate, he/she must first obtain no less than 200 points from the online programming assignments, and then receive a final grade no less than 60 out of 100. The final grade is calculated by G=(G​mid−term×40%+G​final×60%) if G​mid−term&gt;G​final, or G​final will be taken as the final grade G. Here G​mid−term​​ and G​final are the student’s scores of the mid-term and the final exams, respectively.The problem is that different exams have different grading sheets. Your job is to write a program to merge all the grading sheets into one. 输入格式：Each input file contains one test case. For each case, the first line gives three positive integers: P , the number of students having done the online programming assignments; M, the number of students on the mid-term list; and N, the number of students on the final exam list. All the numbers are no more than 10,000.Then three blocks follow. The first block contains P online programming scores G​p ‘s; the second one contains M mid-term scores Gmid−term’s; and the last one contains N final exam scores G​final​​ ‘s. Each score occupies a line with the format: StudentID Score, where StudentID is a string of no more than 20 English letters and digits, and Score is a nonnegative integer (the maximum score of the online programming is 900, and that of the mid-term and final exams is 100). 输出格式：For each case, print the list of students who are qualified for certificates. Each student occupies a line with the format:StudentID G​p Gmid−term G​final ​G If some score does not exist, output “−1” instead. The output must be sorted in descending order of their final grades (G must be rounded up to an integer). If there is a tie, output in ascending order of their StudentID&#39;s. It is guaranteed that the StudentID&#39;s are all distinct, and there is at least one qullified student. 输入样例： 12345678910111213141516171819206 6 701234 880a1903 199ydjh2 200wehu8 300dx86w 220missing 400ydhfu77 99wehu8 55ydjh2 98dx86w 88a1903 8601234 39ydhfu77 88a1903 6601234 58wehu8 84ydjh2 82missing 99dx86w 81 输出样例： 1234missing 400 -1 99 99ydjh2 200 98 82 88dx86w 220 88 81 84wehu8 300 55 84 84 题目分析：乙级1080.mooc最终成绩。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;struct Stu&#123; string name; int gp, gmid, gfinal, G; Stu(string name, int gp, int gmid, int gfinal, int G)&#123; this-&gt;name &#x3D; name; this-&gt;gp &#x3D; gp; this-&gt;gmid &#x3D; gmid; this-&gt;gfinal &#x3D; gfinal; this-&gt;G &#x3D; G; &#125;&#125;;bool cmp(Stu a, Stu b)&#123; if(a.G !&#x3D; b.G) return a.G &gt; b.G; else return a.name &lt; b.name;&#125;set&lt;string&gt; st;vector&lt;Stu&gt; vec;unordered_map&lt;string, int&gt; gp;unordered_map&lt;string, int&gt; gmid;unordered_map&lt;string, int&gt; gfinal;int main()&#123; string id; int p, m, n, score; scanf(&quot;%d%d%d&quot;, &amp;p, &amp;m, &amp;n); for(int i&#x3D;0; i&lt;p; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gp[id] &#x3D; score; &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gmid[id] &#x3D; score; &#125; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gfinal[id] &#x3D; score; &#125; int Gp, Gmid, Gfinal; for(auto it&#x3D;st.begin(); it!&#x3D;st.end(); ++it)&#123; if(gp.find(*it)!&#x3D;gp.end()) Gp &#x3D; gp[*it]; else Gp &#x3D; -1; if(gmid.find(*it)!&#x3D;gmid.end()) Gmid &#x3D; gmid[*it]; else Gmid &#x3D; -1; if(gfinal.find(*it)!&#x3D;gfinal.end()) Gfinal &#x3D; gfinal[*it]; else Gfinal &#x3D; -1; double G; if(Gmid &gt; Gfinal) G &#x3D; (int)(Gmid*0.4 + Gfinal*0.6 + 0.5); else G &#x3D; Gfinal; if(Gp&gt;&#x3D;200 &amp;&amp; G&gt;&#x3D;60) vec.push_back(Stu(*it, Gp, Gmid, Gfinal, G)); &#125; sort(vec.begin(), vec.end(), cmp); for(int i&#x3D;0; i&lt;vec.size(); ++i)&#123; cout&lt;&lt;vec[i].name; printf(&quot; %d %d %d %d\\n&quot;, vec[i].gp, vec[i].gmid, vec[i].gfinal, vec[i].G); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1036.Boys vs Girls（25）","slug":"PAT（甲级）1036.Boys vs Girls（25）","date":"2019-04-07T06:45:42.000Z","updated":"2020-11-29T19:35:22.419Z","comments":true,"path":"2019/04/07/PAT（甲级）1036.Boys vs Girls（25）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891036.Boys%20vs%20Girls%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1036.Boys vs Girls（25）This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. 输入格式：Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. 输出格式：For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference grade​F−gradeM . If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead. 输入样例1： 12343Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95 输出样例1： 123Mary EE990830Joe Math9901126 输入样例2： 121Jean M AA980920 60 输出样例1： 123AbsentJean AA980920NA 题目分析：vector+排序，水题！。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;struct stu&#123; string name; string id; int score;&#125;;vector&lt;stu&gt; female;vector&lt;stu&gt; male;bool cmpfemale(stu a, stu b)&#123;return a.score &gt; b.score;&#125;bool cmpmale(stu a, stu b)&#123;return a.score &lt; b.score;&#125;void print(stu a)&#123; cout&lt;&lt;a.name&lt;&lt;&quot; &quot;&lt;&lt;a.id&lt;&lt;&quot; &quot;&lt;&lt;a.score&lt;&lt;endl;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); string name,gender,id; int score; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;name&gt;&gt;gender&gt;&gt;id; scanf(&quot;%d&quot;, &amp;score); stu s; s.name &#x3D; name; s.id &#x3D; id; s.score &#x3D; score; if(gender[0]&#x3D;&#x3D;&#39;M&#39;)&#123; male.push_back(s); &#125; else&#123; female.push_back(s); &#125; &#125; sort(male.begin(), male.end(), cmpmale); sort(female.begin(), female.end(), cmpfemale); int maxScore, minScore; bool flag &#x3D; false; if(female.size()!&#x3D;0)&#123; cout&lt;&lt;female[0].name&lt;&lt;&quot; &quot;&lt;&lt;female[0].id&lt;&lt;endl; maxScore &#x3D; female[0].score; &#125; else&#123; flag &#x3D; true; cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl; &#125; if(male.size()!&#x3D;0)&#123; cout&lt;&lt;male[0].name&lt;&lt;&quot; &quot;&lt;&lt;male[0].id&lt;&lt;endl; minScore &#x3D; male[0].score; &#125; else&#123; flag &#x3D; true; cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl; &#125; if(flag) cout&lt;&lt;&quot;NA&quot;&lt;&lt;endl; else cout&lt;&lt;maxScore-minScore&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1143. Lowest Common Ancestor（30）","slug":"PAT（甲级）1143. Lowest Common Ancestor（30）","date":"2019-04-07T06:17:05.000Z","updated":"2020-11-29T19:35:22.411Z","comments":true,"path":"2019/04/07/PAT（甲级）1143. Lowest Common Ancestor（30）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891143.%20Lowest%20Common%20Ancestor%EF%BC%8830%EF%BC%89/","excerpt":"","text":"PAT 1143. Lowest Common Ancestor（30）The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.A binary search tree (BST) is recursively defined as a binary tree which has the following properties:1.The left subtree of a node contains only nodes with keys less than the node’s key.2.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.3.Both the left and right subtrees must also be binary search trees.Given any two nodes in a BST, you are supposed to find their LCA.输入格式：Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. 输出格式：For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. 输入样例： 123456786 86 3 1 2 5 4 8 72 58 71 912 -30 899 99 输出样例： 123456LCA of 2 and 5 is 3.8 is an ancestor of 7.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 题目分析：题目给出的是BST树，可以利用BST的中序遍历是顺序序列这一性质。由前序序列排序后获得中序序列，使用中序序列和前序序列重构二叉树即可。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn &#x3D; 10010;map&lt;int, bool&gt; mp;int in[maxn];int pre[maxn];int post[maxn];int preTemp[maxn];struct node&#123; int data; node* lchild; node* rchild;&#125;;node* build(int preL, int preR, int inL, int inR)&#123; if(preL&gt;preR)return NULL; node* root &#x3D; new node; root-&gt;data &#x3D; pre[preL]; int k; for(k&#x3D;inL; k&lt;&#x3D;inR; ++k)&#123; if(in[k] &#x3D;&#x3D; pre[preL])break; &#125; int leftnum &#x3D; k-inL; root-&gt;lchild &#x3D; build(preL+1, preL+leftnum, inL, k-1); root-&gt;rchild &#x3D; build(preL+leftnum+1, preR, k+1, inR); return root;&#125;void postorder(node* root)&#123; if(root)&#123; postorder(root-&gt;lchild); postorder(root-&gt;rchild); cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;; &#125;&#125;node* lca(node* root, int u, int v)&#123; if(root&#x3D;&#x3D;NULL)return NULL; if(root-&gt;data&#x3D;&#x3D;u || root-&gt;data&#x3D;&#x3D;v)return root; node* left &#x3D; lca(root-&gt;lchild, u, v); node* right &#x3D; lca(root-&gt;rchild, u, v); if(left &amp;&amp; right)return root; return left&#x3D;&#x3D;NULL?right:left;&#125;int main()&#123; int m, n, u, v; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;pre[i]); mp[pre[i]] &#x3D; true; preTemp[i] &#x3D; pre[i]; &#125; sort(preTemp,preTemp+n); for(int i&#x3D;0; i&lt;n; ++i)&#123;in[i]&#x3D;preTemp[i];&#125; node* root &#x3D; build(0, n-1, 0, n-1); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(mp[u]&#x3D;&#x3D;false &amp;&amp; mp[v]&#x3D;&#x3D;false) printf(&quot;ERROR: %d and %d are not found.\\n&quot;, u, v); else if(mp[u]&#x3D;&#x3D;false || mp[v]&#x3D;&#x3D;false)&#123; if(mp[u]&#x3D;&#x3D;false) printf(&quot;ERROR: %d is not found.\\n&quot;,u); else printf(&quot;ERROR: %d is not found.\\n&quot;,v); &#125; else&#123; node* tmp &#x3D; lca(root, u, v); if(tmp-&gt;data&#x3D;&#x3D;u || tmp-&gt;data&#x3D;&#x3D;v)&#123; if(tmp-&gt;data &#x3D;&#x3D; u) printf(&quot;%d is an ancestor of %d.\\n&quot;, u, v); else printf(&quot;%d is an ancestor of %d.\\n&quot;, v, u); &#125; else&#123; printf(&quot;LCA of %d and %d is %d.\\n&quot;, u, v, tmp-&gt;data); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1051.LCA in a Binary Tree（30）","slug":"PAT（甲级）1051.LCA in a Binary Tree（30）","date":"2019-04-07T05:52:33.000Z","updated":"2020-11-29T19:35:22.403Z","comments":true,"path":"2019/04/07/PAT（甲级）1051.LCA in a Binary Tree（30）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891051.LCA%20in%20a%20Binary%20Tree%EF%BC%8830%EF%BC%89/","excerpt":"","text":"PAT 1051.LCA in a Binary Tree（30）The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.Given any two nodes in a binary tree, you are supposed to find their LCA. 输入格式：Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. 输出格式：For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. 输入样例： 1234567896 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99 输出样例： 123456LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 题目分析：1.求解最近公共祖先。题目中中给出了二叉树的先序遍历和中序遍历，因此可以重构二叉树。2.将先序或后序序列中的元素保存在map表，标记其是否出现过。方便后边的查询。3.(1)u和v均未在map表中出现过，直接输出a and b are not found(2)u和v只有一个在map表中，直接输出另外一个未找到，a is not found.(3)使用LCA函数求解公共祖先所对应的节点。下边仔细分析LAC：对于LCA算法，如果当前的两个节点在树的两个分支，此时树根节点就是公共祖先。如果两个节点同时在树根的一侧，则其中一个节点是另外一个节点的最近公共祖先。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 10010;map&lt;int, bool&gt; mp;int in[maxn], pre[maxn];struct node&#123; int data; node* lchild; node* rchild;&#125;;&#x2F;&#x2F;二叉树重构模板node* build(int preL, int preR, int inL, int inR)&#123; if(preL&gt;preR)return NULL; node* root &#x3D; new node; root-&gt;data &#x3D; pre[preL]; int k; for(k&#x3D;inL; k&lt;&#x3D;inR; ++k)&#123; if(in[k]&#x3D;&#x3D;pre[preL])break; &#125; int leftNum &#x3D; k-inL; root-&gt;lchild &#x3D; build(preL+1, preL+leftNum, inL, k-1); root-&gt;rchild &#x3D; build(preL+leftNum+1, preR, k+1, inR); return root;&#125;node* lca(node* root, int u, int v)&#123; if(root&#x3D;&#x3D;NULL) return NULL; if(root-&gt;data&#x3D;&#x3D;u || root-&gt;data&#x3D;&#x3D;v) return root; node* left &#x3D; lca(root-&gt;lchild, u, v); node* right &#x3D; lca(root-&gt;rchild, u, v); if(left &amp;&amp; right)return root; return left&#x3D;&#x3D;NULL?right:left;&#125;int main()&#123; int m, n, u, v; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;in[i]); mp[in[i]] &#x3D; true; &#125; for(int i&#x3D;0; i&lt;n; ++i)&#123;scanf(&quot;%d&quot;, &amp;pre[i]);&#125; node* root &#x3D; build(0, n-1, 0, n-1); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); if(mp[u]&#x3D;&#x3D;false &amp;&amp; mp[v]&#x3D;&#x3D;false) printf(&quot;ERROR: %d and %d are not found.\\n&quot;, u, v); else if(mp[u]&#x3D;&#x3D;false || mp[v]&#x3D;&#x3D;false) printf(&quot;ERROR: %d is not found.\\n&quot;,mp[u]&#x3D;&#x3D;false?u:v); else&#123; node* tmp &#x3D; lca(root, u, v); if(tmp-&gt;data&#x3D;&#x3D;u || tmp-&gt;data&#x3D;&#x3D;v)&#123; if(tmp-&gt;data&#x3D;&#x3D;u) printf(&quot;%d is an ancestor of %d.\\n&quot;, u,v); else printf(&quot;%d is an ancestor of %d.\\n&quot;, v, u); &#125; else&#123; printf(&quot;LCA of %d and %d is %d.\\n&quot;, u, v, tmp-&gt;data); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1025.PAT Ranking（25）","slug":"PAT（甲级）1025.PAT Ranking（25）","date":"2019-04-07T01:24:00.000Z","updated":"2020-11-29T19:35:22.523Z","comments":true,"path":"2019/04/07/PAT（甲级）1025.PAT Ranking（25）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891025.PAT%20Ranking%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1025.PAT Ranking（25）Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.输入格式：Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. 输出格式：For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:registration_number final_rank location_number local_rankThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. 输入样例： 123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 输出样例： 1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 题目分析：分组排名，整体排名。 注意：由于不知道题目会输入多少个组，每一个组是一个vector对象，因此可以开辟110个vector数组。相当于一个二维数组。首先进行各组的组内排名，都排完之后将所有组同学合并到同一个vector中，进行最后一次排名，然后一次输出即可。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn &#x3D; 110;struct people&#123; string name; int score;&#125;;struct stu&#123; string name; int group; int score; int groupRank; stu(string name, int group, int score, int groupRank)&#123; this-&gt;name &#x3D; name; this-&gt;group &#x3D; group; this-&gt;score &#x3D; score; this-&gt;groupRank &#x3D; groupRank; &#125;&#125;;vector&lt;people&gt; arr[maxn];vector&lt;stu&gt; v;bool cmp(people a, people b)&#123; if(a.score !&#x3D; b.score)return a.score &gt; b.score; else return a.name &lt; b.name;&#125;bool cmp1(stu a, stu b)&#123; if(a.score !&#x3D; b.score)return a.score &gt; b.score; else return a.name &lt; b.name;&#125;int main()&#123; int n, m; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;m); people p; string name; int score; for(int j&#x3D;0; j&lt;m; ++j)&#123; cin&gt;&gt;name; scanf(&quot;%d&quot;, &amp;score); p.name &#x3D; name; p.score &#x3D; score; arr[i].push_back(p); &#125; sort(arr[i].begin(), arr[i].end(), cmp); int rank &#x3D; 0, pre&#x3D;-1; for(int k&#x3D;0; k&lt;arr[i].size(); ++k)&#123; if(arr[i][k].score !&#x3D; pre)rank &#x3D; k+1; pre &#x3D; arr[i][k].score; v.push_back(stu(arr[i][k].name, i+1, arr[i][k].score, rank)); &#125; &#125; int cnt &#x3D; 0; for(int i&#x3D;0; i&lt;n; ++i)&#123; cnt +&#x3D; arr[i].size(); &#125; printf(&quot;%d\\n&quot;, cnt); sort(v.begin(), v.end(), cmp1); int rank&#x3D;0,pre&#x3D;-1; for(int i&#x3D;0; i&lt;v.size(); ++i)&#123; if(v[i].score!&#x3D;pre)rank &#x3D; i+1; pre &#x3D; v[i].score; printf(&quot;%s %d %d %d\\n&quot;, v[i].name.c_str(), rank, v[i].group, v[i].groupRank); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1138.Postorder Traversal（25）","slug":"PAT（甲级）1138.Postorder Traversal（25）","date":"2019-04-06T16:39:57.000Z","updated":"2020-11-29T19:35:22.403Z","comments":true,"path":"2019/04/07/PAT（甲级）1138.Postorder Traversal（25）/","link":"","permalink":"http://example.com/2019/04/07/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891138.Postorder%20Traversal%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1138.Postorder Traversal（25）Suppose that all the keys in a binary tree are distinct positive integers. Given the preorder and inorder traversal sequences, you are supposed to output the first number of the postorder traversal sequence of the corresponding binary tree.输入格式：Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. 输出格式：For each test case, print in one line the first number of the postorder traversal sequence of the corresponding binary tree. 输入样例： 12371 2 3 4 5 6 72 3 1 5 4 7 6 输出样例： 13 题目分析：模板题，根据中序遍历和前序遍历求解后序遍历序列的第一个元素。 注意：应该牢牢掌握以下三种二叉树的重构。1.前序+中序2.中序+后序3.中序+层序 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int maxn &#x3D; 50010;int mid[maxn] &#x3D; &#123;0&#125;;int pre[maxn] &#x3D; &#123;0&#125;;int post[maxn] &#x3D; &#123;0&#125;;int n, idx&#x3D;1;struct node&#123; int data; node* lchild; node* rchild;&#125;;node* build(int preL, int preR, int inL, int inR)&#123; if(preL &gt; preR)return NULL; node* root &#x3D; new node; root-&gt;data &#x3D; pre[preL]; int k; for(k &#x3D; inL; k&lt;&#x3D;inR; ++k)&#123; if(mid[k] &#x3D;&#x3D; pre[preL]) break; &#125; int numLeft &#x3D; k - inL; root-&gt;lchild &#x3D; build(preL+1, preL+numLeft, inL, k-1); root-&gt;rchild &#x3D; build(preL+numLeft+1, preR, k+1, inR); return root;&#125;void postorder(node* root)&#123; if(root)&#123; postorder(root-&gt;lchild); postorder(root-&gt;rchild); post[idx ++] &#x3D; root-&gt;data; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;scanf(&quot;%d&quot;, &amp;pre[i]);&#125; for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;scanf(&quot;%d&quot;, &amp;mid[i]);&#125; node* root &#x3D; build(1, n, 1, n); postorder(root); cout&lt;&lt;post[1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT考试 常用技巧（持续更新）","slug":"PAT考试 常用技巧（持续更新）","date":"2019-04-06T15:26:34.000Z","updated":"2020-11-29T19:35:22.411Z","comments":true,"path":"2019/04/06/PAT考试 常用技巧（持续更新）/","link":"","permalink":"http://example.com/2019/04/06/PAT%E8%80%83%E8%AF%95%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"1.字符串中的大小写转换 1s[i] ^&#x3D; 32;&#x2F;&#x2F;位运算，速度快 2.排名的实现（有并列的情况）,一般将排名的对象存放在容器中。 123456789101112131415struct peo&#123; int score;&#125;;vector&lt;peo&gt; v;int main()&#123; ....省略部分 int rank &#x3D; 0, pre &#x3D; -1; for(int i&#x3D;0; i&lt;v.size(); i++)&#123; if (pre !&#x3D; v[i].score) rank &#x3D; i + 1; pre &#x3D; v[i].score; printf(&quot;%d &quot;, rank); &#125; return 0;&#125; 3.不想写C/C++头文件，直接写下边一个就可以 1#include &lt;bits&#x2F;stdc++.h&gt; 4.使cin,cout与printf,scanf效率一致。在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。 12ios::sync_with_stdio(false); cin.tie(0); 5.时间的处理， PAT表示时间的一般形式为”hh:mm:ss”,因此可以统一转换为秒方便计算。 1hh:mm:ss time(秒) &#x3D; hh*3600 + mm*60 + ss","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"git本地仓库的使用流程","slug":"git本地仓库的使用流程","date":"2019-04-06T10:03:55.000Z","updated":"2020-11-29T19:35:22.427Z","comments":true,"path":"2019/04/06/git本地仓库的使用流程/","link":"","permalink":"http://example.com/2019/04/06/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"一、基本设置 1.设置用户名 1git config --global user.name &quot;你的用户名&quot; 2.设置邮箱 1git config --global user.email &quot;你的邮箱地址&quot; 3.查看设置 1git config --list 3.删除设置 1git config --global --unset user.name 二、初始化本地仓库 123451.新建本地仓库目录文件夹2.进入该文件后，使用git bash命令行模式：创建本地仓库 mkdir projectName3.cd projectName 切换进入刚刚建立的本地仓库4.git init 初始化本地仓库5.使用ls -al命令会看到在本地下有一个.git的隐藏文件，这个文件非常重要 三、本地仓库基本操作1、新建文件 1231.touch main.cpp 新建文件夹2.git add main.cpp 提交的暂存区3.git commit -m &quot;第一次提交&quot; 2、修改文件 1231.通过vim修改， vim main.cpp2.git add main.cpp 提交的暂存区3.git commit -m &quot;增加了helloworld&quot; 3、删除文件 1231.rm main.cpp2.git rm main.cpp 删除暂存区的main.cpp文件3.git commit -m &quot;第一次删除main.cpp文件&quot; 4、重命名文件 12341.mv readme.md readme2.git add readme3.git rm readme.md替代以上三个操作的git命令：git mv readme.md readme, 一个步骤就可以完成 5、查看版本历史 1git log","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"PAT（甲级）1121.Damn Single（25）","slug":"PAT（甲级）1121.Damn Single（25）","date":"2019-04-06T06:05:20.000Z","updated":"2020-11-29T19:35:22.383Z","comments":true,"path":"2019/04/06/PAT（甲级）1121.Damn Single（25）/","link":"","permalink":"http://example.com/2019/04/06/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891121.Damn%20Single%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1121.Damn Single（25分） “Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.输入格式：Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion. 输出格式：First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line. 输入样例： 123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例： 12510000 23333 44444 55555 88888 题目分析：乙级1065的一个题目，具体分析请看乙级1065 注意：输出格式为%05d，否则测试点3会出错。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn &#x3D; 100000;bool is_appear[maxn] &#x3D; &#123;false&#125;;vector&lt;int&gt;v;unordered_map&lt;int, int&gt; mp;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n, a, b; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); mp.insert(make_pair(a, b)); &#125; int m, tmp; scanf(&quot;%d&quot;, &amp;m); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d&quot;, &amp;tmp); is_appear[tmp] &#x3D; true; &#125; for(auto it&#x3D;mp.begin(); it!&#x3D;mp.end(); ++it)&#123; if(is_appear[it-&gt;first] &amp;&amp; is_appear[it-&gt;second])&#123; is_appear[it-&gt;first] &#x3D; is_appear[it-&gt;second] &#x3D; false; &#125; &#125; for(int i&#x3D;0; i&lt;maxn; ++i)&#123; if(is_appear[i]) v.push_back(i); &#125; sort(v.begin(), v.end()); for(int i&#x3D;0; i&lt;v.size(); ++i)&#123; printf(&quot;%05d&quot;, v[i]); if(i!&#x3D;v.size()-1)printf(&quot; &quot;); &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1050.String Subtraction（20）","slug":"PAT（甲级）1050.String Subtraction（20）","date":"2019-04-06T05:42:52.000Z","updated":"2020-11-29T19:35:22.419Z","comments":true,"path":"2019/04/06/PAT（甲级）1050.String Subtraction（20）/","link":"","permalink":"http://example.com/2019/04/06/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891050.String%20Subtraction%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1050.String Subtraction（20） Given two strings S1 and S​2​​ , S=S1−S​2 is defined to be the remaining string after taking all the characters in S​2 from S1. Your task is simply to calculate S1−S2 for any given strings. However, it might not be that simple to do it fast.输入格式：Each input file contains one test case. Each case consists of two lines which gives S​1​​ and S​2, respectively.The string lengths of both strings are no more than 10^​4. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string. 输出格式：For each test case, print S​1−S2 in one line. 输入样例： 12They are students.aeiou 输出样例： 1Thy r stdnts. 题目分析：数组hash的使用，因为题目要求s1-s2,因此开辟一个hash数组用来存放s2中出现的字符，然后遍历s1的所有字符，如果在hash数组中出现过就不输出。 注意：题目给出的字符串可能包含空格，因此不能使用cin进行输入，建议使用getline()进行输入。 AC代码： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int maxn &#x3D; 128;bool is_appear[maxn]&#x3D;&#123;false&#125;;int main()&#123; string s1,s2; getline(cin, s1); getline(cin, s2); for(int i&#x3D;0; i&lt;s2.length(); ++i)&#123; is_appear[s2[i]] &#x3D; true; &#125; for(int i&#x3D;0; i&lt;s1.length(); ++i)&#123; if(!is_appear[s1[i]]) cout&lt;&lt;s1[i]; &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1006.Sign In and Sign Out（25）","slug":"PAT（甲级）1006.Sign In and Sign Out（25）","date":"2019-04-06T05:25:03.000Z","updated":"2020-11-29T19:35:22.859Z","comments":true,"path":"2019/04/06/PAT（甲级）1006.Sign In and Sign Out（25）/","link":"","permalink":"http://example.com/2019/04/06/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891006.Sign%20In%20and%20Sign%20Out%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1141.PAT Ranking of Institutions （25 分) At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.输入格式：Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:ID_number Sign_in_time Sign_out_timewhere times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters. 输出格式：For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. 输入样例： 12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 输出样例： 1SC3021234 CS301133 题目分析：sort的使用，求解最早签到时间和最晚签到离开时间。主要的难度在于签到和签到离开时间的处理，当成字符串处理会比较直接简单。 注意：由于题目可以转化为输出最早签到的人名和最晚签到离开的人，此题也也可以直接在输入时间比较。在一天中按照hh:mm:ss的形式，最早为00：00：00，最晚为23:59:59 AC代码1： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;struct people&#123; string id, sign_in, sign_out; people(string id, string sign_in, string sign_out)&#123; this-&gt;id &#x3D; id; this-&gt;sign_in &#x3D; sign_in; this-&gt;sign_out &#x3D; sign_out; &#125;&#125;;vector&lt;people&gt; v;bool cmpin(people a, people b) &#123;return a.sign_in &lt; b.sign_in;&#125;bool cmpout(people a, people b)&#123;return a.sign_out &gt; b.sign_out;&#125;void print(people a)&#123; cout&lt;&lt;a.id&lt;&lt;&quot; &quot;&lt;&lt;a.sign_in&lt;&lt;&quot; &quot;&lt;&lt;a.sign_out&lt;&lt;endl;&#125; int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n; scanf(&quot;%d&quot;, &amp;n); string id,sign_in,sign_out; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;id&gt;&gt;sign_in&gt;&gt;sign_out; v.push_back(people(id, sign_in, sign_out)); &#125; &#x2F;&#x2F;for_each(v.begin(), v.end(), print); sort(v.begin(), v.end(), cmpin); cout&lt;&lt;v[0].id&lt;&lt;&quot; &quot;; sort(v.begin(), v.end(), cmpout); cout&lt;&lt;v[0].id&lt;&lt;endl; return 0;&#125; AC代码2： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string earliest &#x3D; &quot;23:59:59&quot;; string latest &#x3D; &quot;00:00:00&quot;; string earliestName, latestName; int n; scanf(&quot;%d&quot;, &amp;n); string id, early, finally; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;id&gt;&gt;early&gt;&gt;finally; if(early &lt;&#x3D; earliest)&#123; earliest &#x3D; early; earliestName &#x3D; id; &#125; if(finally &gt;&#x3D; latest)&#123; latest &#x3D; finally; latestName &#x3D; id; &#125; &#125; cout&lt;&lt;earliestName&lt;&lt;&quot; &quot;&lt;&lt;latestName&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（甲级）1141.PAT Ranking of Institutions （25 分)","slug":"PAT（甲级）1141.PAT Ranking of Institutions （25 分)","date":"2019-04-05T17:09:37.000Z","updated":"2020-11-29T19:35:22.775Z","comments":true,"path":"2019/04/06/PAT（甲级）1141.PAT Ranking of Institutions （25 分)/","link":"","permalink":"http://example.com/2019/04/06/PAT%EF%BC%88%E7%94%B2%E7%BA%A7%EF%BC%891141.PAT%20Ranking%20of%20Institutions%20%EF%BC%8825%20%E5%88%86)/","excerpt":"","text":"PAT 1141.PAT Ranking of Institutions （25 分) After each PAT, the PAT Center will announce the ranking of institutions based on their students’ performances. Now you are asked to generate the ranklist.输入格式：Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^5), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format:ID Score Schoolwhere ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level andTthe top level; Score is an integer in [0, 100]; and School is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee. 输出格式：For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:Rank School TWS Nswhere Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5, where ScoreX is the total score of the testees belong to this institution on level X; and Ns is the total number of testees who belong to this institution.The institutions are ranked according to their TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns. If there is still a tie, they shall be printed in alphabetical order of their codes. 输入样例： 123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu 输出样例： 12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 题目分析：sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。 其中使用C++11的unordered_map和unordered_set会大大提高效率，因为其底层是使用hash_table实现的，具体可以参阅C++11的新标准。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn &#x3D; 100010;struct school&#123; string name; int score; int sum; school()&#123;&#125; school(string name, int score, int sum):name(name), score(score), sum(sum)&#123;&#125;&#125;;vector&lt;school&gt; v;unordered_map&lt;string, double&gt; nameToScore;unordered_map&lt;string, int&gt; nameToSumPeople;set&lt;string&gt; schoolName;void toLower(string&amp; s)&#123; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(s[i]&gt;&#x3D;&#39;A&#39; &amp;&amp; s[i]&lt;&#x3D;&#39;Z&#39;)s[i] +&#x3D; 32; &#125;&#125;bool cmp(school a, school b)&#123; if(a.score!&#x3D;b.score)return a.score&gt;b.score; if(a.sum!&#x3D;b.sum) return a.sum &lt; b.sum; else return a.name &lt; b.name;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n; scanf(&quot;%d&quot;, &amp;n); string id, name; double score; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;id; scanf(&quot;%lf&quot;, &amp;score); cin&gt;&gt;name; toLower(name); schoolName.insert(name); nameToSumPeople[name] +&#x3D; 1; if(&#39;A&#39;&#x3D;&#x3D;id[0])&#123;nameToScore[name] +&#x3D; score;&#125; else if(&#39;B&#39;&#x3D;&#x3D;id[0])&#123;nameToScore[name] +&#x3D; (score &#x2F; 1.5);&#125; else&#123;nameToScore[name] +&#x3D; (score * 1.5);&#125; &#125; for(auto it&#x3D;schoolName.begin(); it!&#x3D;schoolName.end(); ++it)&#123; v.push_back(school(*it, (int)(nameToScore[*it]), nameToSumPeople[*it])); &#125; sort(v.begin(), v.end(), cmp); cout&lt;&lt;v.size()&lt;&lt;endl; int rank &#x3D; 1; cout&lt;&lt;rank&lt;&lt;&quot; &quot;&lt;&lt;v[0].name&lt;&lt;&quot; &quot;&lt;&lt;v[0].score&lt;&lt;&quot; &quot;&lt;&lt;v[0].sum&lt;&lt;endl; for(int i&#x3D;1; i&lt;v.size(); ++i)&#123; if(!i || v[i].score!&#x3D;v[i-1].score) rank &#x3D; i+1; cout&lt;&lt;rank&lt;&lt;&quot; &quot;&lt;&lt;v[i].name&lt;&lt;&quot; &quot;&lt;&lt;v[i].score&lt;&lt;&quot; &quot;&lt;&lt;v[i].sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT 甲级常用单词组 （持续更新）","slug":"PAT 甲级常用单词组 （持续更新）","date":"2019-04-05T15:43:47.000Z","updated":"2020-11-29T19:35:22.747Z","comments":true,"path":"2019/04/05/PAT 甲级常用单词组 （持续更新）/","link":"","permalink":"http://example.com/2019/04/05/PAT%20%E7%94%B2%E7%BA%A7%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E7%BB%84%20%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"12345678910111.case insensitive 不区分大小写2.nodecreasing order 递增次序；非递减次序3.lower case 小写字母4.upper case 大写字母5.there is a tie 成绩并列6.alphabetical order 字典序7.simultaneously 同时地8.positive number9.negative number10.chronologically 按时间的先后顺序记录11.for the sake of simplicity 为了简单起见 图论： 12345671.directed grapg 有向图2.undirected graph 无向图3.directed edges 有向边4.topological order 拓扑序列5.vertices vertex的复数形式 表示节点6.indices index的复数形式 一般表示下标7.connected components 连通分量","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1007.素数对猜想（20）","slug":"PAT（乙级）1007.素数对猜想（20）","date":"2019-04-04T12:14:36.000Z","updated":"2020-11-29T19:35:22.747Z","comments":true,"path":"2019/04/04/PAT（乙级）1007.素数对猜想（20）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891007.%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1007.素数对猜想（20） 让我们定义d​n为：dn=pn+1−p​n，其中p​i是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。”素数对猜想”认为 “存在无穷多对相邻且差为2的素数”。现给定任意正整数N(&lt;10^5​​ )，请计算不超过N的满足猜想的素数对的个数。输入格式：输入在一行给出正整数N。 输出格式：在一行中输出不超过N的满足猜想的素数对的个数。 输入样例： 120 输出样例： 14 题目分析：素数筛选法，O(n^2)求解素数会超时。 AC代码： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cmath&gt;const int max_n &#x3D; 100010;bool p[max_n];int prime[max_n];int num &#x3D; 0;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123; if(p[i]&#x3D;&#x3D;false)&#123; prime[num++] &#x3D; i; &#125; for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)&#123; p[j] &#x3D; true; &#125; &#125; int cnt &#x3D; 0; for(int i&#x3D;0;i&lt;num-1;++i)&#123; if(prime[i+1]-prime[i]&#x3D;&#x3D;2)&#123; cnt++; &#125; &#125; printf(&quot;%d&quot;,cnt); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1004.成绩排名（20）","slug":"PAT（乙级）1004.成绩排名（20）","date":"2019-04-04T12:03:51.000Z","updated":"2020-11-29T19:35:22.755Z","comments":true,"path":"2019/04/04/PAT（乙级）1004.成绩排名（20）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891004.%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1004.成绩排名（20） 读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。输入格式：每个测试输入包含 1 个测试用例，格式为： 12345第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 题目分析：排序的使用。AC代码： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cassert&gt;using namespace std;typedef struct student&#123; char name[11]; char num[11]; int score;&#125;Student;bool cmp(student a,student b)&#123; return a.score &lt; b.score;&#125;int main()&#123; int n; cin&gt;&gt;n; int tmp &#x3D; n; Student student[tmp]; while(tmp--)&#123; cin&gt;&gt;student[tmp].name&gt;&gt;student[tmp].num&gt;&gt;student[tmp].score; assert(student[tmp].score&gt;&#x3D;0 &amp;&amp; student[tmp].score&lt;&#x3D;100); &#125; sort(student,student+n,cmp); printf(&quot;%s %s\\n&quot;,student[n-1].name,student[n-1].num); printf(&quot;%s %s\\n&quot;,student[0].name,student[0].num); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1002.写出这个数（20）","slug":"PAT（乙级）1002.写出这个数（20）","date":"2019-04-04T11:55:37.000Z","updated":"2020-11-29T19:35:22.763Z","comments":true,"path":"2019/04/04/PAT（乙级）1002.写出这个数（20）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891002.%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1002.写出这个数（20） 读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。输入格式：每个测试输入包含 1 个测试用例，即给出自然数n的值。这里保证 n 小于 10​^100。 输出格式：在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例： 11234567890987654321123456789 输出样例： 1yi san wu 题目分析：因为数据的位数太大，long long也是存储不下的，使用大数类的模板解决。其次使用hash数组存储整型数字到拼音字符串的映射。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cassert&gt;using namespace std;string mp[10]&#x3D;&#123;&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;&#125;;struct bign&#123; int d[101]; int len; bign()&#123; memset(d,0,sizeof(d)); len &#x3D; 0; &#125;&#125;;bign change(string&amp; s)&#123; bign a; for(int i&#x3D;0;i&lt;s.length();++i)&#123; a.d[a.len ++] &#x3D; s[s.length()-1-i]-&#39;0&#39;; &#125; return a;&#125;int main()&#123; string s,t; getline(cin, t); bign a &#x3D; change(t); int tmp &#x3D; 0; for(int i&#x3D;0;i&lt;a.len; ++i)&#123; tmp +&#x3D; a.d[i]; &#125; s &#x3D; to_string(tmp); for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; cout&lt;&lt;mp[s[i]-&#39;0&#39;]; if(i!&#x3D;s.length()-1)printf(&quot; &quot;); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1001.害死人不偿命的(3n+1)猜想（15）","slug":"PAT（乙级）1001.害死人不偿命的(3n+1)猜想（15）","date":"2019-04-04T11:13:06.000Z","updated":"2020-11-29T19:35:22.763Z","comments":true,"path":"2019/04/04/PAT（乙级）1001.害死人不偿命的(3n+1)猜想（15）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891001.%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3%EF%BC%8815%EF%BC%89/","excerpt":"","text":"PAT 1001.害死人不偿命的(3n+1)猜想（15） 卡拉兹(Callatz)猜想：对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式:每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式:出从 n 计算到 1 需要的步数。 输入样例： 13 输出样例： 15 题目分析：简单模拟 AC代码: 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;assert&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int count &#x3D; 0; while(n!&#x3D;1)&#123; if(n%2&#x3D;&#x3D;1)&#123; n &#x3D; (3*n+1)&#x2F;2; count++; &#125; else&#123; assert(n%2&#x3D;&#x3D;0); n &#x2F;&#x3D; 2; count++; &#125; &#125; printf(&quot;%d&quot;,count); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1051.复数乘法（15）","slug":"PAT（乙级）1051.复数乘法（15）","date":"2019-04-04T04:23:49.000Z","updated":"2020-11-29T19:35:22.759Z","comments":true,"path":"2019/04/04/PAT（乙级）1051.复数乘法（15）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891051.%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95%EF%BC%8815%EF%BC%89/","excerpt":"","text":"PAT 1051.复数乘法（15） 复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i^2=−1；也可以写成极坐标下的指数形式 (R×e​(Pi))，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 R(cos(P)+isin(P))。现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。输入格式：输入在一行中依次给出两个复数的 R​1, P​1 , R​2​​ , P​2 ，数字间以空格分隔。 输出格式：在一行中按照 A+Bi 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 B 是负数，则应该写成A-|B|i的形式。 输入样例： 12.3 3.5 5.2 0.4 输出样例： 1-8.68-8.23i 题目分析：这道题目的主要难点在于输出格式的处理上。1.对于实部，因为题目要求保留两位有效数字，对于real = -0.0032类似的数字会舍为-0.00,这样的输出是不符合题意的，应该输出为0.00,所以当实部real &lt; 0 &amp;&amp; real &gt;-0.005输出0.00否则正常输出即可;2.对于虚部，因为要添加正负号。所以要区分 1231.img &lt; 0 &amp;&amp; img &gt; -0.005原因同上，输出+.2lfi;2.img &lt;&#x3D; -0.005，正常输出即可， 输出.2lfi;3.img &gt;&#x3D;0, 需要添加正号+, 输出+.2lf; 看到上边，其实对于任意保留位数，可以划分为3个区间，（+无穷大，0]（0，某个数字）[某个数字，-无穷大）,其中某个数字是这样计算而来，保留2小数，就用最小的保留两位数字除以二得到。如保留两位数字，最小为0.01，其对应的数字为0.01/2=0.005。 AC代码: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; double r1,p1,r2,p2; cin&gt;&gt;r1&gt;&gt;p1&gt;&gt;r2&gt;&gt;p2; double real &#x3D; r1*r2*(cos(p1+p2)); double img &#x3D; r1*r2*(sin(p1+p2)); if(real&lt;0 &amp;&amp; real&gt;-0.005) printf(&quot;0.00&quot;); else printf(&quot;%.2lf&quot;, real); if(img&lt;0 &amp;&amp; img&gt;-0.005) printf(&quot;+0.00i&quot;); else if(img&lt;&#x3D;-0.005) printf(&quot;%.2lfi&quot;, img); else printf(&quot;+%.2lfi&quot;, img); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1017.A除以B（20）","slug":"PAT（乙级）1017.A除以B（20）","date":"2019-04-04T02:25:52.000Z","updated":"2020-11-29T19:35:22.775Z","comments":true,"path":"2019/04/04/PAT（乙级）1017.A除以B（20）/","link":"","permalink":"http://example.com/2019/04/04/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891017.A%E9%99%A4%E4%BB%A5B%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1017.A除以B（20） 本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例： 1123456789050987654321 7 输出样例： 117636684150141093474 3 题目分析：算是一个高精度模拟的题目，用算法笔记高精度和低精度的除法，板子题，就当是练习练习高精度运算。柳神有更好的处理方式，传送门：1017 AC代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;struct bign&#123; int d[1010]; int len; bign()&#123; memset(d, 0, sizeof(d)); len &#x3D; 0; &#125;&#125;;bign change(string&amp; t)&#123; bign tmp; for(int i&#x3D;t.length()-1; i&gt;&#x3D;0; --i)&#123; tmp.d[tmp.len ++] &#x3D; t[i]-&#39;0&#39;; &#125; return tmp;&#125;bign divide(bign a, int b, int&amp; r)&#123; bign c; c.len &#x3D; a.len; for(int i&#x3D;a.len-1; i&gt;&#x3D;0; --i)&#123; r &#x3D; r*10 + a.d[i]; if(r &lt; b)c.d[i] &#x3D; 0; else&#123; c.d[i] &#x3D; r&#x2F;b; r &#x3D; r%b; &#125; &#125; while(c.len-1 &gt;&#x3D; 1 &amp;&amp; c.d[c.len-1] &#x3D;&#x3D; 0) c.len --; return c;&#125;void show(bign a)&#123; for(int i&#x3D;a.len-1; i&gt;&#x3D;0; --i)&#123; cout&lt;&lt;a.d[i]; &#125;&#125;int main()&#123; string t; bign a, q; int b, r&#x3D;0; cin&gt;&gt;t&gt;&gt;b; a &#x3D; change(t); q &#x3D; divide(a, b, r); show(q); cout&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1063.计算谱半径（20）","slug":"PAT（乙级）1063.计算谱半径（20）","date":"2019-03-28T08:12:11.000Z","updated":"2020-11-29T19:35:22.775Z","comments":true,"path":"2019/03/28/PAT（乙级）1063.计算谱半径（20）/","link":"","permalink":"http://example.com/2019/03/28/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891063.%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1063.计算谱半径（20） 在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 &#123; a1+b​1i,⋯,an+b​n​​i &#125;，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。输入格式：输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。 输出格式：在一行中输出谱半径，四舍五入保留小数点后 2 位。 输入样例： 12345650 12 0-1 03 30 -3 输出样例： 14.24 题目分析：浮点数的比较，由于在计算机中浮点数不能精确表达，学过计算机组成原理的同学应该知道，在比较两个浮点数字的时候，需要设置一个精度来描述它们之间的大小关系。AC代码： 12345678910111213141516#include &lt;cmath&gt;#include &lt;cstdio&gt;const double eps&#x3D;1e-8;int main()&#123; int n, rm, im; double tmp, max &#x3D; 0; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d %d&quot;, &amp;rm, &amp;im); tmp &#x3D; sqrt(rm*rm + im*im); if(tmp-max &gt; eps)max&#x3D;tmp; &#125; printf(&quot;%.2f\\n&quot;,max); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1029.旧键盘（20）","slug":"PAT（乙级）1029.旧键盘（20）","date":"2019-03-28T03:31:04.000Z","updated":"2020-11-29T19:35:23.083Z","comments":true,"path":"2019/03/28/PAT（乙级）1029.旧键盘（20）/","link":"","permalink":"http://example.com/2019/03/28/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891029.%E6%97%A7%E9%94%AE%E7%9B%98%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1029.旧键盘（20） 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。输入格式：输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。 输出格式：按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 输入样例： 127_This_is_a_test_hs_s_a_es 输出样例： 17TI 题目分析：首先使用一个hash数组标记实际被输入的文字，再用应该被输入的字符串检查哪些不能被输出的字符。由于不能被输出的字符也可能重复，因此还需要一个hash数组标记，确保每个坏键只被输出一次。PAT乙级多次出现hash数组的使用，希望大家可以多多使用，知道完全理解。AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int max_n &#x3D; 128;bool is_appear[max_n] &#x3D; &#123;false&#125;;bool is_output[max_n] &#x3D; &#123;false&#125;;int main()&#123; string s, t; getline(cin, s); getline(cin, t); for(int i&#x3D;0; i&lt;t.length(); ++i)&#123; is_appear[t[i]] &#x3D; true; &#125; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(isalpha(s[i]) &amp;&amp; is_appear[s[i]]&#x3D;&#x3D;false)&#123; if(islower(s[i]))&#123; if(!is_output[s[i]-32])&#123; cout&lt;&lt;(char)(s[i]-32); is_output[s[i]-32] &#x3D; true; &#125; &#125; else&#123; if(!is_output[s[i]])&#123; cout&lt;&lt;s[i]; is_output[s[i]] &#x3D; true; &#125; &#125; &#125; else&#123; if(!is_appear[s[i]])&#123; if(!is_output[s[i]])&#123; cout&lt;&lt;s[i]; is_output[s[i]] &#x3D; true; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1018.锤子剪刀布（20）","slug":"PAT（乙级）1018.锤子剪刀布（20）","date":"2019-03-28T03:09:15.000Z","updated":"2020-11-29T19:35:23.095Z","comments":true,"path":"2019/03/28/PAT（乙级）1018.锤子剪刀布（20）/","link":"","permalink":"http://example.com/2019/03/28/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891018.%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1018.锤子剪刀布（20）现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。输入格式：输入第 1 行给出正整数 N（≤10^​5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例： 123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例： 1235 3 22 3 5B B 题目分析：hash数组的使用+map的使用，简单的模拟题。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;char, int&gt; mp&#123;&#123;&#39;C&#39;,0&#125;,&#123;&#39;J&#39;,1&#125;,&#123;&#39;B&#39;,2&#125;&#125;;map&lt;int, char&gt; mp1&#123;&#123;0,&#39;C&#39;&#125;,&#123;1,&#39;J&#39;&#125;,&#123;2,&#39;B&#39;&#125;&#125;;int arr[3] &#x3D; &#123;0&#125;;int brr[3] &#x3D; &#123;0&#125;;int awin&#x3D;0,bwin&#x3D;0,pin&#x3D;0,alose&#x3D;0,blose&#x3D;0;bool cmp(int a, int b)&#123;return a&gt;b;&#125;void print(int a)&#123;cout&lt;&lt;a&lt;&lt;&quot; &quot;;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n; char a,b; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;a&gt;&gt;b; if((a&#x3D;&#x3D;&#39;C&#39;&amp;&amp;b&#x3D;&#x3D;&#39;J&#39;) || (a&#x3D;&#x3D;&#39;J&#39;&amp;&amp;b&#x3D;&#x3D;&#39;B&#39;) || (a&#x3D;&#x3D;&#39;B&#39;&amp;&amp;b&#x3D;&#x3D;&#39;C&#39;))&#123; awin ++; blose ++; arr[mp[a]] ++; &#125; else if((b&#x3D;&#x3D;&#39;C&#39;&amp;&amp;a&#x3D;&#x3D;&#39;J&#39;) || (b&#x3D;&#x3D;&#39;J&#39;&amp;&amp;a&#x3D;&#x3D;&#39;B&#39;) || (b&#x3D;&#x3D;&#39;B&#39;&amp;&amp;a&#x3D;&#x3D;&#39;C&#39;))&#123; bwin ++; alose ++; brr[mp[b]] ++; &#125; else&#123; pin ++; &#125; &#125; cout&lt;&lt;awin&lt;&lt;&quot; &quot;&lt;&lt;pin&lt;&lt;&quot; &quot;&lt;&lt;alose&lt;&lt;endl; cout&lt;&lt;bwin&lt;&lt;&quot; &quot;&lt;&lt;pin&lt;&lt;&quot; &quot;&lt;&lt;blose&lt;&lt;endl; int arr_max &#x3D; *max_element(arr, arr+3); int brr_max &#x3D; *max_element(brr, brr+3); vector&lt;char&gt; va, vb; for(int i&#x3D;0; i&lt;3; ++i)&#123; if(arr[i]&#x3D;&#x3D;arr_max)&#123; va.push_back(mp1[i]); &#125; &#125; for(int i&#x3D;0; i&lt;3; ++i)&#123; if(brr[i]&#x3D;&#x3D;brr_max) vb.push_back(mp1[i]); &#125; sort(va.begin(), va.end()); sort(vb.begin(), vb.end()); cout&lt;&lt;va[0]&lt;&lt;&quot; &quot;&lt;&lt;vb[0]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1090.危险品装箱（25）","slug":"PAT（乙级）1090.危险品装箱（25）","date":"2019-03-27T13:36:37.000Z","updated":"2020-11-29T19:35:23.095Z","comments":true,"path":"2019/03/27/PAT（乙级）1090.危险品装箱（25）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891090.%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1090.危险品装箱（25） 集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。 本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式：输入第一行给出两个正整数：N (≤10^4) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： 1K G[1] G[2] ... G[K] 其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式：对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例： 123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例： 123NoYesYes 题目分析：此题与乙级1065(单身狗)如出一辙，解题思想完全一致，甚至还要更简单，只是换了一个题目背景而已。1065传送门。 AC代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; mp;const int max_n &#x3D; 100100;bool is_appear[max_n] &#x3D; &#123;false&#125;;int main()&#123; int n, m, a, b; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d%d&quot;, &amp;a,&amp;b); mp.insert(make_pair(a,b)); &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; fill(is_appear, is_appear+max_n, false); int num,tmp; scanf(&quot;%d&quot;, &amp;num); for(int j&#x3D;0; j&lt;num; ++j)&#123; scanf(&quot;%d&quot;, &amp;tmp); is_appear[tmp] &#x3D; true; &#125; bool flag &#x3D; false; for(auto it&#x3D;mp.begin(); it!&#x3D;mp.end(); ++it)&#123; if(is_appear[it-&gt;first] &amp;&amp; is_appear[it-&gt;second])&#123; flag &#x3D; true; &#125; &#125; if(flag) printf(&quot;No\\n&quot;); else printf(&quot;Yes\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1059.C语言竞赛（20）","slug":"PAT（乙级）1059.C语言竞赛（20）","date":"2019-03-27T13:15:11.000Z","updated":"2020-11-29T19:35:23.111Z","comments":true,"path":"2019/03/27/PAT（乙级）1059.C语言竞赛（20）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891059.C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1059.C语言竞赛（20） C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽：0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！2、其他人将得到巧克力。给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式：输入第一行给出一个正整数 N（≤10^4），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式：对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例： 123456789101112131461111666688881234555500016888800011111222288882222 输出样例： 1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 题目分析：读取时用map表将学生ID和对应名次作为映射方便后续的查找使用，ID-&gt;名次。查询时，将查询过的ID在查询hash数组中标记为true，这样就可以检测重复查找，如果在map表中未存储此ID的信息，则说明此学生未参加比赛。最后注意输出的格式为%04d。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; mp;const int max_n &#x3D; 10010;bool is_appear[max_n] &#x3D; &#123;false&#125;;bool is_prime(int n)&#123; if(n&lt;&#x3D;1)return false; for(int i&#x3D;2; i&lt;&#x3D;sqrt(1.0*n); ++i)&#123; if(n%i&#x3D;&#x3D;0)return false; &#125; return true;&#125;int main()&#123; int n, m, tmp; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;tmp); mp.insert(make_pair(tmp, i)); &#125; scanf(&quot;%d&quot;, &amp;m); for(int query&#x3D;0; query&lt;m; ++query)&#123; scanf(&quot;%d&quot;, &amp;tmp); if(mp.find(tmp)&#x3D;&#x3D;mp.end())&#123; printf(&quot;%04d: Are you kidding?\\n&quot;, tmp); continue; &#125; if(is_appear[tmp])&#123; printf(&quot;%04d: Checked\\n&quot;,tmp); continue; &#125; else if(mp[tmp]&#x3D;&#x3D;1)&#123; printf(&quot;%04d: Mystery Award\\n&quot;, tmp); is_appear[tmp] &#x3D; true; &#125; else if(is_prime(mp[tmp]))&#123; printf(&quot;%04d: Minion\\n&quot;, tmp); is_appear[tmp] &#x3D; true; &#125; else&#123; printf(&quot;%04d: Chocolate\\n&quot;, tmp); is_appear[tmp] &#x3D; true; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1065.单身狗（25）","slug":"PAT（乙级）1065.单身狗（25）","date":"2019-03-27T12:37:45.000Z","updated":"2020-11-29T19:35:23.079Z","comments":true,"path":"2019/03/27/PAT（乙级）1065.单身狗（25）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891065.%E5%8D%95%E8%BA%AB%E7%8B%97%EF%BC%8825%EF%BC%89/","excerpt":"","text":"PAT 1065.单身狗 （25） “单身狗”:是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式：输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式：首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 输入样例： 123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例： 12510000 23333 44444 55555 88888 题目分析：读取夫妻/伴侣使用map存储方便之后使用。读取查询的ID时首先使用hash数组标记出现此人，之后遍历map表，如果夫妻/伴侣两个人同时出现在hash数组中，说明这两人不是单身狗，随后标记为false。最后遍历单身狗hash数组，将值为true对应的下标即单身狗ID存储到vector中，对vector排序后输出即可。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int max_n &#x3D; 100010;bool is_appear[max_n] &#x3D; &#123;false&#125;;map&lt;int, int&gt; mp;vector&lt;int&gt; v;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n, a, b; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d%d&quot;, &amp;a,&amp;b); mp.insert(make_pair(a,b)); &#125; int m, tmp; scanf(&quot;%d&quot;, &amp;m); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d&quot;, &amp;tmp); is_appear[tmp] &#x3D; true; &#125; for(auto it&#x3D;mp.begin(); it!&#x3D;mp.end(); ++it)&#123; if(is_appear[it-&gt;first] &amp;&amp; is_appear[it-&gt;second])&#123; is_appear[it-&gt;first] &#x3D; false; is_appear[it-&gt;second] &#x3D; false; &#125; &#125; for(int i&#x3D;0; i&lt;max_n; ++i)&#123; if(is_appear[i]&#x3D;&#x3D;true) v.push_back(i); &#125; sort(v.begin(), v.end()); printf(&quot;%d\\n&quot;, v.size()); for(int i&#x3D;0; i&lt;v.size(); ++i)&#123; printf(&quot;%05d&quot;, v[i]); if(i!&#x3D;v.size()-1)printf(&quot; &quot;); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1033.旧键盘打字（20）","slug":"PAT（乙级）1033.旧键盘打字（20）","date":"2019-03-27T07:47:53.000Z","updated":"2020-11-29T19:35:23.407Z","comments":true,"path":"2019/03/27/PAT（乙级）1033.旧键盘打字（20）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891033.%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1033.旧键盘打字（20） 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5 个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。注意：如果上档键坏掉了，那么大写的英文字母无法被打出。。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例： 127+IE.7_This_is_a_test. 输出样例： 1_hs_s_a_tst 题目分析：输入的字符串可能包含空格。所以还是使用getline()进行字符串的读入，这是一个坑请注意。使用hash数组标记坏掉的键。 两个非常有用的技巧，在字符串处理中。 1234561.判断是否为大写字母bool isupper(char c)2.判断是否为小写字母bool islower(char c);3.小写字母转换为大写字母toupper(char c); AC代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int max_n &#x3D; 128;bool is_appear[max_n] &#x3D; &#123;false&#125;;int main()&#123; string s, t; getline(cin, s); for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; is_appear[s[i]] &#x3D; true; &#125; getline(cin, t); for(int i&#x3D;0; i&lt;t.length(); ++i)&#123; if(isupper(t[i]) &amp;&amp; is_appear[&#39;+&#39;])continue; else if(is_appear[toupper(t[i])])continue; else printf(&quot;%c&quot;, t[i]); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1057.数零壹（20）","slug":"PAT（乙级）1057.数零壹（20）","date":"2019-03-27T03:30:06.000Z","updated":"2020-11-29T19:35:23.111Z","comments":true,"path":"2019/03/27/PAT（乙级）1057.数零壹（20）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891057.%E6%95%B0%E9%9B%B6%E5%A3%B9%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1057.数零壹（20） 给定一串长度不超过 10​^5 的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。 输入格式：输入在一行中给出长度不超过 10^5、以回车结束的字符串。 输出格式：在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。 输入样例： 1PAT (Basic) 输出样例： 13 4 题目分析：因为输入的字符串可能包含空格。所以还是使用getline()进行字符串的读入。为了简化大小写，统一将大写字符转换为小写。关于数字对应的二进制数字包含0和1的个数，参考下边代码，其实和求一个数字二进制数中1的个数的思路是一致的。同时在使用hash数组标记个数即可。 AC代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int bit[2] &#x3D; &#123;0&#125;;void to_lower(string&amp; s)&#123; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(s[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;s[i]&lt;&#x3D;&#39;Z&#39;) s[i] +&#x3D; 32; &#125;&#125;int main()&#123; string s; getline(cin, s); to_lower(s); int sum &#x3D; 0; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if((s[i]&gt;&#x3D;&#39;a&#39; &amp;&amp; s[i]&lt;&#x3D;&#39;z&#39;))&#123; sum +&#x3D; (s[i]-96); &#125; &#125; while(sum &gt; 0)&#123; bit[sum&amp;1] ++; sum &gt;&gt;&#x3D; 1; &#125; printf(&quot;%d %d&quot;,bit[0], bit[1]); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1072.开学寄语（20）","slug":"PAT（乙级）1072.开学寄语（20）","date":"2019-03-27T01:16:59.000Z","updated":"2020-11-29T19:35:23.111Z","comments":true,"path":"2019/03/27/PAT（乙级）1072.开学寄语（20）/","link":"","permalink":"http://example.com/2019/03/27/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891072.%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1072.开学寄语（20） 下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 输入格式：输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 输出格式：顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：姓名缩写: 物品编号1 物品编号2 ……最后一行输出存在问题的学生的总人数和被查缴物品的总数。 输入样例： 1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 输出样例： 1234U: 6666 6666GG: 2333JJ: 6666 23333 5 题目分析：数组hash的应用，使用一个bool数组标记要被收缴物品的编号，在处理每一位同学的物品时，只需要查看对应下标所对应的数组值是否为true，总体来讲是一个常规的简单题。 注意：编号的输出格式为”%04d”,我第一次按照”%d”输出的就有一个测试点没通过。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int max_n &#x3D; 10010;bool is_appear[max_n] &#x3D; &#123;false&#125;;int main()&#123; int n, m, good; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i&#x3D;0; i&lt;m; ++i)&#123; scanf(&quot;%d&quot;, &amp;good); is_appear[good] &#x3D; true; &#125; int num, peo_sum&#x3D;0, goods_sum&#x3D;0; string name, record; vector&lt;int&gt; v; for(int i&#x3D;0; i&lt;n; ++i)&#123; bool flag &#x3D; false; cin&gt;&gt;name&gt;&gt;num; for(int j&#x3D;0; j&lt;num; ++j)&#123; scanf(&quot;%d&quot;, &amp;good); if(is_appear[good]&#x3D;&#x3D;true)&#123; record &#x3D; name; flag &#x3D; true; goods_sum ++; v.push_back(good); &#125; &#125; if(flag)&#123; peo_sum ++; cout&lt;&lt;record&lt;&lt;&quot;: &quot;; for(int i&#x3D;0; i&lt;v.size(); ++i)&#123; printf(&quot;%04d&quot;, v[i]);&#x2F;&#x2F;输出格式%04d if(i!&#x3D;v.size()-1)&#123; printf(&quot; &quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; v.clear(); &#125; printf(&quot;%d %d\\n&quot;, peo_sum, goods_sum); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1064.朋友数（20）","slug":"PAT（乙级）1064.朋友数（20）","date":"2019-03-26T14:34:34.000Z","updated":"2020-11-29T19:35:23.083Z","comments":true,"path":"2019/03/26/PAT（乙级）1064.朋友数（20）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891064.%E6%9C%8B%E5%8F%8B%E6%95%B0%EF%BC%8820%EF%BC%89/","excerpt":"","text":"PAT 1064.朋友数（20） 如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。 输入格式：输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 10^​4 。 输出格式：首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。 输入样例： 128123 899 51 998 27 33 36 12 输出样例： 1243 6 9 26 题目分析：数字处理+set去重。 AC代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; s;void check(int p)&#123; int sum &#x3D; 0; while(p!&#x3D;0)&#123; sum +&#x3D; p%10; p &#x2F;&#x3D; 10; &#125; s.insert(sum);&#125;int main()&#123; int n, num; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;num); check(num); &#125; cout&lt;&lt;s.size()&lt;&lt;endl; int cnt &#x3D; 0; for(auto it&#x3D;s.begin();it!&#x3D;s.end(); ++it)&#123; cout&lt;&lt;*it; cnt ++; if(cnt!&#x3D;s.size()) cout&lt;&lt;&quot; &quot;; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1031.查验身份证（15）","slug":"PAT（乙级）1031.查验身份证（15）","date":"2019-03-26T13:45:10.000Z","updated":"2020-11-29T19:35:23.055Z","comments":true,"path":"2019/03/26/PAT（乙级）1031.查验身份证（15）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891031.%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%EF%BC%8815%EF%BC%89/","excerpt":"","text":"PAT 1031.查验身份证（15） 一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1： 12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1： 12312010X19890101123411010819671130186637070419881216001X 输入样例2： 1232320124198808240056110108196711301862 输出样例2： 1All passed 题目分析：字符串处理。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;const int mod &#x3D; 11;map&lt;int, char&gt; mp&#123;&#123;0,&#39;1&#39;&#125;, &#123;1,&#39;0&#39;&#125;,&#123;2,&#39;X&#39;&#125;,&#123;3,&#39;9&#39;&#125;, &#123;4,&#39;8&#39;&#125;,&#123;5,&#39;7&#39;&#125;,&#123;6,&#39;6&#39;&#125;,&#123;7,&#39;5&#39;&#125;,&#123;8,&#39;4&#39;&#125;,&#123;9,&#39;3&#39;&#125;,&#123;10,&#39;2&#39;&#125;&#125;;int w[] &#x3D; &#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;bool check(const string&amp; s)&#123; int sum &#x3D; 0; for(int i&#x3D;0; i&lt;s.length()-1; ++i)&#123; if(s[i]&lt;&#39;0&#39; || s[i]&gt;&#39;9&#39;)return false; else&#123; sum +&#x3D; (s[i]-&#39;0&#39;)*w[i]; &#125; &#125; int ans &#x3D; sum%mod; if(mp[ans]&#x3D;&#x3D;s[s.length()-1]) return true; else return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); string s; bool flag &#x3D; false; getchar(); for(int i&#x3D;0; i&lt;n; ++i)&#123; getline(cin, s); if(false&#x3D;&#x3D;check(s))&#123; flag &#x3D; true; cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; if(flag&#x3D;&#x3D;false)cout&lt;&lt;&quot;All passed&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1077.互评成绩计算（20）","slug":"PAT（乙级）1077.互评成绩计算（20）","date":"2019-03-26T12:45:50.000Z","updated":"2020-11-29T19:35:23.739Z","comments":true,"path":"2019/03/26/PAT（乙级）1077.互评成绩计算（20）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891077.%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97%EF%BC%8820%EF%BC%89/","excerpt":"","text":"1077.互评成绩计算（20） 在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 G1；老师给这个组的评分记为 G​2。该组得分为 (G1 +G​2 )/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩 输入格式：输入第一行给出两个正整数 N（&gt; 3）和 M，分别是分组数和满分，均不超过 100。随后 N 行，每行给出该组得到的 N 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 N−1 个是其他组给的评分。合法的输入应该是 [0,M] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。 输出格式：为每个组输出其最终得分。每个得分占一行。 输入样例： 12345676 5042 49 49 35 38 4136 51 50 28 -1 3040 36 41 33 47 4930 250 -25 27 45 3148 0 0 50 50 123443 41 36 29 42 29 输出样例： 123456423341313739 题目分析：简单模拟+四舍五入操作。 AC代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;using namespace std;vector&lt;int&gt; vec;int main()&#123; int n, m, tmp; double g1, g2; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i&#x3D;0; i&lt;n; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; scanf(&quot;%d&quot;, &amp;tmp); if(j&#x3D;&#x3D;0)g2 &#x3D; tmp; else&#123; if(tmp&gt;&#x3D;0 &amp;&amp; tmp&lt;&#x3D;m)&#123; vec.push_back(tmp); &#125; &#125; &#125; auto max_it &#x3D; max_element(vec.begin(), vec.end()); auto min_it &#x3D; min_element(vec.begin(), vec.end()); double sum &#x3D; accumulate(vec.begin(), vec.end(), 0); g1 &#x3D; (sum - *max_it - *min_it) * 1.0 &#x2F; (vec.size() - 2); int ans &#x3D; (int)(((g1+g2)&#x2F;2.0)+0.5); cout&lt;&lt;ans&lt;&lt;endl; vec.clear(); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1036.跟奥巴马一起编程（15）","slug":"PAT（乙级）1036.跟奥巴马一起编程（15）","date":"2019-03-26T10:42:08.000Z","updated":"2020-11-29T19:35:23.947Z","comments":true,"path":"2019/03/26/PAT（乙级）1036.跟奥巴马一起编程（15）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891036.%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B%EF%BC%8815%EF%BC%89/","excerpt":"","text":"1036.跟奥巴马一起编程（15） 美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式：输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例： 110 a 输出样例： 12345aaaaaaaaaaa aa aa aaaaaaaaaaa 题目分析：模拟+简单的四舍五入操作。 12int a;int b &#x3D; (int)(x&#x2F;2.0+0.5); &#x2F;&#x2F;四舍五入 AC代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int col; char c; cin&gt;&gt;col&gt;&gt;c; int row &#x3D; (int)(col&#x2F;2.0+0.5); for(int i&#x3D;0; i&lt;row; ++i)&#123; if(i&#x3D;&#x3D;0 || i&#x3D;&#x3D;row-1)&#123; for(int j&#x3D;0; j&lt;col; ++j)&#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); &#125; else&#123; printf(&quot;%c&quot;,c); for(int k&#x3D;1; k&lt;col-1; ++k)printf(&quot; &quot;); printf(&quot;%c&quot;,c); cout&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1056.组合数的和（15）","slug":"PAT（乙级）1056.组合数的和（15）","date":"2019-03-26T08:02:01.000Z","updated":"2020-11-29T19:35:23.647Z","comments":true,"path":"2019/03/26/PAT（乙级）1056.组合数的和（15）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891056.%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C%EF%BC%8815%EF%BC%89/","excerpt":"","text":"PAT（乙级）1056.组合数的和（15） 给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。 输入格式：输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。 输出格式：输出所有可能组合出来的2位数字的和。 输入样例： 13 2 8 5 输出样例： 1330 题目分析：水题，直接给代码。 AC代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int max_n &#x3D; 20;int arr[max_n];int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; int sum &#x3D; 0; for(int i&#x3D;0; i&lt;n; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; if(j!&#x3D;i)&#123; sum +&#x3D; arr[i]*10+arr[j]; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1076.Wifi密码（15）","slug":"PAT（乙级）1076.Wifi密码（15）","date":"2019-03-26T07:53:02.000Z","updated":"2020-11-29T19:35:23.631Z","comments":true,"path":"2019/03/26/PAT（乙级）1076.Wifi密码（15）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891076.Wifi%E5%AF%86%E7%A0%81%EF%BC%8815%EF%BC%89/","excerpt":"","text":"1076.Wifi密码（15） 下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。 输入格式：输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 编号-答案 的格式给出一道题的 4 个选项，T 表示正确选项，F 表示错误选项。选项间用空格分隔。 输出格式：在一行中输出 wifi 密码。 输入样例： 12345678910Correct%pw 38A-T B-F C-F D-FC-T B-F A-F D-FA-F D-F C-F B-TB-T A-F C-F D-FB-F D-T A-F C-FA-T C-F B-F D-FD-T B-F C-F A-FC-T A-F B-F D-F 输出样例： 113224143 题目分析：简单模拟处理，记住最好不要把每一行的输入当作字符来处理，否则在输入读取的处理会非常的麻烦。还是推荐使用getline()函数将每行输入当作一个字符串来处理，不仅可以加速编程，同时能也非常高效的读取字符串。 AC代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;char, int&gt; mp&#123;&#123;&#39;A&#39;,1&#125;, &#123;&#39;B&#39;,2&#125;, &#123;&#39;C&#39;,3&#125;, &#123;&#39;D&#39;,4&#125;&#125;;vector&lt;int&gt; vec;void print(int a)&#123;cout&lt;&lt;a;&#125;void check(const string&amp; s)&#123; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(s[i]&#x3D;&#x3D;&#39;T&#39;) vec.push_back(mp[s[i-2]]); &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); string str; getchar(); for(int i&#x3D;0; i&lt;n; ++i)&#123; getline(cin, str); check(str); &#125; for_each(vec.begin(), vec.end(), print); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1067.试密码(20)","slug":"PAT（乙级）1067.试密码(20)","date":"2019-03-26T07:15:16.000Z","updated":"2020-11-29T19:35:23.647Z","comments":true,"path":"2019/03/26/PAT（乙级）1067.试密码(20)/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891067.%E8%AF%95%E5%AF%86%E7%A0%81(20)/","excerpt":"","text":"1067.试密码(20) 当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式：输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式：对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例1： 123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例1： 1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例2： 123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例2： 123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 题目分析：是一个简单的字符串处理。但是需要注意一些问题，题目要求的是长度不超过 20 的、不包含空格、Tab、回车的非空字符串，但实际上可能在输入有不正确的格式被正确的处理了。如样例2的第四个输入，try again，注意scanf不能读取到空格，处理字符串时可以使用getline()获取整个字符串包含空格。 AC代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int main()&#123; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); string origin, test; int n; cin&gt;&gt;origin&gt;&gt;n; getchar(); int cnt &#x3D; 0; while(n--)&#123; getline(cin, test); if(test.length()&#x3D;&#x3D;1 &amp;&amp; test[0]&#x3D;&#x3D;&#39;#&#39;) return 0; if(test&#x3D;&#x3D;origin)&#123; cout&lt;&lt;&quot;Welcome in&quot;&lt;&lt;endl; return 0; &#125; else&#123; cout&lt;&lt;&quot;Wrong password: &quot;&lt;&lt;test&lt;&lt;endl; &#125; &#125; cout&lt;&lt;&quot;Account locked&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1066.图像过滤（15）","slug":"PAT（乙级）1066.图像过滤（15）","date":"2019-03-26T03:21:47.000Z","updated":"2020-11-29T19:35:23.643Z","comments":true,"path":"2019/03/26/PAT（乙级）1066.图像过滤（15）/","link":"","permalink":"http://example.com/2019/03/26/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891066.%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4%EF%BC%8815%EF%BC%89/","excerpt":"","text":"1066.图像过滤（15） 图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式：输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 输出格式：输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例： 12343 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例： 123003 189 254 000 000000 233 151 099 000088 000 000 000 255 题目分析，简单题。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int max_n &#x3D; 510;int vec[max_n][max_n];int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int m, n, a, b, p, tmp; scanf(&quot;%d%d%d%d%d&quot;, &amp;m, &amp;n, &amp;a, &amp;b, &amp;p); for(int i&#x3D;0; i&lt;m; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; scanf(&quot;%d&quot;, &amp;tmp); vec[i][j] &#x3D; tmp; &#125; &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; if(a&lt;&#x3D;vec[i][j] &amp;&amp; b&gt;&#x3D;vec[i][j]) vec[i][j] &#x3D; p; &#125; &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; for(int j&#x3D;0; j&lt;n; ++j)&#123; if(vec[i][j]&#x3D;&#x3D;0) cout&lt;&lt;&quot;000&quot;; else if(0&lt;vec[i][j] &amp;&amp; vec[i][j]&lt;&#x3D;9) cout&lt;&lt;&quot;00&quot;&lt;&lt;vec[i][j]; else if(10&lt;vec[i][j] &amp;&amp; vec[i][j]&lt;&#x3D;99) cout&lt;&lt;&quot;0&quot;&lt;&lt;vec[i][j]; else cout&lt;&lt;vec[i][j]; if(j!&#x3D;n-1)cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1071.小赌怡情（15）","slug":"PAT（乙级）1071.小赌怡情（15）","date":"2019-03-22T01:35:47.000Z","updated":"2020-11-29T19:35:23.963Z","comments":true,"path":"2019/03/22/PAT（乙级）1071.小赌怡情（15）/","link":"","permalink":"http://example.com/2019/03/22/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891071.%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85%EF%BC%8815%EF%BC%89/","excerpt":"","text":"1071.小赌怡情（15） 常言道”小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式：输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：n1 b t n2其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为0表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式：对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）：玩家赢，输出 Win t! Total = x.；玩家输，输出 Lose t. Total = x.；玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.；玩家输光后，输出 Game Over. 并结束程序。 输入样例1： 12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例1： 1234Win 100! Total &#x3D; 200.Lose 50. Total &#x3D; 150.Not enough tokens. Total &#x3D; 150.Not enough tokens. Total &#x3D; 150. 输入样例2： 12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例2： 123Win 100! Total &#x3D; 200.Lose 200. Total &#x3D; 0.Game Over. 分析：简单模拟 AC代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int sum_money;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n; scanf(&quot;%d %d&quot;, &amp;sum_money, &amp;n); int n1, b, t, n2; for(int i&#x3D;0; i&lt;n; ++i)&#123; scanf(&quot;%d%d%d%d&quot;, &amp;n1, &amp;b, &amp;t, &amp;n2); if(sum_money&#x3D;&#x3D;0)&#123; printf(&quot;Game Over.\\n&quot;); break; &#125; if(t &gt; sum_money)&#123; printf(&quot;Not enough tokens. Total &#x3D; %d.\\n&quot;, sum_money); continue; &#125; if(n2&lt;n1 &amp;&amp; b&#x3D;&#x3D;0)&#123; sum_money +&#x3D; t; printf(&quot;Win %d! Total &#x3D; %d.\\n&quot;,t, sum_money); &#125; else if(n2&gt;n1 &amp;&amp; b&#x3D;&#x3D;1)&#123; sum_money +&#x3D; t; printf(&quot;Win %d! Total &#x3D; %d.\\n&quot;,t, sum_money); &#125; else&#123; sum_money -&#x3D; t; printf(&quot;Lose %d. Total &#x3D; %d.\\n&quot;,t, sum_money); &#125; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1042.统计字符（20）","slug":"PAT（乙级）1042.统计字符（20）","date":"2019-03-21T14:07:52.000Z","updated":"2020-11-29T19:35:23.639Z","comments":true,"path":"2019/03/21/PAT（乙级）1042.统计字符（20）/","link":"","permalink":"http://example.com/2019/03/21/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891042.%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%EF%BC%8820%EF%BC%89/","excerpt":"","text":"1042.统计字符（20） 请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 输入样例： 1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例：e 7 题目分析：排序+数组hash使用+读取带空格字符串等技术 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int max_n &#x3D; 130;int arr[max_n];struct node&#123; char c; int cnt; node(char c, int cnt)&#123; this-&gt;c &#x3D; c; this-&gt;cnt &#x3D; cnt; &#125;&#125;;vector&lt;node&gt; vec;bool cmp(node a, node b)&#123; if(a.cnt!&#x3D;b.cnt) return a.cnt &gt; b.cnt; else return a.c &lt; b.c;&#125;void transform(string&amp; s)&#123; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if(s[i]&gt;&#x3D;&#39;A&#39; &amp;&amp; s[i]&lt;&#x3D;&#39;Z&#39;) s[i] +&#x3D; 32; &#125;&#125;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); fill(arr, arr+max_n, 0); string s; getline(cin, s); transform(s); for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; if( (s[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;s[i]&lt;&#x3D;&#39;z&#39;))&#123; arr[(int)s[i]] ++; &#125; &#125; for(int i&#x3D;0; i&lt;max_n; ++i)&#123; if(arr[i]!&#x3D;0)&#123; vec.push_back(node(i, arr[i])); &#125; &#125; sort(vec.begin(), vec.end(), cmp); printf(&quot;%c %d\\n&quot;, vec[0].c, vec[0].cnt); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1080. MOOC期终成绩（25）","slug":"PAT（乙级）1080. MOOC期终成绩（25）","date":"2019-03-21T13:37:37.000Z","updated":"2020-11-29T19:35:23.635Z","comments":true,"path":"2019/03/21/PAT（乙级）1080. MOOC期终成绩（25）/","link":"","permalink":"http://example.com/2019/03/21/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891080.%20MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9%EF%BC%8825%EF%BC%89/","excerpt":"","text":"1083.是否存在相等的差 对于在中国大学MOOC（http://www.icourse163.org/ ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(Gmid−term×40%+G​final×60%)，如果 G​mid−term&gt;G​final;否则总评 G 就是 G​final。这里 G​mid−term 和 G​final分别为学生的期中和期末成绩。现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。 输入格式：输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。接下来有三块输入。第一块包含 P 个在线编程成绩 G​p；第二块包含 M 个期中考试成绩 Gmid−term；第三块包含 N 个期末考试成绩 G​final​​ 。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。 输出格式：打印出获得合格证书的学生名单。每个学生占一行，格式为：学生学号 G​p G​mid−term G​final G如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出−1。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。 题目分析：使用map存储学生的在线编程成绩，期中成绩以及期末成绩。由于有同学可能只参加部分考试，需要一个set保存所有参与课程同学的姓名，方便后边使用。读入数据后，将满足条件的学生信息存储到vector中， 条件:if(gp&gt;=200 &amp;&amp; G&gt;=60)。这里涉及到一个变成小技巧四舍五入。之后按照输出条件对vector排序即可。 四舍五入： 123int a;double b &#x3D; (int)(a+0.5);cout&lt;&lt;b&lt;&lt;endl; 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Stu&#123; string name; int gp, gmid, gfinal, G; Stu(string name, int gp, int gmid, int gfinal, int G)&#123; this-&gt;name &#x3D; name; this-&gt;gp &#x3D; gp; this-&gt;gmid &#x3D; gmid; this-&gt;gfinal &#x3D; gfinal; this-&gt;G &#x3D; G; &#125;&#125;;bool cmp(Stu a, Stu b)&#123; if(a.G !&#x3D; b.G) return a.G &gt; b.G; else return a.name &lt; b.name;&#125;set&lt;string&gt; st;vector&lt;Stu&gt; vec;unordered_map&lt;string, int&gt; gp;unordered_map&lt;string, int&gt; gmid;unordered_map&lt;string, int&gt; gfinal;int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); string id; int p, m, n, score; scanf(&quot;%d%d%d&quot;, &amp;p, &amp;m, &amp;n); for(int i&#x3D;0; i&lt;p; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gp[id] &#x3D; score; &#125; for(int i&#x3D;0; i&lt;m; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gmid[id] &#x3D; score; &#125; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;id; st.insert(id); scanf(&quot;%d&quot;, &amp;score); gfinal[id] &#x3D; score; &#125; int Gp, Gmid, Gfinal; for(auto it&#x3D;st.begin(); it!&#x3D;st.end(); ++it)&#123; if(gp.find(*it)!&#x3D;gp.end()) Gp &#x3D; gp[*it]; else Gp &#x3D; -1; if(gmid.find(*it)!&#x3D;gmid.end()) Gmid &#x3D; gmid[*it]; else Gmid &#x3D; -1; if(gfinal.find(*it)!&#x3D;gfinal.end()) Gfinal &#x3D; gfinal[*it]; else Gfinal &#x3D; -1; double G; if(Gmid &gt; Gfinal) G &#x3D; (int)(Gmid*0.4 + Gfinal*0.6 + 0.5); else G &#x3D; Gfinal; if(Gp&gt;&#x3D;200 &amp;&amp; G&gt;&#x3D;60) vec.push_back(Stu(*it, Gp, Gmid, Gfinal, G)); &#125; sort(vec.begin(), vec.end(), cmp); for(int i&#x3D;0; i&lt;vec.size(); ++i)&#123; cout&lt;&lt;vec[i].name; printf(&quot; %d %d %d %d\\n&quot;, vec[i].gp, vec[i].gmid, vec[i].gfinal, vec[i].G); &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1083.是否存在相等的差（20）","slug":"PAT（乙级）1083.是否存在相等的差（20）","date":"2019-03-21T11:39:40.000Z","updated":"2020-11-29T19:35:23.643Z","comments":true,"path":"2019/03/21/PAT（乙级）1083.是否存在相等的差（20）/","link":"","permalink":"http://example.com/2019/03/21/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891083.%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE%EF%BC%8820%EF%BC%89/","excerpt":"","text":"1083.是否存在相等的差 给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？ 输入格式：输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。 输出格式：按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。 题目分析：简单模拟+数组hash使用 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn &#x3D; 10010;int arr[maxn];struct Pair&#123; int a,b; Pair(int a, int b)&#123; this-&gt;a &#x3D; a; this-&gt;b &#x3D; b; &#125;&#125;;map&lt;int, int&gt; mp;vector&lt;Pair&gt; vec;int main()&#123; fill(arr, arr+maxn, 0); int n; scanf(&quot;%d&quot;, &amp;n); for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123; mp[ max(arr[i],i)-min(arr[i],i) ] ++; &#125; for(auto it&#x3D;mp.begin(); it!&#x3D;mp.end(); ++it)&#123; if(it-&gt;second&gt;1)&#x2F;&#x2F;注意重复必须大于1 vec.push_back(Pair(it-&gt;first, it-&gt;second)); &#125; &#x2F;&#x2F;逆序输出，因为map是从小到大排序，而题目要求的输出格式是从大到小 for(int i&#x3D;vec.size()-1; i&gt;&#x3D;0; --i)&#123; cout&lt;&lt;vec[i].a&lt;&lt;&quot; &quot;&lt;&lt;vec[i].b&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"PAT（乙级）1082.射击比赛（数学题，距离求解）（20）","slug":"PAT（乙级）1082.射击比赛（数学题，距离求解）（20）","date":"2019-03-21T11:35:20.000Z","updated":"2020-11-29T19:35:24.463Z","comments":true,"path":"2019/03/21/PAT（乙级）1082.射击比赛（数学题，距离求解）（20）/","link":"","permalink":"http://example.com/2019/03/21/PAT%EF%BC%88%E4%B9%99%E7%BA%A7%EF%BC%891082.%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B%EF%BC%88%E6%95%B0%E5%AD%A6%E9%A2%98%EF%BC%8C%E8%B7%9D%E7%A6%BB%E6%B1%82%E8%A7%A3%EF%BC%89%EF%BC%8820%EF%BC%89/","excerpt":"","text":"1082.射击比赛 本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 输入格式：输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：D x y其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。 输出格式：输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 题目分析：距离求解+排序 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Person&#123; string name; double distance; Person(string name, double distance)&#123; this-&gt;name &#x3D; name; this-&gt;distance &#x3D; distance; &#125;&#125;;double dis(int x, int y)&#123; double d &#x3D; sqrt(x*x+y*y); return d;&#125;vector&lt;Person&gt; vec;bool cmp(Person a, Person b)&#123; return a.distance &lt; b.distance;&#125;int main()&#123; &#x2F;&#x2F; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n, x, y; scanf(&quot;%d&quot;, &amp;n); string name; for(int i&#x3D;0; i&lt;n; ++i)&#123; cin&gt;&gt;name&gt;&gt;x&gt;&gt;y; vec.push_back(Person(name, dis(x,y))); &#125; sort(vec.begin(), vec.end(), cmp); printf(&quot;%s %s\\n&quot;, vec[0].name.c_str(), vec[vec.size()-1].name.c_str()); return 0;&#125;","categories":[{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"}],"tags":[]},{"title":"归并排序merge函数的两种写法","slug":"归并排序merge函数的两种写法","date":"2019-03-11T13:01:45.000Z","updated":"2020-11-29T19:35:24.215Z","comments":true,"path":"2019/03/11/归并排序merge函数的两种写法/","link":"","permalink":"http://example.com/2019/03/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/","excerpt":"","text":"第一种：将[left, mid，right]划分为left和right两个子闭区间。其中将mid定义为右子区间的第一个元素的下标。代码实现： 1234567891011121314151617181920212223242526template &lt;typename T&gt;void merge(T arr[], int l, int m, int r)&#123; int LEFT_SIZE &#x3D; m-l;&#x2F;&#x2F;左子区间的大小 int RIGHT_SIZE &#x3D; r-m+1;&#x2F;&#x2F;右子区间的大小 &#x2F;&#x2F;动态申请内存，否则数据量太大时，栈会溢出 T* left &#x3D; new T[LEFT_SIZE]; T* right &#x3D; new T[RIGHT_SIZE]; &#x2F;&#x2F;合并两个有序数组的常规操作 int i &#x3D; 0,j &#x3D; 0,k &#x3D; l;&#x2F;&#x2F;注意k的起始下标为l而不是0 while(i&lt;LEFT_SIZE &amp;&amp; j&lt;RIGHT_SIZE)&#123; if(left[i] &lt; right[j])&#123; arr[k ++] &#x3D; left[i ++]; &#125; else&#123; arr[k ++] &#x3D; right[j ++]; &#125; &#125; while(i &lt; LEFT_SIZE)&#123;arr[k ++] &#x3D; left[i ++];&#125; while(j &lt; RIGHT_SIZE)&#123;arr[k ++] &#x3D; right[j ++];&#125; delete[] left; delete[] right;&#125; 第二种：将[left, mid, right]复制到一个数组中，但此时mid是第一子区间的最后一个元素的下标。 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void merge(T arr[], int l, int mid, int r)&#123; T* data &#x3D; new T[r-l+1]; &#x2F;&#x2F;[l..r]是一个闭区间所以申请空间时需加1 for(int i&#x3D;l; i&lt;&#x3D;r; ++i)&#123; data[i-l] &#x3D; arr[i]; &#125; int i&#x3D;l, j&#x3D;mid+1; &#x2F;&#x2F;i和j代表两个子区间的下标 起始位置分别为i&#x3D;l和j&#x3D;mid+1 for(int k&#x3D;l; k&lt;&#x3D;r; ++k)&#123; if(i&gt;mid)&#123; arr[k] &#x3D; data[j-l]; j ++; &#125; else if(j&gt;r)&#123; arr[k] &#x3D; data[i-l]; i ++; &#125; else if(data[i-l] &lt; data[j-l)&#123; arr[k] &#x3D; data[i-l]; i ++; &#125; else&#123; arr[k] &#x3D; data[j-l]; j ++; &#125; &#125; delete[] data;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"python 记录欧几里得算法","slug":"python 记录欧几里得算法","date":"2019-02-22T01:38:31.000Z","updated":"2020-11-29T19:35:24.191Z","comments":true,"path":"2019/02/22/python 记录欧几里得算法/","link":"","permalink":"http://example.com/2019/02/22/python%20%E8%AE%B0%E5%BD%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、递归法 1234567#保证a&gt;bdef gcd(a,b): if b&#x3D;&#x3D;0: return a else: return gcd(b, a%b) 一、递推法 12345678910def gcd(a, b) if a&lt;b: a,b &#x3D; b,a else: while(b &gt; 0): r &#x3D; a%b a &#x3D; b b &#x3D; r return a","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[]},{"title":"2019春招 CVTE C/C++开发岗笔试编程题两道","slug":"2019春招 CVTE C!C++开发岗笔试编程题两道","date":"2019-02-21T13:55:02.000Z","updated":"2020-11-29T19:35:24.191Z","comments":true,"path":"2019/02/21/2019春招 CVTE C!C++开发岗笔试编程题两道/","link":"","permalink":"http://example.com/2019/02/21/2019%E6%98%A5%E6%8B%9B%20CVTE%20C!C++%E5%BC%80%E5%8F%91%E5%B2%97%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%A4%E9%81%93/","excerpt":"","text":"一、题目描述请编写一个函数用于判断输入的int数是否是-2的整数次幂加1 ((-2)^N+1) 测试用例： 12341 2 1205 -7输出正确10 -9输出错误 代码实现： 12345678910111213bool isPowerOfNegativePlusOne(int numbser)&#123; if(n &lt; 0)&#123; n -&#x3D; 1; n &#x3D; -n; &#125; else&#123; n -&#x3D; 1; &#125; if(n &amp; (n-1)&#x3D;&#x3D;0) return true; else return false;&#125; 二、题目描述一个由数字组成的字符串长度为L，判断字符串是否为存在长度为k的区间，在该区间内的数字排序后是连续的（相同数字视为连续），若存在，给出存在几个这样的区间。输入描述：一个长度为L的由数字组成的字符串S，以及数据区间的长度k。 输出描述：满足上述要求区间的个数。 123输出实例： 123456789 2 1345321898 3 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool check(string s)&#123; for(int i&#x3D;0; i&lt;s.length(); ++i)&#123; for(int j&#x3D;i; j&lt;s.length()-1-i; ++j)&#123; if(s[j+1]&#x3D;&#x3D;s[j]+1 || s[j]&#x3D;&#x3D;s[j+1])&#123; continue; &#125; else&#123; return false; &#125; &#125; &#125; return true;&#125; int howManySub(string s, int k)&#123; string t; int cnt &#x3D; 0; for(int i&#x3D;0; i&lt;&#x3D;s.length()-k; ++i)&#123; t &#x3D; s.substr(i,k); sort(t.begin(), t.end()); if(check(t)&#x3D;&#x3D;true)&#123; cnt ++; &#125; &#125; return cnt;&#125;int main()&#123; string s;cin&gt;&gt;s; int k;cin&gt;&gt;k; cout&lt;&lt;howManySub(s,k); return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"linux下使用core文件对程序进行debug","slug":"linux下使用core文件对程序进行debug","date":"2019-01-13T13:16:50.000Z","updated":"2020-11-29T19:35:24.255Z","comments":true,"path":"2019/01/13/linux下使用core文件对程序进行debug/","link":"","permalink":"http://example.com/2019/01/13/linux%E4%B8%8B%E4%BD%BF%E7%94%A8core%E6%96%87%E4%BB%B6%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8Cdebug/","excerpt":"","text":"一.简单介绍什么是core文件以及他的作用在linux编写的C/C++可执行程序往往会出现如下图的错误，一个core dumped。由于刚开始对linux的认识不足，就忽略了这样一个重要的调试信息。随着学习的深入，其实core文件在linux下是一种ELF格式的文件，有关于什么是ELF格式大家可以自行查阅相关的内容。实际上core文件就是可执行文件执行时的映像，也可以叫做内存的快照。保存下来可执行程序在执行过程的点点滴滴。除了内存信息之外，还有些关键的程序运行状态也会同时dump下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core文件对于程序员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而core文件可以再现程序出错时的情景。结合gdb的调试命令可以对core文件进行调试。 二.如何保存core文件。在linux下，默认的情况是core dumped并不产生core文件，因为此项功能默认是被关闭。使用ulimit -c命令可以查看是否启动core文件。执行上述命令后会有如下的三种可能分别代表着不同的意义： 1231.0 不能产生core文件2.unlimited 产生的core文件没有字节限制3.一个确定数字 当超过这个字节数时不能产生core文件，小于等于时可以产生core文件 综上，只需要使用ulimit -c unlimited就可打开core文件了，注意需要在root用户下执行此命令，否则权限不足执行失败。而且这样的设置是一次性的，下次重启后就需要重新设置。一劳永逸的办法就是在配置文件写入上述的设置。此步设置好之后，当你的可执行程序再次出现core dumped的情况时，就会在当前目录下出现一个core文件。如下： 三.设置core文件的生成路径以及core文件的名称格式。（1）设置进程的pid作为core文件扩展名，这样的好处是当core文有很多时，可以区分是哪一个可执行程序产生的core文件，方便查找。 123456781:添加pid作为扩展名，生成的core文件名称为core.pid0:不添加pid作为扩展名，生成的core文件名称为core &#x2F;&#x2F;修改方法1.修改 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid 文件内容为: 12.在终端执行如下两条命令的任意一条echo &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pidsysctl -w kernel.core_uses_pid&#x3D;1 kernel.core_uses_pid &#x3D; 1 (2)修改core文件的文件格式以及保存路径 1234执行如下两条命令中的一条即可1.echo &quot;&#x2F;corefile&#x2F;core-%e-%p-%t&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern标识生成的core文件名格式是 core-%e-%p-%t，保存路径为&#x2F;corefilesysctl -w kernel.core_pattern&#x3D;&#x2F;corefile&#x2F;core-%e-%p-%t kernel.core_pattern &#x3D; &#x2F;corefile&#x2F;core-%e-%p-%t 以下是参数列表: 1234567%p - insert pid into filename 添加pid(进程id)%u - insert current uid into filename 添加当前uid(用户id)%g - insert current gid into filename 添加当前gid(用户组id)%s - insert signal that caused the coredump into the filename 添加导致产生core的信号%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间%h - insert hostname where the coredump happened into filename 添加主机名%e - insert coredumping executable name into filename 添加导致产生core的命令名 三.使用core文件进行简单debug。测试程序一： 123456#include &lt;iostream&gt;using namespace std;int main()&#123; int *p; *p &#x3D; 20;&#x2F;&#x2F;使用野指针&#125; 对于上述这样的一个小程序很容易定位到错误的源头，但是对于一个成百上千行的代码来说定位一个错误就不容易了尤其是在运行之后发生的bug，但是使用core文件却很容易定位。调试上述文件生成的core文件:通过core文件可以清楚的定位到错误的根源，可见core文件的强大之处。测试程序二： 12345678test1.cpp#include &lt;iosreram&gt;using namespace std;int main()&#123; cout&lt;&lt;(10 &#x2F; 0)&lt;&lt;endl; return 0;&#125; 使用test1生成的core文件定位错误：","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"泛型算法：堆算法","slug":"泛型算法：堆算法","date":"2019-01-06T08:01:10.000Z","updated":"2020-11-29T19:35:24.255Z","comments":true,"path":"2019/01/06/泛型算法：堆算法/","link":"","permalink":"http://example.com/2019/01/06/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A0%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"堆算法是泛型算法的一种，通过迭代器搭建泛型算法与容器联系的桥梁。堆算法支持的四个操作：make_heap(),push_heap(),pop_heap()和sort_heap()。 注意：迭代器必须使用支持随机访问的迭代器容器类，否则不能使用该算法。 (1)make_heap在[fisrt,last)左闭右开的区间构建一个堆。 1234567891011121314151617181920#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;2,1,4,7,3,8&#125;; cout&lt;&lt;&quot;make_heap()之前：&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; make_heap(vec.begin(),vec.end()); cout&lt;&lt;&quot;make_heap()之后：&quot; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0;&#125; 执行结果: (2)push_heap()push_heap()在执行前必须向支持随机访问的容器里添加进去一个元素，如vector&lt; T &gt;的push_back()操作。在此之前,[first,last-1)是一个已经做好的堆，添加元素之后，堆[first,last)这个区间做堆，使用push_heap()即可。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;3,5,1,2&#125;; make_heap(vec.bein(), vec.end()); &#x2F;&#x2F;此时vec容器元素之间的关系是一个堆 cout&lt;&lt;&quot;make_heap之后:&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; vec.push_back(4); push_heap(vec.begin(), vec.end()); cout&lt;&lt;&quot;push_heap之后:&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0;&#125; 执行结果: (3)pop_heap()pop_heap()操作并不是真的将堆顶元素从容器中弹出，而是将容器最后一个元素交换到栈顶，进行shiftDown(1)操作，维持堆的性质。之后可以使用back()获取原堆顶元素，或者使用pop_bakc()操作将原堆顶元素从容器中删除。这里堆从操作可以查看这篇博客：二叉堆的实现代码测试： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;4, 1, 3, 2, 5&#125;; make_heap(vec.begin(), vec.end()); cout&lt;&lt;&quot;make_heap之后:&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; pop_heap(vec.begin(), vec.end()); cout&lt;&lt;&quot;pop_heap()之后:&quot; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;vec.back() &#x3D; &quot;&lt;&lt;vec.back(); return 0;&#125; 执行结果: (1)sort_heapsort_heap算法可以对一个堆进行排序，排序之后也就不是一个堆了。但是如果[first,last)本身不是一个堆，这样的sort_heap是没有定义的。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;4, 1, 3, 5, 2&#125;; make_heap(vec.begin(), vec.end()); cout&lt;&lt;&quot;make_heap之后:&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; sort_heap(vec.begin(), vec.end()); cout&lt;&lt;&quot;sort_heap之后:&quot;; for(auto i:vec)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0;&#125; 执行结果:","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"python实现算法：并查集","slug":"python实现算法：并查集","date":"2019-01-05T14:47:37.000Z","updated":"2020-11-29T19:35:24.199Z","comments":true,"path":"2019/01/05/python实现算法：并查集/","link":"","permalink":"http://example.com/2019/01/05/python%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"代码部分： 123456789101112131415161718192021222324class UnionFind(): is_root &#x3D; [] #是否为根 father &#x3D; [] #father[k] &#x3D; value 保存k的父亲节点 def __init__(self， n): #为方便编写，数组下标从1开始，占用列表的零下标 self.isRoot.append(0) self.father.append(True) for i in range(1, n+1): self.is_root.append(False) #初始化不为其他节点的根节点 self.father.append(i) #初始自己为自己的父亲 #递归查找n的父亲节点 def find(self, n): if self.father[n]&#x3D;&#x3D;n: return n else: return self.find(self.father[n]) #合并操作 优化可以使用：路径压缩 def union(self, a, b): Fa &#x3D; self.find(a) Fb &#x3D; self.find(b) if Fa!&#x3D;Fb: self.father[Fa] &#x3D; Fb","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[]},{"title":"python实现算法：输出素数表","slug":"python实现算法：输出素数表","date":"2019-01-04T13:24:13.000Z","updated":"2020-11-29T19:35:24.207Z","comments":true,"path":"2019/01/04/python实现算法：输出素数表/","link":"","permalink":"http://example.com/2019/01/04/python%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E8%BE%93%E5%87%BA%E7%B4%A0%E6%95%B0%E8%A1%A8/","excerpt":"","text":"代码部分：prime.py 123456789101112131415161718192021&#x2F;&#x2F;时间复杂度为O(n)def is_prime(num): if num&lt;&#x3D;1: return False for i in range(2,num): if num%i&#x3D;&#x3D;0: return False return True&#x2F;&#x2F;arr为列表类型，求出1-100之间的素数def find_prime(arr): for i in range(1,101)： if is_prime(i)&#x3D;&#x3D;True: arr.append(i)&#x2F;&#x2F;调用函数执行arr &#x3D; []find_prime(arr)for i in arr: print(i,end&#x3D;&#39; &#39;)print(end&#x3D;&#39;\\n&#39;) 执行结果：","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[]},{"title":"python实现算法：二进制数中1的个数","slug":"python实现算法：二进制数中1的个数","date":"2019-01-03T10:55:33.000Z","updated":"2020-11-29T19:35:24.215Z","comments":true,"path":"2019/01/03/python实现算法：二进制数中1的个数/","link":"","permalink":"http://example.com/2019/01/03/python%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"1234567def count_bit(num): cnt &#x3D; 0 while num&gt;0: if num&amp;1&#x3D;&#x3D;1: cnt +&#x3D; 1 num &gt;&gt;&#x3D; 1 return cnt","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[]},{"title":"python实现算法：全排列算法","slug":"python实现算法：全排列算法","date":"2019-01-03T10:42:25.000Z","updated":"2020-11-29T19:35:24.195Z","comments":true,"path":"2019/01/03/python实现算法：全排列算法/","link":"","permalink":"http://example.com/2019/01/03/python%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"代码部分： 1234567891011121314151617181920212223#test.pydef swap(arr, i, j): tmp &#x3D; arr[i] arr[i] &#x3D; arr[j] arr[j] &#x3D; tmpdef show(arr,n): for i in rang(0,n): print(arr[i],&#39;\\t&#39;,end&#x3D;&#39; &#39;)&#x2F;&#x2F;全排列部分def perm(arr, p, q): if p&#x3D;&#x3D;q: show(arr,q+1) print(&#39;\\n&#39;) for i in range(p, q+1): swap(arr, p, i) perm(arr, p, q+1) swap(arr, p, i)arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]perm(arr, 0, 2) 执行结果：","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[]},{"title":"C++11新特性--lambda表达式","slug":"C++11新特性--lambda表达式","date":"2018-12-31T02:52:49.000Z","updated":"2020-11-29T19:35:24.735Z","comments":true,"path":"2018/12/31/C++11新特性--lambda表达式/","link":"","permalink":"http://example.com/2018/12/31/C++11%E6%96%B0%E7%89%B9%E6%80%A7--lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"在C++11以后，形如这样的语法。[capture](parameters)mutable -&gt;return-type{statment}称为一个lambda表达式，表达一个匿名函数。从编程的角度上看，lambda是一种函数式编程。 分析语法:1.capture,可以通过值传递或者引用传递的方式给匿名函数提供访问父作用域上下文的变量。特殊的两种情况：[=]和[&amp;]分别表示，以值传递的形式捕捉所有父作用域的变量和以引用传递的形式捕捉所有父作用域的变量。2.（）参数列表形如一般的函数的参数列表。没有参数时可以忽略不写。3.可选择项,mutable,-&gt;return type,分别表示去除匿名函数的常量性，-&gt;return type是匿名函数的返回值类型，可以忽略由编译器自动推导。添加可选项必须在此之前增加()。4.{statment}函数本体。 12345678910111213#include &lt;thread&gt;#include &lt;iostream&gt;int main()&#123; []&#123;&#125;；&#x2F;&#x2F;最简单的表达方式 int a&#x3D;2,b&#x3D;2; [&#x3D;]()-&gt;int&#123;return a+b;&#125;; [a]()&#123;cout&lt;&lt;a&lt;&lt;endl;&#125;; &#x2F;&#x2F;[var] 以传值的方式捕获 [&amp;b]()&#123;++b;cout&lt;&lt;b&lt;&lt;endl;&#125;&#x2F;&#x2F; [&amp;b] 以传递引用的方式捕获 &#x2F;&#x2F;可以使用匿名函数与线程结合起来 thread t1([]&#123;cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl;&#125;); t1.join();&#125; 使用mutable关键字的区别 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int id &#x3D; 10; auto f &#x3D; [id]()mutable&#123; ++ id; cout&lt;&lt;&quot;id:&quot;&lt;&lt;id&lt;&lt;endl; &#125;; f(); cout&lt;&lt;&quot;main id:&quot;&lt;&lt;id&lt;&lt;endl; f(); return 0;&#125; （1）增加mutable关键字（2）不增加mutable关键字 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int id &#x3D; 10; auto f &#x3D; [id]&#123;++id;cout&lt;&lt;&quot;id:&quot;&lt;&lt;id&lt;&lt;endl;&#125;; f(); cout&lt;&lt;&quot;main id:&quot;&lt;&lt;id&lt;&lt;endl; f(); return 0;&#125; 匿名函数与仿函数有着本质的相似处 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;对(）进行重载的函数，在调用()时与调用函数有着相似之处，但是是通过对象名称调用的class Functor&#123;public: Functor(int a&#x3D;0,int b&#x3D;0):_a(a),_b(b)&#123;&#125; void operato()()&#123;cout&lt;&lt;_a+_b&lt;&lt;endl;&#125;private: int _a; int _b;&#125;;int main()&#123; Functor sum(10,20); sum(); auto sum1 &#x3D; [](int a,int b)&#123;cout&lt;&lt;a+b&lt;&lt;endl;&#125;; sum1(20,20); return 0;&#125; 通过上述例子，除去在语法层面上的不同，仿函数和lambda表达式都是通过捕捉一些变量作为初始值，之后进行传递参数并进行计算。在形式上，仿函数通过构造函数构造进行初始化，而lambda表达通过捕捉列表[capture]获取初始值。仿函数通过对operator()重载函数的参数列表进行传参，而lambda表达式通过(parameters)参数列表进行传递参数。最后，仿函数的执行体在operator()函数体中进行运算，而lambda表达式在{}进行运算。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"linux下检测内存泄漏","slug":"linux下检测内存泄漏","date":"2018-12-27T09:28:02.000Z","updated":"2020-11-29T19:35:24.711Z","comments":true,"path":"2018/12/27/linux下检测内存泄漏/","link":"","permalink":"http://example.com/2018/12/27/linux%E4%B8%8B%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"使用开源工具valgrind下载请点击，发行版本链接 安装步骤： 123451.解压文件 tar -jxvf valgrind-x.x.x.tar.bz22.进入文件目录 cd valgrind-x.x.x3.在目录下执行 .&#x2F;configure4.使用make进行自动化编译 make5.安装 make install ubuntu用户可以使用：sudo apt-get install valgrind进行安装 在C/C++程序中，使用指针虽然是非常高效的，但是伴随而来的一旦使用方法不得当就会造成大量的内存碎片。而C++程序对（heap memory）的申请和释放都由程序员手工完成的。但是在大型程序中，一旦出现内存泄漏的问题也难以通过一行一行的逻辑判断进行查找，这是十分痛苦的。当然智能指针(smart pointer)的出现方便管理堆内存，有兴趣的朋友们可以下载boost库的源码学习智能指针是怎么管理堆内存的以及它的特性，但是今天我们讨论的重点是如何使用开源工具检测内存泄漏。boost c++库链接 下面使用valgrind检测常见的内存错误，首先对常见的内存错误进行分类1.使用野指针2.重复释放同一块内存3.new和delete或malloc和free没有配对使用，造成内存泄漏4.使用未进行初始化的对内存 1.使用野指针 12345678910111213test.cpp#include &lt;iostream&gt;using namespace std;int main()&#123; int *pint &#x3D; new int;&#x2F;&#x2F;动态申请内存 *pint &#x3D; 30; delete pint;&#x2F;&#x2F;释放内存 cout&lt;&lt;*pint&lt;&lt;endl;&#x2F;&#x2F;使用野指针 return 0;&#125;g++ test.cpp -g -o testvalgrind --tool&#x3D;memcheck .&#x2F;test进行检测 2.重复释放内存 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int* pint &#x3D; new int; delete pint; delete pint; return 0;&#125;g++ test.cpp -g -o testvalgrind --tool&#x3D;memcheck .&#x2F;test进行检测 3.new和delete或malloc和free没有配对使用，造成内存泄漏 12345678910test.cpp#include &lt;iostream&gt;using namespace std;int main()&#123; int* pint &#x3D; new int; *pint &#x3D; 30; return 0;&#125;g++ test.cpp -o test -gvalgrind --tool&#x3D;memcheck .&#x2F;test 4.使用未进行初始化的对内存","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"C++11新特性--智能指针","slug":"C++11新特性--智能指针","date":"2018-12-02T04:10:20.000Z","updated":"2020-11-29T19:35:24.739Z","comments":true,"path":"2018/12/02/C++11新特性--智能指针/","link":"","permalink":"http://example.com/2018/12/02/C++11%E6%96%B0%E7%89%B9%E6%80%A7--%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"为什么会有智能指针？？？ C++程序员在编写代码的过程往往都会涉及到堆内存的开辟和释放，使用new和delete关键字。特别是内存的释放是通过程序员手动完成的，而不像栈内存只要生存周期结束即可由系统自动回收。所在在实际的编码中，如果忘记手动释放内存或因其他一些细节原因而未进行堆内存的释放，最终导致产生大量的内存释放，造成资源浪费。 一些特殊的情况导致堆内存没有机会得到释放 1234567int main()&#123; int* p &#x3D; new int; if(条件表达式)&#123; return 0; &#125; delete p;&#125; 一般将堆内存的释放安排到程序的末尾，但是像上述例子，如果程序当中一些逻辑语句满足是就退出程序，最终导致堆内存资源未得到释放。 123456789void fun(int* p)&#123; delete p; p &#x3D; NULL;&#125;int main()&#123; int* p &#x3D; new int; fun(p); delete p;&#125; 在上述代码中，在fun函数中已经将指针p所指向的堆内存进行释放，当fun函数调用完毕后，再次执行delete p，此时程序会崩溃，因为p已经为NULL，指向虚拟地址空间的(void*)0是不允许被访问的内存区域，而现在要对他进行释放，显然是错误的。 12345678910111213141516int Div(int a,int b)&#123; if(b&#x3D;&#x3D;0)&#123; throw &quot;div by zero condition!&quot;; &#125; return a&#x2F;b;&#125;int main()&#123; int *p &#x3D; new int; try&#123; Div(10,0); &#125; catch(const char* meg)&#123; cerr&lt;&lt;msg&lt;&lt;endl; &#125; delete p;&#125; 在上述的代码中，由于在try块中捕获到了异常，直接执行catch中的语句，而未进行堆内存的释放，最终也导致了内存泄漏。 综上的三个例子，对于C++使用堆内存资源并造成内存泄漏的几率还是非常大的，即使你非常小心仔细的处理每一个可能会被泄漏的堆内存，也难免会出现一些问题。这无疑要求C++程序员对于对内存的使用要求之高，而智能指针的诞生解放了C++程序员对于堆内存的管理。 智能指针 智能指针是一个类，它将裸指针(带*的指针)进行了封装，实现的指针的自动释放，它的高明之处就在于程序员只需要一次性的设计出一个具有良好功能的智能指针类，用它实例化出来的对象会自动对对象内存的堆资源进行管理，而不需要程序员去干涉，它自己就可以很好的完成对堆内存的管理。 使用智能指针的前提是利用了当栈对象的生存周期结束时，会自动调用析构函数，来进行对对象的销毁。RAII技术。智能指针不能再堆上创建。 设计智能指针的类模板需要解决的问题：（1）指针可以做的事情，智能指针也必须可以做。需要对*，-&gt;运算符进行重载。（2）*运算符需返回引用，因为*可以连续使用。（3）*和-&gt;的重载函数是没有形式参数的。 123456789101112131415161718192021222324252627template &lt;typename T&gt;class SmartPtr&#123;public: SmartPtr(T* ptr&#x3D;NULL):_ptr(ptr)&#123;&#125; ~SmartPtr()&#123;delete _ptr;_ptr&#x3D;NULL;&#125; T&amp; operator*()&#123; return *_ptr; &#125; const T&amp; operator*() const&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; const T* operator-&gt;()const&#123; return _ptr; &#125; private: T* _ptr;&#125;;int main()&#123; SmartPtr&lt;int&gt; p(new int); *p &#x3D; 20; cout&lt;&lt;&quot;*p&#x3D;&quot;&lt;&lt;*p&lt;&lt;endl; &#125; 智能指针的浅拷贝问题 1234567int main()&#123; SmartPtr&lt;int&gt; p(new int); *p &#x3D; 20; SmartPtr&lt;int&gt; p1(p); &#x2F;&#x2F;程序意图使得p和p1指向同一块堆内存 new int cout&lt;&lt;&quot;*p&#x3D;&quot;&lt;&lt;*p&lt;&lt;endl;&#125; 然而执行结果出错，在linux直接检测出来了内存泄漏错误的原因两个智能指针对象中的_ptr指向了堆内存的同一块内存区域，但是p1对象析构时释放了该堆内存，而对象p析构时又对堆内存进行进行了释放。然而此时堆内存已经由上一个对象p1进行了释放，所以导致出错。 解决智能指针浅拷贝的问题引用计数：引用计数实际上就是为了解决这种浅拷贝问题诞生，每当对资源（堆内存）引用一次就对计数器+1，每当删除一次，就对计数器-1,直到当资源的引用计数为0时，就证明没有对象对它进行引用了，此时调用析构函数对资源进行释放。 管理资源的引用计数 12345678910111213141516171819202122&#x2F;&#x2F;资源的引用计数表calss resCountMap&#123;public: &#x2F;&#x2F;增加资源的引用计数 void addRef(void* ptr)&#123; _resCntMap[ptr] +&#x3D; 1;&#x2F;&#x2F;要考虑线程安全 加锁 &#125; &#x2F;&#x2F;减少资源的引用计数 void delRef(void* ptr)&#123; &#x2F;&#x2F;要考虑线程安全 加锁 if(_resCntMap[ptr]&#x3D;&#x3D;0) _resCntMap.erase(ptr); else _resCntMap[ptr] -&#x3D; 1; &#125; &#x2F;&#x2F;获取资源的引用计数 int getRef(void* ptr)&#123; return _resCntMap[ptr]; &#125;private: map&lt;void*,int&gt; _resCntMap;&#125;; 具有引用计数的智能指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556template &lt;typename T&gt;class SmatPtr&#123;public: SmatPtr(T* ptr&#x3D;NULL):_ptr(ptr)&#123; if(_ptr!&#x3D;NULL)&#123; addRef(); &#125; &#125; ~SmartPtr()&#123; delRef(); if(getRef()&#x3D;&#x3D;0)&#123; delete _ptr; &#125; &#125; SmartPtr(const SmartPtr&lt;T&gt;&amp; src):_ptr(src._ptr)&#123; if(_ptr!&#x3D;NULL)&#123; addRef(); &#125; &#125; SmartPtr&lt;T&gt;&amp; operator&#x3D;(const SmartPtr&lt;T&gt;&amp; src)&#123; if(&amp;src&#x3D;&#x3D;this) return *this; delRef();&#x2F;&#x2F;将引用计数-1，因为当前智能指针要去引用其他资源 if(getRef()&#x3D;&#x3D;0)&#123; delete this-&gt;_ptr; &#125; _ptr &#x3D; src._ptr; if(_ptr!&#x3D;NULL) addRef(); return *this; &#125; T&amp; operator*()&#123; return *_ptr; &#125; const T&amp; operator*() const&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; const T* operator-&gt;()const&#123; return _ptr; &#125; void addRef()&#123;_countMap.add(_ptr);&#125; void delRef()&#123;_countMap.delRef(_ptr);&#125; int getRef()&#123;return _countMap.getRef(_ptr);&#125;private: T* _ptr; static resCountMap _countMap;&#x2F;&#x2F;是所有智能指针对象公有的，设置为static&#125;;&#x2F;&#x2F;在类外进行静态成员函数的初始化template &lt;typename T&gt;resCountMap SmatPtr&lt;T&gt;::_countMap；","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C/S模式下---多线程编程","slug":"C!S模式下---多线程编程","date":"2018-11-29T07:27:33.000Z","updated":"2020-11-29T19:35:24.735Z","comments":true,"path":"2018/11/29/C!S模式下---多线程编程/","link":"","permalink":"http://example.com/2018/11/29/C!S%E6%A8%A1%E5%BC%8F%E4%B8%8B---%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"服务器采用单进程/线程编程，在同一时刻，服务器只能与一个客户端进行交互。只有与当前客户端的通信结束后，才能为下一个客户端进行服务。所以，如果采用线程，让主线程连接客户端，而函数线程为每个客户端进行服务，这样就可以保证服务器可以同时为多个客户端提供服务，实现并发。 采用多线程的优势1.线程占用资源少。2.从CPU的工作角度上看，线程的切换速度要比进程快。3.资源共享，线程之间的通信更加简单。4.编码实现相对简单。 代码：ser.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;sys&#x2F;scoket.h&gt;#include &lt;arpa&#x2F;inet&gt; #include &lt;netinet&#x2F;in.h&gt;#include &lt;assert.h&gt;#Include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void* fun(void* arg)&#123; int c &#x3D; (int)arg; char buff[128] &#x3D; &#123;0&#125;; while(1)&#123; int n &#x3D; recv(c,buff,127,0); if(n&lt;&#x3D;0)&#123; printf(&quot;client quit!\\n&quot;); close(c); break; &#125; printf(&quot;%d : %s&quot;,c,buff); send(c,&quot;OK&quot;,2,0); &#125; pthread_exit(NULL);&#125;int main()&#123; int fd &#x3D; socket(AF_INET,SOCK_STREAM,0); assert(fd!&#x3D;-1); struct sockaddr_in cli,ser; ser.sin_family &#x3D; AF_INET; ser.sin_port &#x3D; htons(6000); ser.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;); int res &#x3D; binf(fd,(struct sockaddr*)&amp;ser,sizeof(ser)); assert(res!&#x3D;-1); res &#x3D; listen(fd,5); assert(res!&#x3D;-1); while(1)&#123; socklen_t len &#x3D; sizeof(cli); int c &#x3D; accept(fd,(struct sockaddr*)&amp;cli,&amp;len); if(c&#x3D;&#x3D;-1)&#123; printf(&quot;link error!\\n&quot;); continue; &#125; pthread_t id; pthread_create(&amp;id,NULL,fun,(void*)c);&#x2F;&#x2F;值传递，不能地址传递 &#125; close(fd); return 0;&#125; 执行结果：查看线程数量：需要注意的问题：在向函数线程传递文件描述符的参数必须以值传递的形式进行传递，因为进程中的各个线程共享进程的PCB，如果以传地址或传引用的形式传输文件描述符，之前的正在被服务的客户端文件描述符可能被修改造成程序出错。 采用服务器端多线程编程的缺点：1.要考虑线程安全问题。2.线程之间不是相互独立的。3.进程中的栈帧的大小是有限的，只能启动有限个数的线程。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"C/S模式下---多进程编程","slug":"C!S模式下---多进程编程","date":"2018-11-29T06:25:47.000Z","updated":"2020-11-29T19:35:24.767Z","comments":true,"path":"2018/11/29/C!S模式下---多进程编程/","link":"","permalink":"http://example.com/2018/11/29/C!S%E6%A8%A1%E5%BC%8F%E4%B8%8B---%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"在单进程下进行socket的编程，服务器通过accept()获取到客户端的文件描述符，并且与该客户端进行交互。但是实际有两方面的因素都促使服务器应该能够同时与多个客户端进行交互。 1.listen()函数将已经完成三次握手和即将完成三次握手的客户端文件描述符存放到队列中。2.在实际客户端与服务器进行交互时，服务器必须能够同时与多个客户端进行交互。 多进程编程的优势：1.能够处理同时处理多个客户端的连接，并且能够与客户端进行交互。2.子进程可以共享fork()之间父进程打开的文件描述符，而不需要在进程之间传递文件描述符，简化了编程。3.服务器处理的每个客户连接都是相互独立的，因为进程之间是相互独立的。。4.任务分派明确，父进程只需处理客户端的连接，子进程只需要与客户端进程交互即可。 多进程服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;sys&#x2F;scoket.h&gt;#include &lt;arpa&#x2F;inet&gt; #include &lt;netinet&#x2F;in.h&gt;#include &lt;assert.h&gt;#Include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void zmobie()&#123; wait(NULL);&#125;void communicateWithCli(int c)&#123; char buff[128] &#x3D; &#123;0&#125;; while(1)&#123; int n &#x3D; recv(c,buff,127,0); if(n&lt;&#x3D;0)&#123; printf(&quot;one client quit!&quot;); break; &#125; printf(&quot;%d : %s&quot;,c,buff); send(c,&quot;OK&quot;,2,0); &#125;&#125;int main()&#123; signal(SIGCHLD,zmobie); int fd &#x3D; socket(AF_INET,SOCK_STREAM,0); assert(fd!&#x3D;-1); struct sockaddr_in cli,ser; ser.sin_family &#x3D; AF_INET; ser.sin_port &#x3D; htons(5000); ser.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;); int res &#x3D; bind(fd,(struct sockaddr*)&amp;ser,sizeof(ser)); assert(res!&#x3D;-1); res &#x3D; listen(fd,5); assert(res!&#x3D;-1); while(1)&#123; socklen_t len &#x3D; sizeof(cli); int c &#x3D; accept(fd,(struct sockaddr*)&amp;cli,&amp;len); if(c&#x3D;&#x3D;-1)&#123; printf(&quot;link error!&quot;); continue;&#x2F;&#x2F;继续进行连接 &#125; pid_t pid &#x3D; fork(); assert(pid!&#x3D;-1); &#x2F;&#x2F;子进程 if(pid&#x3D;&#x3D;0)&#123; communicateWithCli(c); exit(0);&#x2F;&#x2F;向父亲发出信号，避免成为僵死进程,因为父进程是一直启动的 &#125; &#x2F;&#x2F;父进程 else&#123; close(c); &#125; &#125; close(fd); return 0;&#125; 执行结果：从执行结果可以看出，有四个客户端可以同时和服务器进行交互，通过多进程的方式就解决了在最前提出的问题。 值得探究的是为什么每次服务器端输出的客户端的文件描述符都是4? 为什么在父进程中需要关闭客户端的文件描述符？文件描述符作为进程的资源是有限的，处于C/S的模式下，主进程只需要负责与客户端连接，而不需要去做具体的逻辑处理。连接之后就不需要该客户端的文件描述符了，具体与客户端进行交互的进程中已经拿到对应的文件描述符了。因此，在父进程中关闭客户端的文件描述符可以减少不必要的资源浪费。 基于C/S模式，采用多进程编程的缺点1.在系统可以打开的进程是有限个数的，为每一个客户端分配一个进程开销太大,如果客户端占着不用，或者只有少量数据的传输，开进程是划不来的。2.一个客户端独占一个进程，资源浪费。3.当客户端退出时，子进程结束。4.如果由大量的客户端同时连接服务器，服务器可能会崩溃。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"Linux-解决登陆mysql数据库出现 “Access denied for user 'root'@'localhost' (using password: YES)”的问题","slug":"Linux-解决登陆mysql数据库出现 “Access denied for user 'root'@'localhost' (using password! YES)”的问题","date":"2018-11-25T14:58:25.000Z","updated":"2020-11-29T19:46:04.199Z","comments":true,"path":"2018/11/25/Linux-解决登陆mysql数据库出现 “Access denied for user 'root'@'localhost' (using password! YES)”的问题/","link":"","permalink":"http://example.com/2018/11/25/Linux-%E8%A7%A3%E5%86%B3%E7%99%BB%E9%99%86mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%20%E2%80%9CAccess%20denied%20for%20user%20'root'@'localhost'%20(using%20password!%20YES)%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"我的平台为redhat-linux,其它版本linux类同。 请按照下列步骤依此执行，亲测有效：1.切换为root用户，停止mysql服务，service mysqld stop。2.在当前终端中输入 mysqld_safe --user=mysql --skip-grant-tables --skip-networking。3.新打开一个终端输入mysql。4.进入mysql后，输入 update mysql.user set password=PASSWORD(&#39;123456&#39;) where user=&#39;root&#39;;修改密码。5.刷新flush priviledges; 退出 quit;6.重新启动mysqld服务,service mysqld restart","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"软链接和硬链接","slug":"软链接和硬链接","date":"2018-11-24T12:29:11.000Z","updated":"2020-11-29T19:35:24.731Z","comments":true,"path":"2018/11/24/软链接和硬链接/","link":"","permalink":"http://example.com/2018/11/24/%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/","excerpt":"","text":"软链接-符号链接：相当于windows的快捷方式。创建命令:ln s 文件名 软链接的名字 ln-link s-soft特点：1.在linux中，软链接文件的颜色为浅蓝色。2.软链接的大小为原文件的文件名大小，即路径长度。3.软链接仅可在当前路径下使用，即和原文件在同一目录下。创建时最好给出原文件的绝对路径。4.目录也可创建软链接，方法同上。如上述的图片中，在这样形式的创建方式下如果将同一级目录下的软链接移动到其他目录下（与原文件不在同一个目录下），软链接会发生失效。所以，这样的创建方式是有一定缺陷的，最好的创建方式，是给出整个原文件的绝对路径，而不是相对路径，这样就不会发生失效，即使软链接和原文件不在同一级目录下。此外，如果原文件被删除，那么软链接也会发生失效，毕竟它只是一个快捷方式而已。 硬链接：在linux上，一以切皆文件。那么如何给出文件名，找到其在磁盘上的对应位置呢？实际上，操作系统对文件名并不感兴趣，它只要求知道文件所对应的inode即可，通过inode找到对应的块即可找到相应的磁盘文件。创建命令:ln 原文件 硬链接文件名 特点：1.使用的inode与原文件是同一个。2.新创建一个引用计数+1。3.删除硬链接文件或原文件只是对用inode节点中引用计数-1。4.只有当inode中引用计数为0时，此文件才真正被删除了。5.不能对目录创建硬链接文件，因为担心出现死递归创建的问题。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"string类的实现","slug":"string类的实现","date":"2018-11-17T03:35:15.000Z","updated":"2020-11-29T19:35:24.735Z","comments":true,"path":"2018/11/17/string类的实现/","link":"","permalink":"http://example.com/2018/11/17/string%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334#include &lt;cstring&gt;class Cstring&#123;private: char* _data;public: Cstring(const char* str)&#123; if(str!&#x3D;NULL)&#123; _data &#x3D; new char[strlen(str)+1]; strcpy(_data,str); &#125; else&#123; _data &#x3D;new char[1]; *_data &#x3D; &#39;\\0&#39;; &#x2F;*这样处理的好处是将NULL和非NULL统一处理，Cstring中其他成员函数不需要 对_data是NULL和非NULL分别进行处理，简化成员函数的逻辑*&#x2F; &#125; &#125; Cstring(const Cstring&amp; src)&#123; this-&gt;_data &#x3D; new char[strlen(str)+1]; strcpy(_data,strc._data); &#125; Cstring&amp; operator&#x3D;(const Cstring&amp; src)&#123; if(this &#x3D;&#x3D; &amp;src)&#123; return *this; &#125; delete[] this-&gt;_data; this-&gt;_data &#x3D; new char[strlen(src._data)+1]； strcpy(this-&gt;_data,src._data); return *this; &#125; ~Cstring()&#123; delete[] _data; &#125;&#125;;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"浅拷贝和深拷贝（用string类分析）","slug":"浅拷贝和深拷贝（用string类分析）","date":"2018-11-17T03:24:22.000Z","updated":"2020-11-29T19:35:24.739Z","comments":true,"path":"2018/11/17/浅拷贝和深拷贝（用string类分析）/","link":"","permalink":"http://example.com/2018/11/17/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88%E7%94%A8string%E7%B1%BB%E5%88%86%E6%9E%90%EF%BC%89/","excerpt":"","text":"区分什么是初始化和赋值。对于一个类来讲，如果用一个已经存在的对象去构造一个新对象，这个过程就是初始化的过程。如果用一个已经存在的对象去给另一个已经存在的对象赋值，这就是赋值的过程。在初始化和赋值的过程中，假设类涉及到堆内存,如果采用编译器系统默认给定的拷贝构造函数和赋值运算符的重载函数进行对象之间的初始化过程和赋值过程，轻则发生浅拷贝，重则内存泄漏，这样的程序都是有问题的。下面分析为什么在使用默认的拷贝构造函数时会出现浅拷贝问题。 1234567891011121314151617181920class Cstring&#123;private: char* _data;public: Cstring(const char* str)&#123; if(str!&#x3D;NULL)&#123; _data &#x3D; new char[strlen(str)+1]； strcpy(_data,str); &#125; else&#123; &#x2F;&#x2F;不处理为NULL的原因是，降低类中其他函数的逻辑复杂度，统一处理 &#x2F;&#x2F;不需要判断_data是否NULL，分开处理 _data &#x3D; new char[1]; *_data &#x3D; &#39;\\0&#39;; &#125; &#125; ~Cstring()&#123; delete[] _data; &#125;&#125;; 测试程序 ： 12345int main()&#123; Cstring str(&quot;hello&quot;); Cstring str1 &#x3D; str; return 0;&#125; 因为调用默认的拷贝构造函数，只是简单的内存值拷贝，这样会使得对象str1中的_data和对象str中的_data指向同一块在堆上的内存空间，str1相对于str后构造，所以str1会先进行析构，释放掉了这块堆内存。使得str中的_data变为野指针，此str对象进行析构。将会释放野指针指向heap上的一块堆内存，这是非常不安全的。解决方案:进行深拷贝，每个对象有自己的堆内存 1234Cstring::Cstring(const Cstring&amp; src)&#123; this-&gt;_data &#x3D; new char[strlen(src._data)+1]； strcpy(_data,src.data);&#125; 如上图，这样就实现了在拷贝构造函数中深拷贝。 下面再讨论一下使用默认赋值运算符重载的拷贝构造函数在使用时出现的内存泄漏以及浅拷贝问题。测试程序： 12345int main()&#123; Cstring str(&quot;hello&quot;); Cstrint str1(&quot;world&quot;); str &#x3D; str1;&#x2F;&#x2F;可以理解为str.&#x3D;(str1)这样的调用方式&#125; 编译器系统默认的赋值运算符的重载函数是简单的赋值。解决方案：自己实现赋值运算符重载函数，两个目的：1.避免出现内存泄漏的问题。2.进行深拷贝 1234567891011Cstring&amp; Cstring(const Cstring&amp; src)&#123; &#x2F;&#x2F;防止发生在自赋值 if(this &#x3D;&#x3D; &amp;src)&#123; return *this; &#125; delete[] this-&gt;_data;&#x2F;&#x2F;释放当前对象在堆上的空间，避免出现内存泄漏 _data &#x3D; new char[strlen(src._data)+1];&#x2F;&#x2F;申请空间，避免出现浅拷贝 strcpy(_data,src._data);&#x2F;&#x2F;进行内存拷贝 return *this;&#125;&#x2F;&#x2F;经过上述的处理，内存泄漏和浅拷贝的问题都得以解决 总结：在实现类的构造函数中，往往会涉及到堆内存的开辟。如果对拷贝构造函数和赋值运算符的重载函数不进行重写，会发生浅拷贝以及内存泄漏等问题导致程序出错。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"二叉堆类模板的实现以及使用它进行堆排序","slug":"二叉堆类模板的实现以及使用它进行堆排序","date":"2018-11-16T14:43:20.000Z","updated":"2020-11-29T19:35:24.739Z","comments":true,"path":"2018/11/16/二叉堆类模板的实现以及使用它进行堆排序/","link":"","permalink":"http://example.com/2018/11/16/%E4%BA%8C%E5%8F%89%E5%A0%86%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%AE%83%E8%BF%9B%E8%A1%8C%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"二叉堆：二叉堆一棵完全二叉树，从递归的定义来讲，对于完全二叉树的任何一个节点，其左孩子要么是空树要么是一个完全二叉树，右孩子同上。 堆：对于一个堆来讲，可以是一个大根堆，也可以是一个小根堆。 大根堆的性质：对于在大根堆任何一个节点，其值不小于左右孩子的值。小根堆的性质：对于在大根堆任何一个节点，其值不大于左右孩子的值。由于堆的底层数据结构是由完全二叉树实现的，就可以利用完全二叉树的一些性质来实现一个堆。假设一棵完全二叉树的编号从零开始，则对于任意节点i，其父亲节点和孩子节点可以表示为。father(i) = i/2;left(i) = 2 * i,right(i) = 2 * i+1;用数组构建一个堆：由于数组的下标是从0开始的，这样与完全二叉树节点从1开始不对应，实际可以这样处理，为数组多申请一个空间不使用索引为0的空间，这样就可以将一棵完全二叉树和数组完全的对应起来，这样处理会使得代码编写更为简单，代码的可读性非常高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template&lt;typename T&gt;class Heap&#123;private: T* data;&#x2F;&#x2F;存储堆中数据的数组 int count;&#x2F;&#x2F;记录当前堆中有效元素的个数 int capacity;&#x2F;&#x2F;记录堆存储的容量 &#x2F;&#x2F;向上调整元素data[k]满足堆的性质 void shiftUp(int k)&#123; &#x2F;&#x2F;以构建大根堆为前提条件 while(k&gt;1 &amp;&amp; data[k&#x2F;2] &lt; data[k])&#123; &#x2F;&#x2F;若k节点的父亲节点data[k&#x2F;2]比自己还小，需交换位置 &#x2F;*循环终止条件k&gt;1,当k&#x3D;&#x3D;2时，其父亲节点为data[1]。 需注意边界处理，否则会发生数组越界*&#x2F; swap(data[k&#x2F;2],data[k]); k &#x2F;&#x3D; 2;&#x2F;&#x2F;更新节点 &#125; &#125; &#x2F;&#x2F;向下调整data[k]以继续满足堆的性质 &#x2F;&#x2F;对于任何一个节点，寻找max(node,max(node-&gt;left,node-&gt;right))作为当前的根节点 void shiftDown(int k)&#123; &#x2F;&#x2F;当前节点有右孩子 while(2*k&lt;&#x3D;count)&#123; int j &#x3D; 2*k;&#x2F;&#x2F;j表示最终data[k]所在的位置 if(j+1 &lt;&#x3D; count &amp;&amp; data[j+1]&gt;data[j])&#123; j ++;&#x2F;&#x2F;当前节点存在右孩子，并且右孩子大于左孩子的值 &#125; if(data[k] &gt; data[j]) break;&#x2F;&#x2F;当前节点大于其左右孩子，则不需要做调整 else swap(data[k],data[j]); k &#x3D; j;&#x2F;&#x2F;更新新的根节点 &#125; &#125;public: Heap(int capacity)&#123; data &#x3D; new T[capacity+1];&#x2F;&#x2F;0索引不使用 this-&gt;capacity &#x3D; capacity; this-&gt;count &#x3D; 0; &#125; ~Heap()&#123; delete[] data;&#x2F;&#x2F;释放在堆上开辟的内存 &#125; int size()&#123;return count;&#125; bool isEmpty()&#123;return size&#x3D;&#x3D;0;&#125; void insert(T value)&#123; &#x2F;&#x2F;插入数据前需判断是否还有空间可以插入 assert(count&lt;capacity); data[count+1] &#x3D; value; count ++; &#x2F;&#x2F;新添加的元素可能不满足堆的性质，需做调整维护堆的性质 shiftUp(count);&#x2F;&#x2F;调用被private限定的方法，不直接暴露给用户 &#125; &#x2F;&#x2F;推出堆顶元素 T extractMax()&#123; &#x2F;&#x2F;需判空，如果堆空，则没有堆顶元素 assert(count &gt;&#x3D; 1);&#x2F;&#x2F;堆中至少由一个元素 T ans &#x3D; data[1];&#x2F;&#x2F;对于大根堆，data[1]就是此堆的最大元素 swap(data[1],data[count]);&#x2F;&#x2F;将堆中最后一个元素和第一个元素交换位置 count --;&#x2F;&#x2F;删除被交换下来的最大元素 shiftDown(1);&#x2F;&#x2F;data[count]放置到第一个位置有可能不满足堆的性质，需做调整 return ans; &#125;&#125;; 利用上边已经实现的Heap的类模板实现堆排序 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;堆排序的接口template&lt;typename T&gt;void heapSort(T arr[],int n)&#123; Heap&lt;T&gt; hp(n+1); for(int i&#x3D;0;i&lt;n;++i)&#123; hp.insert(arr[i]); &#125; &#x2F;&#x2F;从小到大排序 for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)&#123; arr[i] &#x3D; hp.extractMax(); &#125;&#125;template&lt;typename T&gt;void show(T arr[],int n)&#123; for(int i&#x3D;0;i&lt;n;++i)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125; 主函数 12345678int main(void)&#123; int arr[] &#x3D; &#123;8,5,9,7,3,6,4,2,1&#125;; int n &#x3D; sizeof(arr)&#x2F;sizeof(int); heapSort(arr,n); show(arr,n); return 0;&#125; 执行结果：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"CVTE笔试题目--删除链表中的重复元素","slug":"CVTE笔试题目--删除链表中的重复元素","date":"2018-11-16T12:41:50.000Z","updated":"2020-11-29T19:35:25.027Z","comments":true,"path":"2018/11/16/CVTE笔试题目--删除链表中的重复元素/","link":"","permalink":"http://example.com/2018/11/16/CVTE%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE--%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目描述：有时候列表中的重复元素占用空间但是并没有什么作用，请实现下列函数帮忙删除有序链表中的重复元素。只保留第一个出现的元素。 输入样例：1-&gt;2-&gt;2-&gt;4-&gt;4-&gt;4-&gt;5-&gt;6-&gt;6-&gt;7输出样例：1-&gt;2-&gt;4-&gt;5-&gt;6-&gt;7 解题思路：使用一个hash数组来标记链表中元素是否出现，这样即使出现重复元素，标记的是该元素是否出现，这样就将重复的元素过滤掉。之后清空链表，因为是顺序链表，从0索引开遍历整个hash数组。将hash数组中标记为true所对应的索引push_back到链表中即可。 12345678910111213void RemoveRedundant(list&lt;int&gt;&amp; l)&#123; int len &#x3D; l.size(); vector&lt;bool&gt; arr(len,false); for(auto it&#x3D;l.begin();it!&#x3D;l.end();++it)&#123; arr[*it] &#x3D; true; &#125; l.clear(); for(int i&#x3D;0;i&lt;arr.size();++i)&#123; if(arr[i]&#x3D;&#x3D;true)&#123; l.push_back(i); &#125; &#125;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"使用优先级队列实现堆排序","slug":"使用优先级队列实现堆排序","date":"2018-11-12T09:20:43.000Z","updated":"2020-11-29T19:35:25.007Z","comments":true,"path":"2018/11/12/使用优先级队列实现堆排序/","link":"","permalink":"http://example.com/2018/11/12/%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;template&lt;typename T&gt;void heapSort(T arr[],int n)&#123; &#x2F;&#x2F;构建大根堆 &#x2F;&#x2F;如果T类型不是基本类型，是class&#x2F;struct，则需要重载小于号运算符 priority_queue&lt;T,vector&lt;T&gt;&gt; q;&#x2F;&#x2F;缺省的情况下使用小于号，越小的优先级越高 for(int i&#x3D;0;i&lt;n;++i)&#123; q.push(arr[i]); &#125; for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)&#123; arr[i] &#x3D; q.top(); q.pop(); &#125;&#125;template&lt;typename T&gt;void show(T arr[],int n)&#123; for(int i&#x3D;0;i&lt;n;++i)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int arr[] &#x3D; &#123;5,3,1,4,2&#125;; int n &#x3D; sizeof(arr)&#x2F;sizeof(int); heapSort(arr,n); show(arr,n); return 0;&#125; 执行结果：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"java中Iterable接口的使用，实现一个单链表的迭代器","slug":"java中Iterable接口的使用，实现一个单链表的迭代器","date":"2018-11-11T04:31:46.000Z","updated":"2020-11-29T19:35:25.039Z","comments":true,"path":"2018/11/11/java中Iterable接口的使用，实现一个单链表的迭代器/","link":"","permalink":"http://example.com/2018/11/11/java%E4%B8%ADIterable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"单链表实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class MyLinkedList &lt;T&gt;&#123; private static class Entry&lt;E&gt;&#123; private E value; private Entry next; Entry(E e)&#123;this.value &#x3D; e;this.next &#x3D; null;&#125; Entry(E e,Entry next)&#123;this.value &#x3D; e;this.next &#x3D; next;&#125; Entry()&#123;&#125; public E getValue()&#123;return value;&#125; public void setValue(E value) &#123;this.value &#x3D; value;&#125; public Entry getNext() &#123; return next;&#125; public void setNext(Entry next) &#123; this.next &#x3D; next;&#125; &#125; private Entry&lt;T&gt; head; private int length; MyLinkedList()&#123; head &#x3D; new Entry&lt;T&gt;(); length &#x3D; 0; &#125; public void push(T e)&#123; insertTail(e); &#125; public void pop()&#123; if(!isEmpty())&#123; deleteTail(); &#125; else&#123; System.out.print(&quot;栈空，不能进行删除!&quot;); &#125; &#125; public T peek()&#123; if(!isEmpty())&#123; return getTailValue(); &#125; else &#123; System.out.print(&quot;栈空，没有栈顶元素&quot;); return null; &#125; &#125; public boolean isEmpty()&#123;return getLength()&#x3D;&#x3D;0;&#125; public int search(T e)&#123; int index &#x3D; searchIndex(e); if(index&gt;&#x3D;0)&#123; return getLength()-index; &#125; else&#123; return -1; &#125; &#125; public int searchIndex(T e)&#123; assert(head!&#x3D;null); Entry p &#x3D; head.next; int i &#x3D; 0; while(p!&#x3D;null)&#123; if(p.value.equals(e))&#123; return i; &#125; i++; p &#x3D; p.next; &#125; return -1; &#125; public void insert(int pos,T e)&#123; if(pos &lt; 1 || pos &gt;getLength()+1)&#123; System.out.print(&quot;插入位置不正确!&quot;); &#125; int i &#x3D; 0; assert(head!&#x3D;null); Entry p &#x3D; head; while(i&lt;pos-1 &amp;&amp; p!&#x3D;null)&#123; i++; p &#x3D; p.next; &#125; Entry pNew &#x3D; new Entry(e); pNew.next &#x3D; p.next; p.next &#x3D; pNew; length++; &#125; public void insertHead(T e)&#123;insert(1,e);&#125; public void insertTail(T e)&#123;insert(getLength()+1,e);&#125; public void delete(int pos)&#123; if(pos&lt;1 || pos&gt;getLength())&#123; System.out.print(&quot;删除位置不正确!&quot;); &#125; assert(head!&#x3D;null); int i&#x3D;0; Entry p &#x3D; head; while(i&lt;pos-1 &amp;&amp; p!&#x3D;null)&#123; i++;p &#x3D; p.next; &#125; Entry q &#x3D; p.next; q.value &#x3D; null; p.next &#x3D; q.next; length--; &#125; public void deleteHead()&#123;delete(1);&#125; public void deleteTail()&#123;delete(getLength());&#125; public void show()&#123; assert(head!&#x3D;null); Entry p &#x3D; head.next; while(p!&#x3D;null)&#123; System.out.print(p.value+&quot; &quot;); p &#x3D; p.next; &#125; System.out.println(); &#125; public int getLength()&#123;return length;&#125; public T getTailValue()&#123; assert(head!&#x3D;null); Entry&lt;T&gt; p &#x3D; head; while(p.next!&#x3D;null)&#123; p &#x3D; p.next; &#125; return p.getValue(); &#125;&#125; Iterable接口Iterable接口中需要实现的抽象方法iterator()的返回值会返回一个迭代器对象，这个迭代器对象可以作为一个工具来遍历集合类中的对象。此外，迭代器更是设计模式，如对图的遍历可以实现一个图迭代器，简化代码，将遍历的思想抽象出来。 自己实现一个可以遍历上述单链表的迭代器,这个迭代器需要实现Iterator接口中的方法。主要包括以下三个方法：（1）是否存在下一个对象元素（2）返回下一个对象元素（3）删除集合中的当前迭代器指向的对象元素 12345678910111213141516171819202122232425262728public class MyLinkedList &lt;T&gt; implements Iterable&lt;T&gt;&#123; public Iterator iterator()&#123; return new MyIterator(); &#125; public class MyIterator implements Iterator&lt;T&gt; &#123; Entry&lt;T&gt; data; MyIterator()&#123; data &#x3D; head.next; &#125; @Override public boolean hasNext() &#123; return data !&#x3D; null; &#125; @Override public T next() &#123; Entry&lt;T&gt; last &#x3D; data; data &#x3D; data.next; return last.getValue(); &#125; @Override public void remove() &#123; MyLinkedList1.this.delete(searchIndex(data.getValue())); &#125; &#125; 测试迭代器： 12345678910111213public class Main &#123; public static void main(String[] args)&#123; MyLinkedList1&lt;Integer&gt; list &#x3D; new MyLinkedList1&lt;&gt;(); for(int i&#x3D;0;i&lt;10;++i)&#123; list.insertTail(i); &#125; list.show(); Iterator it &#x3D; list.iterator(); while(it.hasNext())&#123; System.out.print(it.next()+&quot; &quot;); &#125; &#125;&#125; 测试结果：可以看出通过迭代器循环遍历集合中的对象元素和show()方法的功能是相同的，但是迭代器为遍历集合对象元素提供了一种统一的方法，此外也可以使用迭代器做更多的事情。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"BST（二叉搜索/排序树）类模板的实现","slug":"BST（二叉搜索!排序树）类模板的实现","date":"2018-11-04T12:43:31.000Z","updated":"2020-11-29T19:35:24.999Z","comments":true,"path":"2018/11/04/BST（二叉搜索!排序树）类模板的实现/","link":"","permalink":"http://example.com/2018/11/04/BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2!%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%89%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"BST树的递归定义：(1)BST树是一棵空树。(2)BST树由根节点、左子树和右子树。左子树和右子树分别都是一棵BST树。 由于二叉树的递归定义，使得在二叉树中许多操作中可以以递归的方式书写操作，代码更加浅显易懂。 重点条件：左子树中的所有节点的数据域都小于或等于根节点的数据域，而右子树中的所有节点的数据域都大于等于根节点的数据域。根据这个特点，BST树的中序遍历是一个由小到大的顺序序列。 BST树删除任意节点操作相对较难，这里分析一下。由于BST树的特点，对于任意一棵BST树均满足根节点的数据大于等于左子树任意节点的数据域，同时满足根节点的数据域小于等于右子树任意节点的数据域。根据这个特点，BST树中最左边的节点的数据域一定是BST的最小值，而BST树中最右边的节点的数据域一定是BST的最大值。而删除任意一个节点可以归结为以下三类：（1）一个节点有右子树，而没有左子树。（2）一个节点有左子树，而没有右子树。（3）一个节点既有左子树又有右子树。（最难）（4）一个节点为叶子节点。（可以归结到（1）和（2）两种情况当中）对于一个既有左子树又有右子树的节点来讲，在删除该节点之后，为了继续维持BST树的性质，选择一个合适的节点作为新树的根节点是非常有必要的。 如何选取？根据BST的定义，很容易观察到，当前节点右子树中所有节点均大于当前节点。但是在右子树中的最小值一定小于右子树其他节点，因此我们可以选取这个最小值所在的节点作为新BST的根，因为它继续满足BST对于任意节点，其数据大于左子树任意节点的数据域但同时小于右子树中任意节点的数据域的性质。此外，很对称是当前右子中的最大值所在节点也可以作为新树的根，它也继续满足BST树的性质。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200template&lt;typename T&gt;class BST&#123;private: &#x2F;&#x2F;节点类 struct Node&#123; T value; Node *left,*right;&#x2F;&#x2F;指向左右孩子的指针 Node(T value)&#123; this-&gt;value &#x3D; value; this-&gt;right &#x3D; this-&gt;left &#x3D; NULL; &#125; &#x2F;&#x2F;用另外一个节点的信息构造节点 Node(Node* node)&#123; this-&gt;value &#x3D; value; this-&gt;left &#x3D; node-&gt;left; this-&gt;right &#x3D; node-&gt;right; &#125; &#125;; &#x2F;*插入数据域为value的节点，插入之后整个BST任然满足BST的定义 返回值为插入数据域为value节点后，BST树的根节点。*&#x2F; Node* insert(Node* node,T value)&#123; &#x2F;&#x2F;空树和非空树两种情况 if(node &#x3D;&#x3D; NULL)&#123; &#x2F;&#x2F;空树 size ++;&#x2F;&#x2F;维护树中节点的个数 return new Node(value); &#125; else&#123; &#x2F;&#x2F;非空树 &#x2F;&#x2F;树中已有数据域为value的节点，更新该节点 if(value &#x3D;&#x3D; node-&gt;value)&#123; node-&gt;value &#x3D; value; return node; &#125; else if(value &lt; node-&gt;value)&#123; &#x2F;&#x2F;value比当前节点的数据域小，根据二叉树的定义，应插入在其左子树中 node-&gt;left &#x3D; insert(node-&gt;left,value); return node; &#125; else&#123; node-&gt;right &#x3D; insert(node-&gt;right,value); return node; &#125; &#125; &#125; &#x2F;&#x2F;获取BST树中数据域最大值所在的节点 Node* maxValue(Node* node)&#123; &#x2F;&#x2F;如果当前节点的右子树为空树，当前节点的数据域即为BST树的最大值 if(node-&gt;right &#x3D;&#x3D; NULL)&#123; return node; &#125; return maxValue(node-&gt;right); &#125; &#x2F;&#x2F;获取BST树中数据与最小值所在的节点 Node* minValue(Node* node)&#123; &#x2F;&#x2F;如果当前节点的左子树为空树，则当前节点的数据域即为整个BST树的最小值 if(node-&gt;left &#x3D;&#x3D; NULL)&#123; return node; &#125; return minValue(node-&gt;left); &#125; &#x2F;&#x2F;返回删除最小值后BST树的根 Node* deleteMin(Node* node)&#123; &#x2F;*如果当前节点的左子树为空树，即当前节点的数据域为BST树的最小值。 只需要将当前节点的右子树替代当前节点即可*&#x2F; if(node-&gt;left &#x3D;&#x3D; NULL)&#123; &#x2F;&#x2F;保存当前节点的右子树 Node* rightTree &#x3D; node-&gt;right; delete node; size --;&#x2F;&#x2F;维护size的定义 return rightTree; &#125; else&#123; &#x2F;&#x2F;在当前节点右子树树中删除 node-&gt;left &#x3D; deleteMin(node-&gt;left); return node; &#125; &#125; Node* deleteMax(Node* node)&#123; if(node-&gt;right &#x3D;&#x3D; NULL)&#123; Node* leftTree &#x3D; node-&gt;left; delete node; size --; return leftTree; &#125; else&#123; node-&gt;right &#x3D; deleteMax(node-&gt;right); return node; &#125; &#125; Node* remove(Node* node,T value)&#123; if(node &#x3D;&#x3D; NULL)&#123; return node; &#125; else&#123; if(value &lt; node-&gt;value)&#123; node-&gt;left &#x3D; remove(node-&gt;left,value); return node; &#125; else if(value &gt; node-&gt;value)&#123; node-&gt;right &#x3D; remove(node-&gt;right,value); return node; &#125; else&#123; if(node-&gt;right &#x3D;&#x3D; NULL)&#123; Node* leftTree &#x3D; node-&gt;left; delete node; size --; return leftTree; &#125; else if(node-&gt;left &#x3D;&#x3D; NULL)&#123; Node* rightTree &#x3D; node-&gt;right; delete node; size --; return rightTree; &#125; else&#123; Node* deleteNode &#x3D; node; Node* newTree &#x3D; new Node(minValue(node-&gt;right)); size ++; newTree-&gt;right &#x3D; deleteMin(node-&gt;right); newTree-&gt;left &#x3D; node-&gt;left; delete node; size --; return newTree; &#125; &#125; &#125; &#125; &#x2F;&#x2F;中序遍历 void inorder(Node* node)&#123; if(node!&#x3D;NULL)&#123; inorder(node-&gt;left); cout&lt;&lt;node-&gt;value&lt;&lt;&quot; &quot;; inorder(node-&gt;right); &#125; &#125; void destroy(Node* node)&#123; if(node!&#x3D;NULL)&#123; destroy(node-&gt;left); destroy(node-&gt;right); delete node; size --; &#125; &#125; Node* root;&#x2F;&#x2F;BST树的根节点 int size;&#x2F;&#x2F;BST树总结点个数public: BST()&#123; root &#x3D; NULL; size &#x3D; 0; &#125; ~BST()&#123; destroy(root);&#x2F;&#x2F;释放以root为根的二叉树节点在heap中的资源 &#125; &#x2F;&#x2F;获取当前BST树节点个数 int getSize()&#123;return size;&#125; &#x2F;&#x2F;判断一棵BST是否为空树 bool isEmpty()&#123;return size&#x3D;&#x3D;0;&#125; void insert(T value)&#123; &#x2F;&#x2F;调用私有的方法，用户只能使用此接口，实现插入操作 root &#x3D; insert(root,value); &#125; &#x2F;&#x2F;获取BST树中的最大值 T maxValue()&#123; if(root!&#x3D;NULL)&#123; Node* maxNode &#x3D; maxValue(root); return maxNode-&gt;value; &#125; &#125; &#x2F;&#x2F;获取BST树中的最小值 T minValue()&#123; if(root!&#x3D;NULL)&#123; Node* minNode &#x3D; minValue(root); return minNode-&gt;value; &#125; &#125; &#x2F;&#x2F;删除BST树最小值所在的节点 void deleteMax()&#123; if(root!&#x3D;NULL)&#123; root &#x3D; deleteMax(root); &#125; &#125; &#x2F;&#x2F;删除BST树最大值所在的节点 void deleteMin()&#123; if(root!&#x3D;NULL)&#123; root &#x3D; deleteMin(root); &#125; &#125; &#x2F;&#x2F;删除BST树中数据域为value的节点，即删除二叉树中的任意节点 void remove(T value)&#123; if(root!&#x3D;NULL)&#123; root &#x3D; remove(root,value); &#125; &#125; void inorder()&#123; inorder(root); &#125;&#125;; 测试: 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main(void)&#123; int arr[] &#x3D; &#123;9,5,3,4,1,7,2,8,0&#125;; int n &#x3D; sizeof(arr)&#x2F;sizeof(int); BST&lt;int&gt; bst; for(int i &#x3D; 0;i&lt;n;++i)&#123; bst.insert(arr[i]); &#125; bst.inorder(); cout&lt;&lt;&quot;max:&quot;&lt;&lt;bst.maxValue()&lt;&lt;endl; cout&lt;&lt;&quot;min:&quot;&lt;&lt;bst.minValue()&lt;&lt;endl; cout&lt;&lt;&quot;删除的节点是:value&#x3D;&#x3D;4&quot;&lt;&lt;endl; bst.remove(4); bst.inorder(); return 0;&#125; 执行结果：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"编写一个程序区分是C源代码还是C++源代码","slug":"编写一个程序区分是C源代码还是C++源代码","date":"2018-11-02T01:33:47.000Z","updated":"2020-11-29T19:35:25.031Z","comments":true,"path":"2018/11/02/编写一个程序区分是C源代码还是C++源代码/","link":"","permalink":"http://example.com/2018/11/02/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%86%E6%98%AFC%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BF%98%E6%98%AFC++%E6%BA%90%E4%BB%A3%E7%A0%81/","excerpt":"","text":"C++是在C语言的基础上建立的，所以在C++程序中沿用了很多C语言的东西，如printf函数既可以在C程序中使用，也可以在C++程序中使用，只需要引入相关的库文件即可。 如何区分是.c文件还是.cpp文件? 12345678910111213test.cpp#include&lt;cstdio&gt;int main(void)&#123; printf(&quot;hello world&quot;); return 0;&#125;test.c#include&lt;stdio.h&gt;int main(void)&#123; printf(&quot;hello world&quot;); return 0;&#125; 上边test.c和test.cpp源文件如果使用g++进行编译，g++会把.c文件当作.cpp文件进行处理，这样是区分不出来的。实际上C++编译器在编译C++程序中会向文件中添加__cpluscplus宏,我们可以利用这个宏来区分当前源文件是C++程序还是C程序。 123456789#include&lt;stdio.h&gt;int main(void)&#123;#ifdef __cpluscplus printf(&quot;c++\\n&quot;);#else printf(&quot;c\\n&quot;);#endif return 0;&#125; 此外，实际上我们在看C库的一些源码时，也会如上边的宏定义，因为C库函数完可能被C++程序使用，但是两者生成符号的规则却完全不相同。为了使得生成符号一致，需要加入extern “C”{}。来自cstdio的一段源码就是用到了__cplusplus宏：","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"一个C程序辨别系统是64位还是32位","slug":"一个C程序辨别系统是64位还是32位","date":"2018-11-01T14:39:09.000Z","updated":"2020-11-29T19:35:24.999Z","comments":true,"path":"2018/11/01/一个C程序辨别系统是64位还是32位/","link":"","permalink":"http://example.com/2018/11/01/%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%E8%BE%A8%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%98%AF64%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/","excerpt":"","text":"知识储备：计算机的位数取决CPU中寄存器的宽度，具体来说就是算术逻辑运算单元(ALU)的宽度，用来表征计算机的计算能力，ALU一次可以计算最大长度整数即计算机的位数。 在32bit的计算机中,ALU一次可以计算的最大整数为4个字节。在64bit的计算机中。ALU一次可以计算的最大整数为8个字节。 实际上，int这种类型是用来描述机器字长的，也就是说它可以代表寄存器的宽度。但是实际上int和long这两种类型不但和CPU体系结构有关系，同时和编译器的处理也有关系，不同的编译选项下它们的大小也是随之变化的，因此用这两个类型来测试当前系统是64bit还是32bit是不可取的。 如何测试？我们可以通过计算在操作系统中可寻址单元的个数，这样就可以计算出对应操作系统中一个地址的大小来区分64bit和32bit。编译器的位数要与操作系统一致。在32bit和64bit操作系统下姑且认为地址总线的条数分别是32条和64条(实际中不是这样的，但是可以这么理解)，那么形成的地址的大小分别是4字节和八字节。 测试代码： 12345#include&lt;cstdio&gt;int main(void)&#123; printf(sizeof(void*)&#x3D;&#x3D;8?&quot;64bit\\n&quot;:&quot;32bit\\n&quot;); return 0;&#125; 1.ubuntu64位2.Dev C++ 32bit 3.Dev C++ 64bit","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"冒泡排序、简单选择排序和插入排序(java实现)","slug":"冒泡排序、简单选择排序和插入排序(java实现)","date":"2018-10-16T23:48:16.000Z","updated":"2020-11-29T19:35:25.019Z","comments":true,"path":"2018/10/17/冒泡排序、简单选择排序和插入排序(java实现)/","link":"","permalink":"http://example.com/2018/10/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(java%E5%AE%9E%E7%8E%B0)/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Sort&#123; public stativ &lt;T&gt; void swao(T[] arr,int i,int j)&#123; T tmp &#x3D; arr[i]; arr[i]] &#x3D; arr[j]; arr[j] &#x3D; tmp; &#125; &#x2F;&#x2F;冒泡排序及其优化 public static &lt;T extends Compapable&lt;T&gt;&gt; void bubbleSort(T[] arr,int n)&#123; int i,j; boolean flag; T tmp; for(i &#x3D; 0;i&lt;n-1;++i)&#123; flag &#x3D; false; for(j &#x3D; 0;j&lt;n-1-i;++j)&#123; if(arr[j].compareTo(arr[j+1])&gt;0)&#123; flag &#x3D; true; swao(arr,j,j+1); &#125; &#125; if(flag &#x3D;&#x3D; false)break; &#125; &#125; &#x2F;&#x2F;选择排序及其优化 public static &lt;T extends Comparable&lt;T&gt;&gt; void selectSort(T[] arr,int n)&#123; int left &#x3D; 0; int right &#x3D; n-1; while(left &lt; right)&#123; int minIndex &#x3D; left; int maxIndex &#x3D; right; if(arr[minIndex].compareTo(arr[maxIndex])&gt;0)&#123; swap(arr,minIndex,maxIndex); &#125; for(int i&#x3D;left+1;i&lt;right;++i)&#123; if(arr[i].compareTo(arr[minIndex])&lt;0)&#123; minIndex &#x3D; i; &#125; else if(arr[i].compareTo(arr[maxIndex])&gt;0)&#123; maxIndex &#x3D; i; &#125; &#125; if(left!&#x3D;minIndex)&#123;swap(arr,left,minIndex);&#125; if(right!&#x3D;maxIndex)&#123;swap(arr,right,maxIndex);&#125; left++; right--; &#125; &#125; public static &lt;T extends Comparable&lt;T&gt;&gt; void insertSort(T[] arr,int n)&#123; for(int i&#x3D;1;i&lt;n;++i)&#123; T tmp &#x3D; arr[i]; int j; for(j&#x3D;i;j&gt;0 &amp;&amp; arr[j-1].compareTo(tmp)&gt;0;--j)&#123; arr[j] &#x3D; arr[j-1]; &#125; arr[j] &#x3D; tmp; &#125; &#125;&#125;","categories":[{"name":"数据结构 java","slug":"数据结构-java","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-java/"}],"tags":[]},{"title":"约瑟夫环模型问题的题解(java)","slug":"约瑟夫环模型问题的题解(java)","date":"2018-09-20T01:00:53.000Z","updated":"2020-11-29T19:35:25.027Z","comments":true,"path":"2018/09/20/约瑟夫环模型问题的题解(java)/","link":"","permalink":"http://example.com/2018/09/20/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3(java)/","excerpt":"","text":"1~10十个人进行编号，开始报数，报到3的人淘汰，剩余的人是编号为几的人？ 解题思路：设置一个长度为11的数组，其中索引为0的位置不进行编号，这索引和索引对应元素的值是意义对应的，即index==arr[index],被淘汰的人其元素值置为-1，用来标记其被淘汰。定义一个计数器count1来计数已经被淘汰的人，每当一个被淘汰时，计数器就加1。当计数器的值为9时，即10个人只剩一人，此时退出程序。此外还需要一个计数器count用来决策那个人会被淘汰，计数器数到3，计数器重置为0，淘汰一个人。 12345678910111213141516171819202122232425262728class Solution&#123; public static int circle()&#123; int[] arr &#x3D; new int[11];&#x2F;&#x2F;0索引不用，所以数组长度加1 for(int i&#x3D;1;i&lt;&#x3D;10;++i)&#123; arr[i] &#x3D; i; &#125; int index &#x3D; 0;&#x2F;&#x2F; int count &#x3D; 0; int count1 &#x3D; 0; while(true)&#123; index +&#x3D; 1； count +&#x3D; 1; &#x2F;&#x2F;超过数组长度时，需更新index index &#x3D; (index&gt;&#x3D;1 &amp;&amp; index&lt;&#x3D;10)?index:(index % arr.length)+1; if(3&#x3D;&#x3D;count)&#123; count &#x3D; 0; arr[index] &#x3D; -1; count1 +&#x3D; 1; &#125; if(9&#x3D;&#x3D;count1)break; &#125; for(int i&#x3D;1;i&lt;&#x3D;10;++i)&#123; if(arr[i]!&#x3D;-1) return i; &#125; return -1; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java反射","slug":"java反射","date":"2018-09-19T03:44:54.000Z","updated":"2020-11-29T19:35:26.019Z","comments":true,"path":"2018/09/19/java反射/","link":"","permalink":"http://example.com/2018/09/19/java%E5%8F%8D%E5%B0%84/","excerpt":"","text":"获取class对象的三种方法(1)调用Object类的getClass()方法，由于在java中所有的类都默认的继承了Object类，所以在派生类中都有getClass()方法。 1234567class People&#123;&#125;public class Test&#123; public stativ void main(String[] args)&#123; People p &#x3D; new People(); Class c &#x3D; p.getClass(); &#125;&#125; (2)使用Class类的forName()类(静态)方法获取，其参数为类或接口的全限定名，包名+类名。 1Class c &#x3D; Class.forName(&quot;java.lang.String&quot;); (3)使用类型名.class获取class对象。 1234Class c1 &#x3D; int.class;Class c2 &#x3D; double.class;Class c3 &#x3D; People.class;Class c4 &#x3D; int[].class;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java字符串切割小记","slug":"java字符串切割小记","date":"2018-09-19T02:26:24.000Z","updated":"2020-11-29T19:35:25.023Z","comments":true,"path":"2018/09/19/java字符串切割小记/","link":"","permalink":"http://example.com/2018/09/19/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"split方法（1）以一个字符串中的空格为界限切割为单词。 12345678910class Test&#123; public static void testSplit()&#123; &#x2F;&#x2F;切割后的字符串保存在String数组中 String str &#x3D; &quot;China American English Korea&quot;; String[] arr &#x3D; str.split(&quot;\\\\s&quot;); for(String it:arr)&#123; System.out.println(it); &#125; &#125;&#125; 运行结果：","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java中的异常","slug":"java中的异常","date":"2018-09-17T12:13:38.000Z","updated":"2020-11-29T19:35:26.295Z","comments":true,"path":"2018/09/17/java中的异常/","link":"","permalink":"http://example.com/2018/09/17/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/","excerpt":"","text":"Java中的异常 异常：直观的理解就是不正常，不完全正确，可能存在某些问题。在实际编写程序的过程中，往往可能出于疏忽而导致程序出现bug。典型的有数组越界，除0等，在c语言中由于考虑到程序实际的效率而未考虑数组下标越界引起的程序错误，如果在编写程序涉及到数组的边界问题而未考虑，几乎100%会发生如下的bug。合理的处理异常，会使得程序的健壮性，可读性以及可维护性得到大大的提高。 在java中，提供了优秀的异常机制，当程序出现在运行时期的异常和编译阶段的异常，提供解决错误的方法。 错误：是指系统出现错误或运行环境出现的错误，此类错误非常严重。即使捕捉到也不能够有效的处理，由java虚拟机生成并抛出，通常这类型的错误是由系统错误引起的。运行时期异常：是在运行时期可以被捕获的异常并能够做有效的处理，如果程序当中没有对这些可能存在的异常做处理，这些异常的处理通常由默认的异常处理程序进行处理。非运行时期异常：通常是一些语法、语义错误，此类错误通常在编写代码时，由集成开发环境(IDE)提示错误。下图是java中异常的层次结构： 在程序中显式的进行异常的处理 1.捕获可能存在的异常。通过try&#123;&#125;和catch(形式参数)&#123;&#125;代码块，其中catch(形式参数)&#123;&#125;代码块可以有多个，但是try&#123;&#125;代码块只有一个。也就是说一个try代码块可以搭配多个catch代码块，因为在可能存在异常的代码块中，可能存在各种不同类型的异常，但是每个catch代码块只能够捕捉到特定类型的异常，所以为了去处理每种类型的异常，就需要增加相应的catch块。注意：catch代码块的参数列表需要写对应类型的异常。当我们忘记可能发生异常的具体类型时间，可以使用Exception基类，因为在java中所有肯能出现的异常都继承Exception类，当然基类的引用是可以指向子类的方法的。(向上造型)，注意：在实际的编程中，并不推荐使用Exception的对象作为catch的实参，当有多个catch块时，只能有一个catch块可以使用Exception,否则若所有的catch块都使用Exception,当程序中有多个异常时，根本找不多异常到底是哪一个，正如前边所说的，一个catch块只处理对应的异常。如果所有的catch都想用Exception，那岂不是所有的问题都可以由一个catch来处理了，这显然是矛盾的。 123456789try&#123; &#x2F;&#x2F;书写可能出些异常的代码块&#125;catch(某种类型的异常)&#123; &#x2F;&#x2F;当出现异常时，对异常进行处理的代码块&#125;catch(另外一种类型的异常)&#123;&#125;finally&#123;&#125; 在catch代码块中，异常对象可以使用的两个比较有用的方法。(1)getMassage()方法，是Throwable类提供的一个方法，通过该方法的调用，可以得到有关异常的信息。(2)printStackTrace()方法，也是由Throwable提供的一个重载的方法，用于输跟踪异常事件发生时堆栈的内容。由于异常类都是直接或间接的继承Throwable类，因此子类中都是可以调用这两个方法的。值得一提的是finally代码块也是非常重要，尤其是在finally代码块中释放资源。finally代码块中的内容，无论之前的·catch·块是否对一场进行了处理，它都一定会执行。如对数据库的连接，若将数据库关闭的操作写在catch块中，但是并没有出现catch所能处理的异常。此时，数据库的连接并没有关闭，而数据库的连接是由上限的，当到达一定数量时，就不允许创建新的连接了。此时，如果将关闭数据库的代码在finally代码块中，就可以解决上边存在的问题。2.声明异常 （1）throws关键字，将方法执行时可能会出现的异常写在方法的头部，throws关键字后边声明多个异常，它们之间使用逗号隔开，这样调用该方法时就知道应该写什么样的代码来处理这些可能存在的异常，如果调用了声明的异常的方法，却并没有相应的catch块，这样的代码是不能编译通过的。一旦在编写代码的过程中调用了声明异常的方法，调用方就必须做相应的处理，否则编译是不能通过的。 1234567891011class Test&#123; void fun() throws Exception&#123; &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Test t &#x3D; new Test(); t.fun();&#x2F;&#x2F;不能编译通过 &#125;&#125; （2）并不是所有可能出现的异常的方法对所有的异常进行异常的声明，如运行时异常RuntimeException异常，它和它的子类不需要进行异常声明。在处理的异常的过程中，如果当前调用方不对异常进行处理，那么由它的上一级调用者处理，沿着调用的层次向上传递。 使用自定义的异常有时候，系统的提高的异常并不能完全够实际的开发使用，由于java的继承机制，可以很好的提高代码复用。可以通过继承基类Exception,编译自己的异常，以处理这些实际开发中可能存在的异常。 12345678910111213141516171819202122232425262728class MyException extends Exception&#123; MyException(String str)&#123; System.out.println(str); &#125;&#125;class Salary&#123; void fun(int n) throws MyException&#123; if(n &gt; 100000)&#123; throw new MyException(&quot;工资大于10000!&quot;) &#x2F;&#x2F;MyException e &#x3D; new MyException(&quot;工资大于10000!&quot;); &#x2F;&#x2F;throw e; &#x2F;&#x2F;以上的两种写法是等价的 &#125; &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Salary s &#x3D; new Salary; try&#123; s.fun(10010); &#125; catch(MyException e)&#123; e.printStackTrace; &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java素数筛选法","slug":"java素数筛选法","date":"2018-09-13T09:30:04.000Z","updated":"2020-11-29T19:35:26.283Z","comments":true,"path":"2018/09/13/java素数筛选法/","link":"","permalink":"http://example.com/2018/09/13/java%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95/","excerpt":"","text":"判断是否为素数对于一个任意一个正整数，如果它只能被自身或1整除，称其为素数，否则为合数。1比较特殊，既不是质数也不是合数。 基于素数的定义，很快就可以直观的想到代码，对于任意一个正整数，只需要在（1，n）也就是[2,n-1]之间进行遍历，如果n可以被区间中的任何一个数字整除，它就不是质数。否则，如果对整个区间遍历完毕，还未找到一个数字可以整除n，那么这个数字就是质数。 1234567891011public Test&#123; &#x2F;&#x2F;类方法 public static bool isPrime(int n)&#123; for(int i&#x3D;2;i&lt;&#x3D;n-1;++i)&#123; if(n%i&#x3D;&#x3D;0)&#123; return false; &#125; &#125; return true; &#125;&#125; 算法时间复杂度分析：对于上边穷举遍历暴力的方法，判断一个正整数是否为素数。所需的时间复杂度是O(n),然而在实际应用中，判断某一个数字是否为为素数只是整个程序当中的一小部分，这样的时间复杂度相对而言还是比较高的。下面将一种时间复杂度为O(n^(1/2))时间复杂的判断素数的算法。 数学背景：对于任意一个正整数N,可以将其分解为两个因数。特殊情况下N^(1/2)相等，即N=N^(1/2)*N^(1/2)。此外若存在两个因数，则其中一个必然大于N^(1/2)，而另外一个必然小于N^(1/2)。因此，只需要在区间[2,N^(1/2)]区间遍历即可，若在此区间存在一个正整数使得N被整除，则其为合数（此时这个因数小于N^(1/2)，而另外一个因数必然大于N^(1/2)），否则其为质数。进过这样的 处理可以显著的降低判断是否为质数算法的时间复杂度，达到O(n^(1/2))。 12345678910public Test&#123; public static bool isPrime(int n)&#123; for(int i&#x3D;2;i&lt;&#x3D;Math.sqrt(n*1.0);++i)&#123; if(n%i &#x3D;&#x3D; 0)&#123; return false; &#125; &#125; return true; &#125;&#125; 素数筛选法：从小到大遍历每一个数字，将其倍数筛去，剩下的即为素数。 12345678910111213141516171819202122232425262728293031323334353637class Test&#123; private boolean[] p;&#x2F;&#x2F;用于标记对应下标的数字是否为素数 private int[] prime; private int len&#x3D;0; &#x2F;&#x2F;构造方法 Test(int n)&#123; p &#x3D; new boolean[n]; prime &#x3D; new int[n]; &#125; public void prime(int n)&#123; for(int i&#x3D;2;i&lt;n;++i)&#123; if(p[i]&#x3D;&#x3D;false)&#123; prime[len++] &#x3D; i;&#x2F;&#x2F;false表示对应下标为素数 &#x2F;&#x2F;进行筛选 for(int j&#x3D;i+i;j&lt;n;j+&#x3D;i)&#123; p[j] &#x3D; true;&#x2F;&#x2F;标记不是素数 &#125; &#125; &#125; &#125; public void show(int n)&#123; for(int i&#x3D;0;i&lt;n;++i)&#123; System.out.print(prime[i]+&quot; &quot;); &#125; &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Test t &#x3D; new Test(100); t.prime(100); t.show(100); &#125;&#125; 输出100范围内的素数：","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java中Compareable接口思考","slug":"java中Compareable接口思考","date":"2018-09-11T15:48:34.000Z","updated":"2020-11-29T19:35:26.271Z","comments":true,"path":"2018/09/11/java中Compareable接口思考/","link":"","permalink":"http://example.com/2018/09/11/java%E4%B8%ADCompareable%E6%8E%A5%E5%8F%A3%E6%80%9D%E8%80%83/","excerpt":"","text":"在C++中，如果需要比较两个类对象。就不能直接通过&gt;,&lt;进行比较，引用对象不是基本数据类型。C++提供了运算符的重载函数得以解决这个问题。但是在java中没有运算符重载这一说，因此如果需要比较两个对象可能需要通过对象访问实例方法获取相应的值再做比较。无论从代码的的形式上还是方便理解的层面上都是不良好的。幸运的是在java中提供了一些接口，通过类实现这些接口就可以通过这些实例方法在对象之间做比较。 interface Compareable 12345678910111213141516171819class People implements Compareable&lt;People&gt;&#123; private String name; private int age; People(int age)&#123; this.age &#x3D; age; &#125; public int compareTo(People o)&#123; if(this.age&gt;o.age)&#123; return 1; &#125; else if(this.age&lt;o,age)&#123; return -1; &#125; else&#123; return 0; &#125; &#125;&#125; 测试代码： 1234567public class Main&#123; public static void main(String[] args)&#123; People p1 &#x3D; new People(10); People p2 &#x3D; new People(20); System.out.println(p1.compareTo(p2)); &#125;&#125; 执行结果：通过构建这样的类实例方法，无论从代码的简洁程度上还是程序的易读性和易维护性都得到了很大提高。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java基本数据类型转换为字符串","slug":"java基本数据类型转换为字符串","date":"2018-09-10T08:21:10.000Z","updated":"2020-11-29T19:35:26.267Z","comments":true,"path":"2018/09/10/java基本数据类型转换为字符串/","link":"","permalink":"http://example.com/2018/09/10/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"由于基本数据类型不能直接强制转换为引用数据类型，一种实际中存在的需求是。当我们需要将基本数据类型的值转换成为对应的字符串应该怎么做？因此，java提供了包装类将基本数据类型封装成类。通过调用类的toString()方法可以将基本数据类型的值转换成对应的字符串。 包装类Byte(byte),Short(short),Integer(int),Long(long)Float(float),Double(double),Character(char),Boolean(bool)通过这些类对基本数据类型的封装，调用toString()方法即可转换为对应的字符串。instanceof关键字是java中的一个运算符，是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。true表示对象是特定类的一个实例对象，否则不是。 测试代码： 123456789101112131415161718public class Main&#123; public static void main(String[] args)&#123; Character c &#x3D; new Character(&#39;c&#39;); if(c.toString() instanceof String)&#123; System.out.println(c.toString()); &#125; Integer i &#x3D; new Integer(10); if(i.toString() instanceof String)&#123; System.out.println(i.toString()); &#125; Double d &#x3D; new Double(12.25); if(d.toString() instanceof String)&#123; System.out.println(d.toString()); &#125; &#125;&#125; 运行结果：","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java类的初始化顺序","slug":"java类的初始化顺序","date":"2018-09-08T14:14:54.000Z","updated":"2020-11-29T19:35:26.271Z","comments":true,"path":"2018/09/08/java类的初始化顺序/","link":"","permalink":"http://example.com/2018/09/08/java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"了解类的初始化顺序对于编写正确的Java代码是非常重要的，尤其java是完全面向对象的语言，类作为整个程序编写的单位。构造方法静态实例变量实例变量静态块实例块 测试代码：所有类在同一包下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Test1&#123; public Test1()&#123; System.out.println(&quot;父类普通实例变量&quot;); &#125;&#125;class Test2&#123; public Test2()&#123; System.out.println(&quot;父类静态实例变量&quot;); &#125;&#125;class Test3&#123; public Test3()&#123; System.out.println(&quot;子类普通实例变量&quot;); &#125;&#125;class Test4&#123; public Test4()&#123; System.out.println(&quot;子类静态实例变量&quot;); &#125;&#125;class public Father&#123; private String Test1 p &#x3D; new Test1(); public static String Test2 &#x3D; q &#x3D; new Test2(); Father()&#123; System.out.println(&quot;父类构造方法&quot;); &#125; &#123; System.out.println(&quot;父类实例块&quot;); &#125; static&#123; System.out.println(&quot;父类静态块&quot;); &#125;&#125;class public Son extends Father&#123; private String Test3 p &#x3D; new Test3(); public static String Test4 &#x3D; q &#x3D; new Test4(); Son()&#123; System.out.println(&quot;子类构造方法&quot;); &#125; &#123; System.out.println(&quot;父类实例块&quot;); &#125; static&#123; System.out.println(&quot;父类静态块&quot;); &#125;&#125;在Main类中进行测试:public class Main&#123; public static void main(String[] args)&#123; Son s &#x3D; new Son(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"数字黑洞","slug":"数字黑洞","date":"2018-09-08T06:23:09.000Z","updated":"2020-11-29T19:35:26.251Z","comments":true,"path":"2018/09/08/数字黑洞/","link":"","permalink":"http://example.com/2018/09/08/%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/","excerpt":"","text":"数字黑洞简介：黑洞数又称陷阱数，是类具有奇特转换特性的整数。任何一个数字不全相同整数，经有限“重排求差”操作，总会得某一个或一些数，这些数即为黑洞数。“重排求差”操作即把组成该数的数字重排后得到的最大数减去重排后得到的最小数。—《互动百科》 下面看《算法笔记》上一个关于给定四位不完全相同的数字，演示到达：“数字黑洞的过程\"。 题目描述：给定一个各位数字完全不相同的四位正整数，如果先把四个数字按照非递排序(递增)，再按照非递减排序(递增)，然后用第一个数字减去第二个数字将得到一个重复的数字。一直重复怎样做，很快会停在有数字黑洞之称的6174，这个神奇的数字也叫Kaprekar常数。例如：从6767开始，将会得到7766 - 6677 = 10899810 - 0189 = 96219621 - 1268 = 83528543 - 2358 = 61747641 - 1467 = 6174…现在给定任意四位正整数，请编写程序演示到达数字黑洞的过程 输入格式：输入给出一个(0,10000)区间的正整数N。输出格式：如果N的四位数全相等，则在一行内输出”N - N = 0000”。否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意，每个数字按四位数格式输出。输入样例1:6767输出样例1：7766 - 6677 = 10899810 - 0189 = 96219621 - 1268 = 83528543 - 2358 = 6174输入样例2:2222输出样例2:2222 - 2222 = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;&#x2F;&#x2F;自定义排序规则，sort函数按照递增排序bool cmp(int a,int b)&#123; return a&gt;b;&#125;&#x2F;&#x2F;因为要获取当前数字按照每位排序的最大值和最小值&#x2F;&#x2F;将数字转换为数组方便排序void numToAarry(int num,int nums[])&#123; for(int i&#x3D;0;i&lt;4;++i)&#123; nums[i] &#x3D; num%10;&#x2F;&#x2F;获取当前数字的个位 num &#x2F;&#x3D; 10; &#125;&#125;&#x2F;&#x2F;排序完成后，将数组中已排好序的数字转换为数字int arrayToNum(int num,int nums[])&#123; int num &#x3D; 0; for(int i&#x3D;0;i&lt;4;++i)&#123; num &#x3D; num*10+nums[i]; &#125; return num;&#125;int main()&#123; int MAX; int MIN; int n; scanf(&quot;%d&quot;,&amp;n); while(1)&#123; int nums[4]; numToAarry(n,nums); sort(arr,arr+4);&#x2F;&#x2F;从小到达排序 MIN &#x3D; arrayToNum(nums); sort(arr,arr+4,cmp);&#x2F;&#x2F;从大到小排序 MAX &#x3D; arrayToNum(nums); n &#x3D; MAX-MIN; &#x2F;&#x2F;%4d小数点前不足四位时用0补齐 printf(&quot;%04d - %04d &#x3D; %d&quot;,MAX,MIN,n); if(n&#x3D;&#x3D;0 || n&#x3D;&#x3D;6174) break; &#125;&#125; 参考：《算法笔记》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"一个时间复杂度O(n)，空间复杂度为O(1)的排序算法","slug":"一个时间复杂度O(n)，空间复杂度为O(1)的排序算法","date":"2018-09-06T07:09:59.000Z","updated":"2020-11-29T19:35:26.267Z","comments":true,"path":"2018/09/06/一个时间复杂度O(n)，空间复杂度为O(1)的排序算法/","link":"","permalink":"http://example.com/2018/09/06/%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O(n)%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(1)%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"其实就是利用Hash的思想，开辟一个固定长度的hash数组用于标记待排序数组的数据元素是否出现过。由于固定长度的hash数组，所以空间复杂度与待排序数组数据规模n没有关系，也就是说空间复杂度为O(1)。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;排序能力，[0,65535]区间的数字，你也可以试试更大的const int MAXN &#x3D; 65535;bool hash[MAXN];template&lt;typename T&gt;void Sort(T arr[],int n)&#123; fill(hash,hash+MAXN,false); &#x2F;&#x2F;时间复杂度为O(n) for(int i&#x3D;0;i&lt;n;++i)&#123; hash[arr[i]] &#x3D; true;&#x2F;&#x2F;标记arr[i]出现过 &#125; &#x2F;&#x2F;时间复杂度为O(MAXN) int k&#x3D;0; for(int i&#x3D;0;i&lt;MAXN;++i)&#123; if(hash[i] &#x3D;&#x3D; true)&#123; arr[k++] &#x3D; i; &#125; &#125; 总的时间复杂度为O(n+MAXN),即O(n)&#125;void show(int arr[],int n)&#123; for(int i&#x3D;0;i&lt;n;++i) cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;int main()&#123; int arr [] &#x3D; &#123;5,6,9,2,3,7,4,1,8&#125;; int n &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); show(arr,n); return 0;&#125; 尝试测试一个这样的排序算法性能1.待排序元素值不能出现重复，否则会丢失掉重复的数据元素。2.对于一个几乎有序的待排序数组数组，其时间复杂任然为O(n)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"java生成随机数的两种方法","slug":"java生成随机数的两种方法","date":"2018-09-06T01:07:43.000Z","updated":"2020-11-29T19:35:26.271Z","comments":true,"path":"2018/09/06/java生成随机数的两种方法/","link":"","permalink":"http://example.com/2018/09/06/java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"1.使用Math类中的Math.random()方法 生成（0.1）区间的数字，因此当需要生成更大范围内的数字，需要在返回值的基础上扩大倍数以回去更大的随机值。 123456789101112import java.util.Randompublic class Main&#123; public static void main(String[] args)&#123; for(int i&#x3D;0;i&lt;5;++i)&#123; System.out.println(Math.Random()+&quot; &quot;); &#125; for(int i&#x3D;0;i&lt;5;++i)&#123; &#x2F;&#x2F;扩大随机数的范围（0，1000） System.out.println(1000*Math.Random()+&quot; &quot;); &#125; &#125;&#125; 静态成员方法可以通过类调用: 随机生成的结果： ![这里写图片描述](https://img-blog.csdn.net/20180906085608867?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSkJGSlNC/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![这里写图片描述](https://img-blog.csdn.net/20180906085728480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSkJGSlNC/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 2.通过Random类定义随机对象与Math类中的Math.random()方法不同的是，通过Random定义出来的对象，通过对象调用方法。可以获得不同范围内的随机数，而这个范围取决于你给定的范围。此外，获取随机数的类型也更多。 12345678import java.util.Random;public class Main&#123; public static void main(String[] args)&#123; Random rand &#x3D; new Random(); &#x2F;&#x2F;随机生成[0,1000)区间内的数字 rand.nextInt(1000); &#125;&#125; 可供选择生成随机数的类型","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"java指令集","slug":"java指令集","date":"2018-09-05T16:26:44.000Z","updated":"2020-11-29T19:35:26.359Z","comments":true,"path":"2018/09/06/java指令集/","link":"","permalink":"http://example.com/2018/09/06/java%E6%8C%87%E4%BB%A4%E9%9B%86/","excerpt":"","text":"1.栈和局部变量操作 ,将常量压入栈的指令 `aconst_null` 将null对象引用压入栈 `iconst_m1` 将int类型常量-1压入栈 `iconst_0` 将int类型常量0压入栈 `iconst_1` 将int类型常量1压入栈 `iconst_2` 将int类型常量2压入栈 `iconst_3` 将int类型常量3压入栈 `iconst_4` 将int类型常量4压入栈 `iconst_5` 将int类型常量5压入栈 `lconst_0` 将long类型常量0压入栈 `lconst_1` 将long类型常量1压入栈 `fconst_0` 将float类型常量0压入栈 `fconst_1` 将float类型常量1压入栈 `dconst_0`将double类型常量0压入栈 `dconst_1` 将double类型常量1压入栈 `bipush` 将一个8位带符号整数压入栈 `sipush `将16位带符号整数压入栈 `ldc `把常量池中的项压入栈 `ldc_w` 把常量池中的项压入栈（使用宽索引） `ldc2_w` 把常量池中long类型或者double类型的项压入栈（使用宽索引） 2.从栈中的局部变量中装载值的指令iload 从局部变量中装载int类型值lload 从局部变量中装载long类型值fload 从局部变量中装载float类型值dload 从局部变量中装载double类型值aload 从局部变量中装载引用类型值（refernce）iload_0 从局部变量0中装载int类型值iload_1 从局部变量1中装载int类型值iload_2 从局部变量2中装载int类型值iload_3 从局部变量3中装载int类型值lload_0 从局部变量0中装载long类型值lload_1 从局部变量1中装载long类型值lload_2 从局部变量2中装载long类型值lload_3 从局部变量3中装载long类型值fload_0 从局部变量0中装载float类型值fload_1 从局部变量1中装载float类型值fload_2 从局部变量2中装载float类型值fload_3 从局部变量3中装载float类型值dload_0 从局部变量0中装载double类型值dload_1 从局部变量1中装载double类型值dload_2 从局部变量2中装载double类型值dload_3 从局部变量3中装载double类型值aload_0 从局部变量0中装载引用类型值aload_1 从局部变量1中装载引用类型值aload_2 从局部变量2中装载引用类型值aload_3 从局部变量3中装载引用类型值iaload 从数组中装载int类型值laload 从数组中装载long类型值faload 从数组中装载float类型值daload 从数组中装载double类型值aaload 从数组中装载引用类型值baload 从数组中装载byte类型或boolean类型值caload 从数组中装载char类型值saload 从数组中装载short类型值 3.将栈中的值存入局部变量的指令 istore 将int类型值存入局部变量lstore 将long类型值存入局部变量fstore 将float类型值存入局部变量dstore 将double类型值存入局部变量astore 将将引用类型或returnAddress类型值存入局部变量istore_0 将int类型值存入局部变量0istore_1 将int类型值存入局部变量1istore_2 将int类型值存入局部变量2istore_3 将int类型值存入局部变量3lstore_0 将long类型值存入局部变量0lstore_1 将long类型值存入局部变量1lstore_2 将long类型值存入局部变量2lstore_3 将long类型值存入局部变量3fstore_0 将float类型值存入局部变量0fstore_1 将float类型值存入局部变量1fstore_2 将float类型值存入局部变量2fstore_3 将float类型值存入局部变量3dstore_0 将double类型值存入局部变量0dstore_1 将double类型值存入局部变量1dstore_2 将double类型值存入局部变量2dstore_3 将double类型值存入局部变量3astore_0 将引用类型或returnAddress类型值存入局部变量0astore_1 将引用类型或returnAddress类型值存入局部变量1astore_2 将引用类型或returnAddress类型值存入局部变量2astore_3 将引用类型或returnAddress类型值存入局部变量3iastore 将int类型值存入数组中lastore 将long类型值存入数组中fastore 将float类型值存入数组中dastore 将double类型值存入数组中aastore 将引用类型值存入数组中bastore 将byte类型或者boolean类型值存入数组中castore 将char类型值存入数组中sastore 将short类型值存入数组中wide指令wide 使用附加字节扩展局部变量索引4.通用(无类型）栈操作 nop 不做任何操作pop 弹出栈顶端一个字长的内容pop2 弹出栈顶端两个字长的内容dup 复制栈顶部一个字长内容dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2 复制栈顶部两个字长内容dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈swap 交换栈顶部两个字长内容 5.类型转换 i2l 把int类型的数据转化为long类型i2f 把int类型的数据转化为float类型i2d 把int类型的数据转化为double类型l2i 把long类型的数据转化为int类型l2f 把long类型的数据转化为float类型l2d 把long类型的数据转化为double类型f2i 把float类型的数据转化为int类型f2l 把float类型的数据转化为long类型f2d 把float类型的数据转化为double类型d2i 把double类型的数据转化为int类型d2l 把double类型的数据转化为long类型d2f 把double类型的数据转化为float类型i2b 把int类型的数据转化为byte类型i2c 把int类型的数据转化为char类型i2s 把int类型的数据转化为short类型 7.整数运算 iadd 执行int类型的加法ladd 执行long类型的加法isub 执行int类型的减法lsub 执行long类型的减法imul 执行int类型的乘法lmul 执行long类型的乘法idiv 执行int类型的除法ldiv 执行long类型的除法irem 计算int类型除法的余数lrem 计算long类型除法的余数ineg 对一个int类型值进行取反操作lneg 对一个long类型值进行取反操作iinc 把一个常量值加到一个int类型的局部变量上 8.逻辑运算 移位操作 ishl 执行int类型的向左移位操作lshl 执行long类型的向左移位操作ishr 执行int类型的向右移位操作lshr 执行long类型的向右移位操作iushr 执行int类型的向右逻辑移位操作lushr 执行long类型的向右逻辑移位操作按位布尔运算iand 对int类型值进行“逻辑与”操作land 对long类型值进行“逻辑与”操作ior 对int类型值进行“逻辑或”操作lor 对long类型值进行“逻辑或”操作ixor 对int类型值进行“逻辑异或”操作lxor 对long类型值进行“逻辑异或”操作浮点运算fadd 执行float类型的加法dadd 执行double类型的加法fsub 执行float类型的减法dsub 执行double类型的减法fmul 执行float类型的乘法dmul 执行double类型的乘法fdiv 执行float类型的除法ddiv 执行double类型的除法frem 计算float类型除法的余数drem 计算double类型除法的余数fneg 将一个float类型的数值取反dneg 将一个double类型的数值取反对象和数组对象操作指令new 创建一个新对象checkcast 确定对象为所给定的类型getfield 从对象中获取字段putfield 设置对象中字段的值getstatic 从类中获取静态字段putstatic 设置类中静态字段的值instanceof 判断对象是否为给定的类型数组操作指令newarray 分配数据成员类型为基本上数据类型的新数组anewarray 分配数据成员类型为引用类型的新数组arraylength 获取数组长度multianewarray 分配新的多维数组控制流条件分支指令ifeq 如果等于0，则跳转ifne 如果不等于0，则跳转iflt 如果小于0，则跳转ifge 如果大于等于0，则跳转ifgt 如果大于0，则跳转ifle 如果小于等于0，则跳转if_icmpcq 如果两个int值相等，则跳转if_icmpne 如果两个int类型值不相等，则跳转if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转ifnull 如果等于null，则跳转ifnonnull 如果不等于null，则跳转if_acmpeq 如果两个对象引用相等，则跳转if_acmpnc 如果两个对象引用不相等，则跳转比较指令lcmp 比较long类型值fcmpl 比较float类型值（当遇到NaN时，返回-1）fcmpg 比较float类型值（当遇到NaN时，返回1）dcmpl 比较double类型值（当遇到NaN时，返回-1）dcmpg 比较double类型值（当遇到NaN时，返回1）无条件转移指令goto 无条件跳转goto_w 无条件跳转（宽索引）表跳转指令tableswitch 通过索引访问跳转表，并跳转lookupswitch 通过键值匹配访问跳转表，并执行跳转操作异常athrow 抛出异常或错误finally子句jsr 跳转到子例程jsr_w 跳转到子例程（宽索引）rct 从子例程返回方法调用与返回方法调用指令invokcvirtual 运行时按照对象的类来调用实例方法invokespecial 根据编译时类型来调用实例方法invokestatic 调用类（静态）方法invokcinterface 调用接口方法方法返回指令ireturn 从方法中返回int类型的数据lreturn 从方法中返回long类型的数据freturn 从方法中返回float类型的数据dreturn 从方法中返回double类型的数据areturn 从方法中返回引用类型的数据return 从方法中返回，返回值为void线程同步montiorenter 进入并获取对象监视器monitorexit 释放并退出对象监视器JVM指令助记符变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_加：iadd,ladd,fadd,dadd减：isub,lsub,fsub,dsub乘：imul,lmul,fmul,dmul除：idiv,ldiv,fdiv,ddiv余数：irem,lrem,frem,drem取负：ineg,lneg,fneg,dneg移位：ishl,lshr,iushr,lshl,lshr,lushr按位或：ior,lor按位与：iand,land按位异或：ixor,lxor类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)创建类实便：new创建新数组：newarray,anewarray,multianwarray访问类的域和类实例域：getfield,putfield,getstatic,putstatic把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore获取数组长度：arraylength检相类实例或数组属性：instanceof,checkcast操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmplfcmpg,dcmpl,dcmpg复合条件转移：tableswitch,lookupswitch无条件转移：goto,goto_w,jsr,jsr_w,ret调度对象的实便方法：invokevirtual调用由接口实现的方法：invokeinterface调用需要特殊处理的实例方法：invokespecial调用命名类中的静态方法：invokestatic方法返回：ireturn,lreturn,freturn,dreturn,areturn,return异常：athrowfinally关键字的实现使用：jsr,jsr_w,ret","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"LeetCode 120.三角形的最小路径和（二维DP）","slug":"LeetCode 120.三角形的最小路径和（二维DP）","date":"2018-09-03T04:13:52.000Z","updated":"2020-11-29T19:35:26.223Z","comments":true,"path":"2018/09/03/LeetCode 120.三角形的最小路径和（二维DP）/","link":"","permalink":"http://example.com/2018/09/03/LeetCode%20120.%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%BA%8C%E7%BB%B4DP%EF%BC%89/","excerpt":"","text":"题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 分析：从题目中看出，第n行三角形中有n个数字。可以用一个二维数组存储数字三角形。需要找出自顶向下的最小路径和，则需要找到每一行的最小值。用dp[1][1]表示最小路径和。要找前两行的最小路径和,则需要找到与（1，1）下一行相邻的两个点（2，1）到底的最小路劲和（2，2），决策出最小的路径和，dp[1][1] = min(dp[2][1]，dp[2][2]) + f[1][1];对于dp[i][j]，则其求解为:dp[i][j] = min{dp[i+1][j],dp[i+1][j+1]}+f[i][j]。即为状态转移方程，将dp[i][j]称为状态。边界条件：对于最后一行，最小路径和即为元素自身的值。AC代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cassert&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int maxn &#x3D; 1000;int f[maxn][maxn];int dp[maxn][maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i&#x3D;1;i &lt;&#x3D; n;++i)&#123; for(int j&#x3D;1;j &lt;&#x3D; i;++j)&#123; scanf(&quot;%d&quot;,&amp;f[i][j]); &#125; &#125; for(int j&#x3D;1;j &lt;&#x3D; n;++j)&#123; dp[n][j] &#x3D; f[n][j]; &#125; for(int i&#x3D;n-1;i &gt;&#x3D; 1;--i)&#123; for(int j&#x3D;1;j &lt;&#x3D; i;++j)&#123; dp[i][j] &#x3D; f[i][j] + std::min(dp[i+1][j],dp[i+1][j+1]); &#125; &#125; printf(&quot;%d\\n&quot;,dp[1][1]); for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123; for(int j&#x3D;1;j &lt;&#x3D; i;++j)&#123; printf(&quot;dp[%d][%d]&#x3D;%d &quot;,i,j,dp[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 执行结果：","categories":[{"name":"算法基础 Leetcode","slug":"算法基础-Leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"}],"tags":[]},{"title":"fibonacci数列递归，动态规划，循环+递推三种方法的性能比较","slug":"fibonacci数列递归，动态规划，循环+递推三种方法的性能比较","date":"2018-09-02T06:08:27.000Z","updated":"2020-11-29T19:35:26.611Z","comments":true,"path":"2018/09/02/fibonacci数列递归，动态规划，循环+递推三种方法的性能比较/","link":"","permalink":"http://example.com/2018/09/02/fibonacci%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E5%BE%AA%E7%8E%AF+%E9%80%92%E6%8E%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/","excerpt":"","text":"斐波那契数列的定义1.n==1 || n==2 A(n) = 12.An = A(n-1)+A(n-2) 递归法： 12345678int fibonacci(int n)&#123; assert(n &gt; 0); &#x2F;&#x2F;递归出口 if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)&#123; return 1; &#125; return fiboancci(n-1)+fibonacci(n-2);&#125; 这样的递归算法时间复杂度达到了O(2^n)，当数据规模到达一定程度时，是不可接受的算法。为什么时间复杂度会如此之高，对于给定的一个项数n(n&gt;=2)，每次求解都需要两次进行递归，所以时间复杂度为O(2^n)。而其中还包括很多重复计算的子问题，如求解fib(4)已经知道了fib(2)，但是在计算fib(3)又一次求解了fib(2)，若给定的项数n较大时，其中包括非常之多的重复子问题。如何进行优化呢？ 动态规划（记忆化搜索）动态规划正是用来解决问题当中会出现重复子问题的方法。动态规划通过记录子问题的解，来避免当下次出现相同子问题时进行重复的计算。而通过递归写法的动态规划也称为记忆化搜索，通过递归记录子问题的解，一般将解存储在数组，而后通过索引找到对应问题的解。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;const int maxn &#x3D; 1000;int dp[maxn];&#x2F;&#x2F;全局的变量存储.data段,如果在函数中开辟会占用大量的栈空间long long fibonacci(int n)&#123; assert(n &gt; 0);&#x2F;&#x2F;防止传入错误的数据，进行断言 if(n &#x3D;&#x3D; 1||n &#x3D;&#x3D; 2)&#123; return 1; &#125; &#x2F;&#x2F;搜索是否有对应的解，没有则存储 if(dp[n] &#x3D;&#x3D; -1)&#123; dp[n] &#x3D; fibonacci(n-1)+fibonacci(n-2); &#125; return dp[n];&#x2F;&#x2F;搜索成功&#125;int main()&#123; memset(dp,-1,sizeof(dp));&#x2F;&#x2F;初始化记录解的dp数组 int n; &#x2F;&#x2F;注意fibonacci的项，太大会溢出 scanf(&quot;%d&quot;,&amp;n); printf(&quot;fib(%d) &#x3D; %lld\\n&quot;,n,fibonacci(n)); return 0;&#125; 通过记忆化搜索的方式，只需要O(n)的时间复杂度即可计算出fibonacci数列的第n的值，相比直接递归求解时间复杂度O(2^n)得到了大大的提升，算法的性能显著提高。 动态规划（循环+递推） 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;const int maxn &#x3D; 1000;int dp[maxn];int main()&#123; memset(dp,-1,sizeof(dp)); int n;&#x2F;&#x2F;注意输入的项数 scanf(&quot;%d&quot;,&amp;n); dp[0] &#x3D; 1; dp[1] &#x3D; 1; for(int i&#x3D;2;i &lt; n;++i)&#123; dp[i] &#x3D; dp[i-1]+dp[i-2];&#x2F;&#x2F;递推 &#125; printf(&quot;%d&quot;,dp[n-1]); return 0;&#125; 时间复杂度为O(n),在循环+递推写法的动态规划，相比递归的写法更好理解，但是其本质还是相同的。都是为了解决当问题中出现重复子问题而进行重复计算的问题。 值得注意的是，使用动态规划这种思想解决问题的前提是，一个问题当中必须有重复的子问题才能使用动态规划进行解决。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"LeetCode 283.Move Zeros","slug":"LeetCode 283.Move Zeros","date":"2018-08-27T02:28:06.000Z","updated":"2020-11-29T19:35:26.591Z","comments":true,"path":"2018/08/27/LeetCode 283.Move Zeros/","link":"","permalink":"http://example.com/2018/08/27/LeetCode%20283.Move%20Zeros/","excerpt":"","text":"题目描述：Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 样例输入：[0,1,0,3,12]样例输出：[1,3,12,0,0] 12345678910111213141516171819&#x2F;&#x2F;直观的方法就是，开辟一个数组用于保存所有非零元素&#x2F;&#x2F;遍历完成后回写到原数组中，之后添加对应个数的0元素void moveZeroes(int* nums, int numsSize) &#123; int nonzero[numsSize]; int k&#x3D;0;&#x2F;&#x2F;统计非零元素的个数 for(int i&#x3D;0; i&lt;numsSize; ++i)&#123; if(nums[i]) nonzero[k++] &#x3D; nums[i]; &#125; &#x2F;&#x2F;2.回写非零元素 int j&#x3D;0;&#x2F;&#x2F;记录新数组当前下标 for(int i&#x3D;0; i&lt;k; ++i)&#123; nums[j++] &#x3D; nums[i]; &#125; &#x2F;&#x2F;3.添加0,numsSize-k为零元素的个数 fpr(int i&#x3D;0; i&lt;numsSize-k; ++i)&#123; nums[k++] &#x3D; 0; &#125;&#125; 上述算法的时间复杂度为：O(n)，空间复杂度也为O(n)。上边的算法开辟了额外的数组用于存储非零元素，那么如何空间复杂度上进行优化，能能在原数组上直接操作即数据结构中的就地完成？ 1234567891011&#x2F;&#x2F;two pointers思想void moveZeroes(int* nums, int numsSize)&#123; int k&#x3D;0;&#x2F;&#x2F;标记非零元素 for(int i&#x3D;0;i&lt;numsSize;++i)&#123; if(nums[i]!&#x3D;0) nums[k++]&#x3D;nums[i] &#125; for(int i&#x3D;k;i&lt;numsSize;++i)&#123; nums[i]&#x3D;0; &#125;&#125; 交换零元素和非零元素 1234567891011121314void moveZeroes(int* nums, int numsSize)&#123; int k&#x3D;0; for(int i&#x3D;0;i&lt;numsSize;++i)&#123; if(nums[i])&#123; &#x2F;&#x2F;防止发生自交换，若数组中全为非零元素 if(i!&#x3D;k)&#123; swap(nums[k++],nums[i]); &#125; else&#123; k++; &#125; &#125; &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"}],"tags":[]},{"title":"指针值传递、地址传递和引用传递","slug":"指针值传递、地址传递和引用传递","date":"2018-08-26T01:32:40.000Z","updated":"2020-11-29T19:35:26.603Z","comments":true,"path":"2018/08/26/指针值传递、地址传递和引用传递/","link":"","permalink":"http://example.com/2018/08/26/%E6%8C%87%E9%92%88%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"","text":"一、指针的值传递 1234567891011121314151617&#x2F;&#x2F;test.c#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;void fun(char* p)&#123; p &#x3D; (char*)malloc(sizeof(char)); assert(p!&#x3D;NULL); strcpy(p,&quot;hello&quot;); &#x2F;&#x2F;free(p)&#125;int main(void)&#123; char* p &#x3D; NULL; fun(p); printf(&quot;p&#x3D;%s\\n&quot;,p);&#125; 执行结果中并未输出字符串hello其实这里主函数调用fun函数，形参向实参传递参数的时候，发生的是拷贝。在fun函数中对局部指针变量p的任何修改都不会影响到主函数中的指针变量p。下面简单的用函数栈帧空间图分析一下： 值传递，形参的修改不会影响到实参 二、指针的地址传递由于实参是一个一级指针的地址，要传入这样的地址给形参，这需要一个对应类型的二级指针来接受一级指针的地址。 1234567891011121314151617&#x2F;&#x2F;test.c#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;void fun(char** p)&#123; *p &#x3D; (char*)malloc(sizeof(char)*100); assert(*p !&#x3D; NULL); strcpy(*p,&quot;hello&quot;);&#125;int main(void)&#123; char* p &#x3D; NULL; fun(&amp;p); printf(&quot;p&#x3D;%s\\n&quot;,p); free(p); return 0;&#125; 上述代码的执行结果是：p=hello 指针的地址传递经常用在没有头节点的链表中，因为在创建和销毁链表时，头指针的值需要被修改。如果用一级指针接收发生的是值传递，要修改其值必须用二级指针接收一级指针的地址，在这个地址对应的内存块进行修改。 三、指针的引用传递用二级指针操作一级指针的内存往往让人难以理解，甚至往往还会发生内存泄漏的风险，在C++中，可以通过指针的引用简化这样的内存模型，实际上在编译器内部还是处理为二级指针，当使用时，解引用为一级指针，如对无头结点链表的初始化、销毁等操作，也可以使用一级指针的引用简化问题的处理。 12345678910111213141516&#x2F;&#x2F;test.cpp#include &lt;iostream&gt;using namespace std;void fun(char* &amp;p)&#123; p &#x3D; new char[100]; strcpy(p,&quot;hello&quot;);&#125;int main()&#123; char* p&#x3D;NULL; fun(p); cout&lt;&lt;&quot;p &#x3D; &quot;&lt;&lt;p&lt;&lt;endl; delete [] p; return 0;&#125; 怎么理解一级指针的引用传递呢，编译器在内存中开辟了临时量，用于存储引用变量的地址，一但使用引用变量就进行解引用。所以在外部看来，似乎就是使用了原变量，有兴趣的同学可以反汇编源代码。从汇编的角度去理解引用，看看底层语言是怎么处理引用的，相信会对引用有更深刻的理解。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"二维数组的探究","slug":"二维数组的探究","date":"2018-08-21T16:17:49.000Z","updated":"2020-11-29T19:35:26.623Z","comments":true,"path":"2018/08/22/二维数组的探究/","link":"","permalink":"http://example.com/2018/08/22/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"二维数组本质还是一维数组，数组中的每一个元素都是数组，这些元素具有相同的属性。既然是数组类型，其具备两个条件：1.数组元素的个数；2.数组元素的类型 验证二维数组本质是一维数组： 1234567891011void show(int* a,int n)&#123; for(int i&#x3D;0;i &lt; n;++i)&#123; printf(&quot;%d &quot;,a[i]); &#125;&#125;int main()&#123; int A[] &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; int len &#x3D; sizeof(A)&#x2F;sizeof(A[0][0]); show((int*)A,len); return 0;&#125; ![这里写图片描述](https://img-blog.csdn.net/20180821234314471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSkJGSlNC/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 在内存中，是没有二维数组的。二维数组也是连续存放的，只是在逻辑上的二维。 验证二维数组的步长： 123456test.cint A[][4] &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;printf(&quot;A:%d , A+1:%d&quot;,A,A+1);&#x2F;&#x2F;验证每一个元素的步长，即一维数组的长度printf(&quot;&amp;A:%d , &amp;A+1:%d&quot;,&amp;A,&amp;A+1);&#x2F;&#x2F;验证整个二维数组的步长 ![这里写图片描述](https://img-blog.csdn.net/2018082120480079?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSkJGSlNC/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 二维数组名：二维数组名代表第0行首元素的地址，类同于 一维数组名代表首元素的地址。二维数组首元素就是首行，这个关系是一致的。 123456int A[][4] &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;&#x2F;&#x2F;A： 代表第0行首地址&#x2F;&#x2F;A+i&lt;&#x3D;&gt;&amp;A[i]： 代表第i行首地址&#x2F;&#x2F;*(A+i)&lt;&#x3D;&gt;A[i]: 代表第i行首元素的地址&#x2F;&#x2F;*(A+i)+j&lt;&#x3D;&gt;&amp;A[i][j]: 代表第i行第j列元素的地址&#x2F;&#x2F;*(*(A+i)+j)&lt;&#x3D;&gt;A[i][j]: 代表第i行第j列元素的值 指向二维数组的数组指针 1234567int A[][4] &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int (*p)[4] &#x3D; A;&#x2F;&#x2F;注意不能写为int (*p)[4] &#x3D; &amp;A;&#x2F;&#x2F;&amp;A是指整个二维数组的首地址&#x2F;&#x2F;int (*p)[4];p指向元素类型为int，元素个数为4的一维数组int (*q)[][4] &#x3D; A; 二维数组做形式参数 123456789101112131415&#x2F;&#x2F;数组做参数时会退化指针，不同是指针的步长不相同void show(int (*A)[4])&#123; for(int i&#x3D;0;i&lt;3;++i)&#123; for(int j&#x3D;0;j&lt;4;++j)&#123; printf(&quot;%d &quot;,A[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; int A[][4] &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; show(A); return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"数组指针和指针数组","slug":"数组指针和指针数组","date":"2018-08-21T12:32:50.000Z","updated":"2020-11-29T19:35:26.595Z","comments":true,"path":"2018/08/21/数组指针和指针数组/","link":"","permalink":"http://example.com/2018/08/21/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","excerpt":"","text":"一、数组指针初学C语言的朋友对数组指针这指针数组感到迷惑，分不清，包括我自己，其实是对概念的不清晰以及对数组和指针这两个概念理解的不够深入，下面谈谈我的理解。数组指针，是一个指针而不是数组。这个指针具有指向整个数组的能力，保存这个数组的其实地址。定义数组指针变量 123456789101112131415161718192021222324251.先定义数组类型，根据类型定义指针变量typedef int A[5];&#x2F;&#x2F;A是数组类型。元素类型为int，元素个数为10A* p &#x3D; NULL;&#x2F;&#x2F;p是数组指针类型变量int a[5] &#x3D; &#123;0&#125;;p &#x3D; &amp;a;&#x2F;&#x2F;注意，不能写成 p&#x3D;a,两者类型是不相同的&#x2F;&#x2F;a代表数组首元素的地址，&amp;a代表整个数组的地址&#x2F;&#x2F;通过数组指针赋值for(int i&#x3D;0;i &lt; 5;++i)&#123; (*p)[i] &#x3D; i;&#125;&#x2F;&#x2F;sizeofsizeof(p);\\\\4 指针变量的大小，在32位下都是4sizeof(*p);\\\\20 指针指向空间的大小，即整个数组的大小2.先定义数组指针类型，根据类型定义变量typedef int (*A)[5];&#x2F;&#x2F;定义指向元素个数为5，元素类型为int的数组的指针类型Aint a[5]; A q &#x3D; &amp;a;&#x2F;&#x2F;用类型定义变量3.直接定义数组指针变量int a[5] &#x3D; &#123;1,2,3,4,5&#125;;int (*q)[5] &#x3D; &amp;a;&#x2F;&#x2F;q是数组指针变量 二、指针数组指针数组，是一个数组，而不是指针。数组中的每一个元素都是一个指针，这些元素构成的集合就是这个数组。 1234char* str[] &#x3D; &#123;&quot;China&quot;,&quot;American&quot;,&quot;Russia&quot;&#125;;&#x2F;&#x2F;数组中的每一个都是字符串常量&#x2F;&#x2F;字符串常量保存在.data段中的.rodata段&#x2F;&#x2F;实际上常量字符串就是一个指针，这个指针指向.rodata对应的常量字符串 指针数组的应用完整的main函数原型，int main(int arc,char* argv[],char* envp[])其中,两个数组分别保存命令行参数和环境变量(路径) 1234567#include&lt;cstdio&gt;int main(int argc,char* argv[],char* envp[])&#123; for(int i&#x3D;0;i &lt; argc;++i)&#123; printf(&quot;argv[%d] &#x3D; %s\\n&quot;,i,argv[i]); printf(&quot;envp[%d] &#x3D; %s\\n&quot;,i,envp[i]); &#125;&#125; 三、防止数组发生越界数组作为函数参数传递时，会退化为指针。为了提高程序执行的效率，C语言不做数组下标的安全性检查。如果进行了检查当数组数据量非常大时候会显著减低程序的效率，在安全性和高效率之间，权衡利弊之下。C语言选择了效率，因此在实际使用的情况下，尤其是在有数组参与函数调用的情况下，数组的长度需要作为函数的参数传递进去，防止出现错误，损坏堆栈的数据。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"Debug常用命令","slug":"Debug常用命令","date":"2018-08-21T04:42:47.000Z","updated":"2020-11-29T19:35:26.595Z","comments":true,"path":"2018/08/21/Debug常用命令/","link":"","permalink":"http://example.com/2018/08/21/Debug%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、简单介绍在windows32操作系统下可以使用debug.exe对可执行文件进行调试，可以看到底层的寄存器之间的数据传输。64位已经不支持运行16位的程序，因此想要在64位下完成debug调试可执行程序，需要安装32位模拟器DosBox，详细安装步骤请百度。二、常用命令（1）查看寄存器中的内容-r（2）单步执行-t测试代码： 12345678assume cs:codecode segment: start: mov ax,10 mov ax,4c00H int 21Hcode endsend start （3）查看内存的内容-d 1000:0 8，1000代表段寄存器的值，0是偏移地址。8代表查看8个字节（4）改写内存中的内容-e 1000:0修改后进行查看：-d 1000:0（5）将指定内存块的机器指令转化为汇编指令-u cs:0（6）以汇编语言的形式在内存中写入一段程序-a","categories":[],"tags":[]},{"title":"Codeup墓地 谁是你的潜在朋友","slug":"Codeup墓地 谁是你的潜在朋友","date":"2018-08-16T05:18:54.000Z","updated":"2020-11-29T19:35:26.607Z","comments":true,"path":"2018/08/16/Codeup墓地 谁是你的潜在朋友/","link":"","permalink":"http://example.com/2018/08/16/Codeup%E5%A2%93%E5%9C%B0%20%E8%B0%81%E6%98%AF%E4%BD%A0%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%9C%8B%E5%8F%8B/","excerpt":"","text":"问题描述： “臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会 并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。 首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。 输入 每个案例第一行两个整数N,M，2 &lt;= N ，M&lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;=P&lt;=M) 输出每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^） 样例输入 123454 52321 样例输出 12341BeiJu1BeiJu 123456789101112131415161718192021222324#include&lt;cstdio&gt;#define maxn 201int main()&#123; int n,m,P; int reader[maxn]; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!&#x3D;EOF)&#123; int booksum[maxn] &#x3D; &#123;0&#125;; for(int i&#x3D;0;i&lt;n;++i)&#123; scanf(&quot;%d&quot;,&amp;P); reader[i] &#x3D; P; booksum[P]++; &#125; for(int i&#x3D;0;i&lt;n;++i)&#123; int sum &#x3D; booksum[reader[i]]-1; if(sum!&#x3D;0)&#123; printf(&quot;%d&quot;,sum); &#125; else&#123; printf(&quot;BeiJu\\n&quot;); &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Hash初步(空间换时间的策略)","slug":"Hash初步(空间换时间的策略)","date":"2018-08-15T16:12:50.000Z","updated":"2020-11-29T19:35:26.599Z","comments":true,"path":"2018/08/16/Hash初步(空间换时间的策略)/","link":"","permalink":"http://example.com/2018/08/16/Hash%E5%88%9D%E6%AD%A5(%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E7%9A%84%E7%AD%96%E7%95%A5)/","excerpt":"","text":"问题描述：给定N个正整数，给定M个正整数。如N = {7，8，2，4}，M = {8，2}，查找集合M中的正整数是否在集合N出现过。 暴力枚举： 12345678910111213#include&lt;cstdio&gt;int main()&#123; int arr[N] &#x3D; &#123;7,8,2,4&#125;; int brr[M] &#x3D; &#123;8,2&#125;; for(int i&#x3D;0;i &lt; N;++i)&#123; if(int j&#x3D;0;j &lt; M;++i)&#123; if(arr[i] &#x3D;&#x3D; brr[j])&#123; printf(&quot;brr[%d] &#x3D;&#x3D; arr[%d]\\n&quot;,j,i); &#125; &#125; &#125;&#125; 这样的算法时间复杂度O(M*N)，显然随着问题规模度的增加，这样的算法是给糟糕的，难以接受的。而hash提供的思路是用空间换时间，设定一个bool的hashtable数组，以hashtable[x] = true表示数据x在集合N出现过。而对于处理M个欲查询的数字是否在N出现，时间复杂度O(M+N)，改善为线性阶的时间复杂度。而对于现代计算机来讲，存储空间已经不是制约算法性能的因素了，因此采用用空间换时间的策略是完全行得通的，甚至是优秀的。 12345678910111213141516171819202122&#x2F;&#x2F;hash.c#include&lt;cstdio&gt;#define bool int#define false 0#define true 1const int MAX &#x3D; 10000;bool HashTable[MAX] &#x3D; &#123;false&#125;;int main()&#123; int arr[] &#x3D; &#123;7,8,2,4&#125;; int N &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); int brr[] &#x3D; &#123;8,2&#125;; int M &#x3D; sizeof(brr)&#x2F;sizeof(brr[0]); for(int i&#x3D;0;i &lt; M:++i)&#123; HashTable[arr[i]] &#x3D; true; &#125; for(int j&#x3D;0;j &lt; N;++j)&#123; if(HashTable[brr[j]] &#x3D;&#x3D; true)&#123; printf(&quot;%d 出现过!\\n&quot;,brr[j]); &#125; &#125; return 0;&#125; 对于字符串问题的处理，hash这样的处理方式往往是利器！","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"全排列（permutation）","slug":"全排列（permutation）","date":"2018-08-15T13:38:36.000Z","updated":"2020-11-29T19:35:26.595Z","comments":true,"path":"2018/08/15/全排列（permutation）/","link":"","permalink":"http://example.com/2018/08/15/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88permutation%EF%BC%89/","excerpt":"","text":"显然，对于具有n个元素的集合R,R={r1,r2,r3…rn},其排列方式有n!种。如：R = {1,2,3}，其全排列如下：1，2，31，3，22，1，32，3，13，1，23，2，1从上边的排列中可以看出规律，以集合中某一元素作为第一个数字，集合当中的其余数字做全排列。而其余数字组成的集合可以看作是子集合，子集合中的第一个元素作为第一个数字，子集合当中的其余数字做全排列。可以看出，这是一个递归过程。有了上面的思想，可以容易的写出一个递归算法解决全排列的问题。 代码实现： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;&#x2F;&#x2F;交换数组的i项和j项void swap(int A[],int i,int j)&#123; int temp &#x3D; A[i]; A[i] &#x3D; A[j]; A[j] &#x3D; temp;&#125;void show(int A[],int n)&#123; for(int i&#x3D;0;i &lt; n;++i)&#123; printf(&quot;%d &quot;,A[i]); &#125; printf(&quot;\\n&quot;);&#125;&#x2F;&#x2F;对数组做排列,p,q之间做全排列void permutation(int A[],int p,int q)&#123; &#x2F;&#x2F;递归出口，只有一个元素时。全排列就是其本身 if(p &#x3D;&#x3D; q)&#123; show(A,q+1);&#x2F;&#x2F;数组是从0下标开始的 &#125; for(int i&#x3D;p;i &lt;&#x3D; q;++i)&#123; swap(A,p,i); perm(A,p+1,q);&#x2F;&#x2F;子集合做全排列 swap(A,p,i);&#x2F;&#x2F;恢复，否则会有重复 &#125;&#125; test1.c 12345int main()&#123; int arr[] &#x3D; &#123;1,2,3&#125;; permutation(arr,0,2); return 0;&#125; test2.c","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"进制转换","slug":"进制转换","date":"2018-08-14T15:49:56.000Z","updated":"2020-11-29T19:35:26.599Z","comments":true,"path":"2018/08/14/进制转换/","link":"","permalink":"http://example.com/2018/08/14/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"P进制数转换为十进制数，采用按权展开相加。 123456789int p;&#x2F;&#x2F;p进制int x;&#x2F;&#x2F;p进制数字int product&#x3D;1;&#x2F;&#x2F;任何权值的0次幂均为1int y;&#x2F;&#x2F;输出的十进制数字while(x !&#x3D; 0)&#123; y &#x3D; y+(x%10)*product;&#x2F;&#x2F;(x%10)获取x的个位数字 product *&#x3D; p;&#x2F;&#x2F;获取下一位的权值 x &#x2F;&#x3D; 10;&#x2F;&#x2F;去掉x的个位数字&#125; 十进制数字转换为Q进制数字，采用除基取余法。 1234567891011#define MAX 20int Q;&#x2F;&#x2F;Q进制int y;&#x2F;&#x2F;十进制数字int ans[MAX] &#x3D; &#123;0&#125;;&#x2F;&#x2F;存放Q进制数的每一位int num&#x3D;0;&#x2F;&#x2F;位数do&#123; ans[num++] &#x3D; y % Q; y &#x2F;&#x3D; Q;&#125;while(y!&#x3D;0)ans[0...num-1]，逆序输出可以得到Q进制数字的每一位","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"二分查找的递归和非递归","slug":"二分查找的递归和非递归","date":"2018-08-14T15:08:36.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/14/二分查找的递归和非递归/","link":"","permalink":"http://example.com/2018/08/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92/","excerpt":"","text":"二分查找的前提是数据有序，二分查找的性能十分优秀。时间复杂度为O(log2n)非递归 1234567891011121314151617181920int binsearch(int arr[],int len,int value)&#123; &#x2F;&#x2F;low和high指向当前查找区间的两端,value为查找的关键字 int low&#x3D;0; int high&#x3D;len-1; int mid;&#x2F;&#x2F;当前区间的中间 while(low &lt;&#x3D; high)&#123; mid &#x3D; low + (high-low)&#x2F;2; &#x2F;&#x2F;mid &#x3D; (low+high)&#x2F;2;这样的写法会有整型相加溢出的bug if(arr[mid] &#x3D;&#x3D; value)&#123; return mid;&#x2F;&#x2F;返回下标 &#125; if(value &lt; arr[mid])&#123; high &#x3D; mid-1; &#125; else&#123; low &#x3D; mid+1; &#125; &#125; return -1;&#x2F;&#x2F;未查找到返回-1&#125; 递归 12345678910111213141516int binsearch(int arr[],int left,int right,int value)&#123; &#x2F;&#x2F;递归出口 if(left &gt; right)&#123; return -1; &#125; mid &#x3D; low + (high-low)&#x2F;2; if(arr[mid] &#x3D;&#x3D; value)&#123; return mid; &#125; else if(arr[mid] &gt; value)&#123; return binsearch(arr,left,mid-1,value); &#125; else&#123; return binsearch(arr,mid+1，right,value); &#125;&#125; 顺序查找的时间复杂度为O(n)，相对于二分查找性能较差 12345678int seqsearch(int arr[],int len,int value)&#123; for(int i&#x3D;0;i &lt; len;++i)&#123; if(arr[i] &#x3D;&#x3D; value)&#123; return i; &#125; &#125; return -1;&#x2F;&#x2F;未查找到返回-1&#125;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"使用vs2008编译器自带的命令行工具查看类的内存布局","slug":"使用vs2008编译器自带的命令行工具查看类的内存布局","date":"2018-08-14T11:58:35.000Z","updated":"2020-11-29T19:35:26.899Z","comments":true,"path":"2018/08/14/使用vs2008编译器自带的命令行工具查看类的内存布局/","link":"","permalink":"http://example.com/2018/08/14/%E4%BD%BF%E7%94%A8vs2008%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%B8%A6%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","excerpt":"","text":"测试代码: 1234567891011121314151617#include&lt;iostream&gt;using namespace std;class Base&#123;protected: int _a;&#125;; class Derive:public Base&#123;public: int _b;&#125;;int main()&#123; return 0;&#125; 1.打开命令行工具2.输入源文件路径3.输入cl main.cpp /d1reportSingleClassLayout Derivr(类名)，最后加类名。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"随机点名程序实现","slug":"随机点名程序实现","date":"2018-08-14T08:34:34.000Z","updated":"2020-11-29T19:35:26.899Z","comments":true,"path":"2018/08/14/随机点名程序实现/","link":"","permalink":"http://example.com/2018/08/14/%E9%9A%8F%E6%9C%BA%E7%82%B9%E5%90%8D%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"代码：test.cpp 1234567891011121314#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; srand(time(NULL)); &#x2F;&#x2F;种下随机种子，否则rand()函数返回的是伪随机数 string name[] &#x3D; &#123;&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;zhaoliu&quot;,&quot;wangwu&quot;&#125;; int len &#x3D; sizeof(str)&#x2F;sizeof(str[0]); cou t&lt;&lt; str[rand()%len] &lt;&lt; endl;&#x2F;&#x2F;输出随机到的名字 return 0;&#125; 执行结果：","categories":[{"name":"编程练习","slug":"编程练习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"C++ OOP思想","slug":"C++ OOP思想","date":"2018-08-05T16:36:27.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/06/C++ OOP思想/","link":"","permalink":"http://example.com/2018/08/06/C++%20OOP%E6%80%9D%E6%83%B3/","excerpt":"","text":"oop思想","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"Linux中查看进程的虚拟地址空间内存布局","slug":"Linux中查看进程的虚拟地址空间内存布局","date":"2018-08-05T03:43:39.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/05/Linux中查看进程的虚拟地址空间内存布局/","link":"","permalink":"http://example.com/2018/08/05/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","excerpt":"","text":"要查看一个进程的虚拟地址空间的内存布局，需要设置阻塞。如果没有设置阻塞，当./a.out按下去后，程序执行的速度非常快以至于来不及查看，所以需要设置阻塞。 1234567891011#include&lt;stdio.h&gt;int a;static int b&#x3D;10;int main(int argc,char* argv[],char* envp[])&#123; int a&#x3D;10;&#x2F;&#x2F;stack char* p&#x3D;(char*)malloc(sizeof(char));&#x2F;&#x2F;heap printf(&quot;a&#x3D;%d,p&#x3D;0x%x\\n&quot;,a,p);&#x2F;&#x2F;动态链接库，*.so getchar();&#x2F;&#x2F;设置阻塞 getchar(); return 0;&#125; 1. gcc test.c -&gt; a.out2. ./a.out &amp;放在后台执行3. ps -u查看进程id4. cat /proc/进程id/maps 输出进程虚拟地址空间的布局","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"c和c++的区别 （四）动态内存开辟、c/c++作用域","slug":"c和c++的区别 （四）动态内存开辟、c!c++作用域","date":"2018-08-05T03:15:48.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/05/c和c++的区别 （四）动态内存开辟、c!c++作用域/","link":"","permalink":"http://example.com/2018/08/05/c%E5%92%8Cc++%E7%9A%84%E5%8C%BA%E5%88%AB%20%EF%BC%88%E5%9B%9B%EF%BC%89%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F%E3%80%81c!c++%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"一、动态内存开辟C：malloc，freeC++：new，delete。new的底层调用任然是malloc，但相对于malloc，new具有初始化的功能。对于内置类型可以直接初始化，对于自定义类型，调用构造函数初始化。delete首先会进行析构，然后调用free。 123456789101112131415161718192021222324252627int main()&#123; 内置类型内存的动态开辟： int* p&#x3D;(int*)malloc(sizeof(int)); free(p); int* q&#x3D;new int(10); delete q; 一维数组的动态开辟： int* p&#x3D;(int*)malloc(sizeof(int)*100); free(p); int* q&#x3D;new int[100]; delete []q; 二维数组的动态开辟： 如3*4： int main()&#123; int **p&#x3D;new int*[3]; for(int i&#x3D;0;i &lt; 3;++i)&#123; p[i] &#x3D; new int[4]; &#125; for(int i&#x3D;0;i &lt; 3;++i)&#123; delete []p[i]; &#125; delete []p; return 0;&#125; 1.默认的new开辟内存失败，不能以NULL作为判断。当new动态开辟内存失败时，会抛出异常 throw bad_alloc(“”)。 123456try&#123; int *p&#x3D;new int(10);&#125;catch(const bad_alloc &amp;err)&#123; &#125; 2.int* p=new (nothrow) int(10);可以通过返回值是否为NULL判断动态开辟是否成功。 3.在堆上开辟常量内存。 123在堆上开辟常量内存const int* p &#x3D; new const int(10);const int* q &#x3D; new const int[10]; 4.定位new placement new 12345678char buffer[1000] &#x3D; &#123;0&#125;;char* p &#x3D; new (buffer) char[100];&#x2F;&#x2F;在buff上开辟100字节内存int* p &#x3D; new int;p &#x3D; new (p) int(10);int* p&#x3D;(int*)operator new(sizeof(int)); &#x2F;&#x2F;mallocp &#x3D; new (p) int(10);&#x2F;&#x2F;初始化 二、C/C++作用域C作用域：（1）全局作用域（2）局部作用域 C++作用域：（1）局部作用域（2）类作用域（3）名字空间作用域namespace，又分为局部的名字作用域和全局的名字作用域 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F;MyName不参与编译，不产生符号namespace MyName&#123; int data&#x3D;10; int sum(int a,int b)&#123;return a+b;&#125;&#125;&#x2F;&#x2F;int data&#x3D;20;&#x2F;&#x2F;using 声明，下边这样的声明方式，一次只能声明一个符号using MyName::data;using MyName::sum;using namespace MyName;&#x2F;&#x2F;声明整个名字空间MyName中的符号int main()&#123; int data&#x3D;30; cout&lt;&lt;data&lt;&lt;endl;&#x2F;&#x2F;优先使用局部的 cout&lt;&lt;::data&lt;&lt;endl;&#x2F;&#x2F;::全局的作用域符号 cout&lt;&lt;MyName::data&lt;&lt;endl;&#x2F;&#x2F;MyName名字空间&#125; 在名字空间定义变量的好处是，可以在不同作用域定义同名的变量，而不致引起冲突。可以定义多个同名的名字空间，在编译的时候进行合并。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"c和c++的区别 （三）const&(引用)和const*(地址)在函数中的应用","slug":"c和c++的区别 （三）const&(引用)和const!(地址)在函数中的应用","date":"2018-08-04T16:22:58.000Z","updated":"2020-11-29T19:35:26.859Z","comments":true,"path":"2018/08/05/c和c++的区别 （三）const&(引用)和const!(地址)在函数中的应用/","link":"","permalink":"http://example.com/2018/08/05/c%E5%92%8Cc++%E7%9A%84%E5%8C%BA%E5%88%AB%20%EF%BC%88%E4%B8%89%EF%BC%89const&(%E5%BC%95%E7%94%A8)%E5%92%8Cconst!(%E5%9C%B0%E5%9D%80)%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、用普通引用接收返回值 1234567891011int GetInt()&#123; int value&#x3D;10; return value;&#x2F;&#x2F;返回值通过eax寄存器带回&#125;int main()&#123; int &amp;a&#x3D;GetInt();&#x2F;&#x2F;错误 &#x2F;&#x2F;引用初始化的值要能取地址，寄存器没有地址 修改为:const int&amp; a&#x3D;GetInt(); return 0;&#125; 二、返回局部变量的地址 123456789101112&#x2F;&#x2F;不能返回局部变量的地址或引用int* GetIntPtr()&#123; int value&#x3D;10; &#x2F;&#x2F;const int value&#x3D;10;是数据,在.data段,这种情况可以返回地址 return &amp;value; &#x2F;&#x2F;lea eax,[value]&#125;int main()&#123; int* p&#x3D;GetIntPtr(); eax-&gt;p return 0;&#125; 三、返回.data段变量的地址 1234567891011int* GetIntPtr()&#123; static int value&#x3D;10; return &amp;value; &#x2F;&#x2F;lea eax,[value]&#125;int main()&#123; int *&amp;p&#x3D;GetIntPtr();&#x2F;&#x2F;错误，引用初始化的值要能取地址 &#x2F;&#x2F;修改为常引用:int* const&amp;p&#x3D;GetIntPtr(); return 0;&#125; 四、返回局部变量的引用 123456789&#x2F;&#x2F;不能返回局部变量的引用int&amp; GetIntRef()&#123; int value&#x3D;10;&#x2F;&#x2F;const int value&#x3D;10;是正确的 return value; &#x2F;&#x2F;lea eax,[value]&#125;int main()&#123; int a&#x3D;GetIntRef(); *eax-&gt;p&#125; 五、返回指针的地址、返回指针的引用 12345678910int** GetIntPtrPtr()&#123; static int data&#x3D;10; static int* p&#x3D;&amp;data; return &amp;p;&#x2F;&#x2F;通过eax寄存器带回&#125;int*&amp; GetIntPtrRef()&#123; static int data&#x3D;10; static int *p&#x3D;&amp;data; return p;&#125; 临时量的产生由三种不同的情况： 1231.函数调用之前2.函数的return语句处3.函数调用之后","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C/C++函数返回值问题","slug":"C!C++函数返回值问题","date":"2018-08-04T15:28:58.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/04/C!C++函数返回值问题/","link":"","permalink":"http://example.com/2018/08/04/C!C++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/","excerpt":"","text":"函数返回值问题在C/C++中内置类型：char short int long float double结构体类型、联合体类型union、枚举类型enum 函数返回值分为三种情况：1.函数返回值小于等于4字节时，返回值由eax寄存器带回。 123456int fun(int a,int b)&#123;return a+b;&#125;int main()&#123; int a&#x3D;10; int b&#x3D;10; int ret&#x3D;sum(a,b);&#125; 2.函数返回值大于4字节小于等于时，返回值是由eax和edx寄存器带回。 1234567891011121314151617typedef struct data&#123; int x; int y;&#125;Data;Data sum(Data a,Data b)&#123; Data c; c.x&#x3D;a.x+b.x; c.y&#x3D;a.y+b.y; return c;&#125;int main()&#123; Data a&#x3D;&#123;1,2&#125;; Data b&#x3D;&#123;3,4&#125;; Data ret&#x3D;sum(a,b); return 0;&#125; 3.函数返回值大于8个字节，产生临时量。函数调用之前就产生，被调用函数return处通过ebp+8进行访问。 12345678910111213141516typedef strut&#123; int a[20];&#125;Data;Data sum(Data a,Data b)&#123; Data temp &#x3D; &#123;0&#125;; temp.a[0]&#x3D;a.a[0]+b.a[0]; return temp;&#125;int main()&#123; Data a &#x3D; &#123;0&#125;; Data b &#x3D; &#123;0&#125;; Data ret &#x3D; sum(a,b); return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"c和c++的区别（二）const和引用、一级指针、二级指针的结合","slug":"c和c++的区别（二）const和引用、一级指针、二级指针的结合","date":"2018-08-04T01:07:20.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/04/c和c++的区别（二）const和引用、一级指针、二级指针的结合/","link":"","permalink":"http://example.com/2018/08/04/c%E5%92%8Cc++%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89const%E5%92%8C%E5%BC%95%E7%94%A8%E3%80%81%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E3%80%81%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E7%BB%93%E5%90%88/","excerpt":"","text":"一、const和一级指针的结合 一级指针的模型一级指针有两种表达方式，p和*p。所以const与一级指针有两种结合方式。 1234567891011121314&#x2F;&#x2F;在c++语法规则中，const修饰距离它最近的类型。int a&#x3D;10;int *p&#x3D;&amp;a;int const *p;&#x2F;&#x2F;距离const最近的类型是int,而不是int*,因为int已经是类型了&#x2F;&#x2F;const的是*p,p本身没有被const修饰const int *p;&#x2F;&#x2F;距离const最近的是int,*不能构成类型。const修饰的是*p,p没有被修饰int* const p;&#x2F;&#x2F;距离const最近的类型是int*,修饰的是一个指针变量p。但*p没有被修改&#x2F;&#x2F;存在内存泄漏const int* const p;&#x2F;&#x2F;距离第一个const最近的类型是int,修饰的是*p。距离第二个const的类型&#x2F;&#x2F;是int*,所以修饰的p。 在C++中，定义常量必须进行初始化。那么上边四个哪些是常量？ 123456int a&#x3D;10;int *p&#x3D;&amp;a;int const *p;&#x2F;&#x2F;const修饰*p，但是没有修饰p。p可更改，故不是常量。const int *p;&#x2F;&#x2F;const修饰*p,没有修饰p。p可更改，故不是常量。int* const p;&#x2F;&#x2F;const修饰的是p,是常量。const int const* p;&#x2F;&#x2F;变量名p本身被const修饰，故是常量。 123456int main()&#123; int a&#x3D;10; const int b&#x3D;20; a&#x3D;b;&#x2F;&#x2F;正确，将常量值赋值给变量 b&#x3D;a;&#x2F;&#x2F;错误，常量不能作左值&#125; 在C++中，当const关键字修饰常量时，const所在的位置，会不会出现问题。主要是担心代码会修改被const修饰的常量值，如果有这样的风险，编译器不会通过代码的编译的。 修改的方式有两种：1.直接修改 直接修改比较容易判断，看常量是否作左值。2.间接修改 会不会将常量的引用或地址泄漏出去，通过使用引用（使用引用会自动解引用）或指针间接修改常量。 123一级指针与const结合总结：const int* -&gt; int* &#x2F;&#x2F;错误int* -&gt; const int* &#x2F;&#x2F;正确 测试一：test.cpp 123456789101112131415int main()&#123; &#x2F;* int a&#x3D;10; int *p&#x3D;&amp;a;&#x2F;&#x2F;&amp;a int* 正确的赋值 *&#x2F; const int b&#x3D;10; int *p &#x3D; &amp;b; const int* q &#x3D; &amp;b; &#x2F;&#x2F;&amp;b -&gt; const int* ,将常量的地址泄漏出去了 &#x2F;&#x2F;但是泄漏出去不一定是错误的，且看下边的例子 *p&#x3D;20;&#x2F;&#x2F;错误，可以通过*p修改b内存块的地址。const没有修饰*p &#x2F;&#x2F;存在间接修改常量内存块的风险,编译是不通过的 *q&#x3D;20;&#x2F;&#x2F;此时q为const int*,不能作左值，编译错误&#125; 测试二：test1.cpp 1234567891011121314int main()&#123;&#x2F;&#x2F;对于const int*,可以存储常量的地址，也可以存储变量的地址 int a&#x3D;10;&#x2F;&#x2F; const int a&#x3D;10; const int* p&#x3D;&amp;a; int* q&#x3D;p;&#x2F;&#x2F;直观的感受q就是&amp;a啊，a是变量，可以通过*q修改a &#x2F;*但是编译是错误的，为什么呢？ 对于const int* p,其类型为const int*，不管存储的常量的地址 还是变量的地址，都按照其类型存储，即const int*，即使是存储 的是变量的地址也会提升为常量的地址。 int *q&#x3D;p;*q并没被const的修饰，所以会出现编译错误 *&#x2F; 可见，其实const int*里边存储与变量a无关 return 0;&#125; 测试三：test2.cpp 12345test2.cppint main()&#123; const int* p&#x3D;NULL; int* q&#x3D;p;&#125; 测试四：test3.cpp 1234567891011121314&#x2F;&#x2F;输出类型test3.cpp#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123; int a&#x3D;10; int const *p&#x3D;&amp;a; int *const q&#x3D;&amp;a; cout&lt;&lt;typeid(p).name()&lt;&lt;endl; cout&lt;&lt;typeid(q).name()&lt;&lt;endl; return 0;&#125; 有上图结果可知，const没有修饰*（指针）/&amp;（引用），不用考虑。 二、const和引用的结合定义引用时，由于&amp;和变量名紧挨着。所以const和引用结合只有一种方式，即const int &amp;变量名或int const &amp;变量名，而不会出现int &amp;const 变量名这种形式。 123456789101112int main()&#123; &#x2F;&#x2F;int a&#x3D;10; &#x2F;&#x2F;int &amp;b&#x3D;a; &#x2F;&#x2F;const int &amp;c&#x3D;a; const int a&#x3D;10; int &amp;b&#x3D;a;&#x2F;&#x2F;错误，将a的引用泄露出去，通过对b赋值可以修改常量 &#x2F;&#x2F;对于常变量只能使用常引用 const int a&#x3D;10; const int&amp; b&#x3D;a; return 0;&#125; 常引用const&amp;引用常量(包括可寻址的常量和不可寻址的常量) 12345int main()&#123; int &amp;a&#x3D;10;&#x2F;&#x2F;错误，不能用立即数进行初始化 const int &amp;b&#x3D;10;&#x2F;&#x2F;正确的，为什么呢？ return 0;&#125; 从汇编的角度看看常引用为什么是可行的，往往越底层的东西越能带来透彻的理解。 12345678const int&amp; a&#x3D;10;mov dword ptr[ebp-14h],OAh&#x2F;&#x2F;函数栈帧空间以栈底指针ebp的偏移量offset表示栈空间的地址&#x2F;&#x2F;将OAh(10)存到[ebp-14h]指向的四字节的内存空间中mov eax,[ebp-14h]&#x2F;&#x2F;将地址[ebp-14h]存放到eax寄存器中mov dword ptr[a],eax&#x2F;&#x2F;将eax寄存器中的内容即[ebp-14h]存放到地址为a四字节的空间[a]中 通过上边汇编代码的分析，所谓常引用，实际上是在内存中寻取了一块空间，作为临时量，存放立即数。而引用则是对这块内存空间即临时量的引用。 123const int &amp;a&#x3D;10;&#x2F;&#x2F;可以看作是下边两行代码const int temp&#x3D;10;const int &amp;a&#x3D;temp; 指针变量与常引用结合 12345678910111213如现在要向地址为0x0011ff22内存块写入10,定义指针的引用变量int main()&#123; int *&amp;p &#x3D; (int*)0x0011fff22;*p&#x3D;10; &#x2F;&#x2F;显然这是错误，引用不能用立即数初始化 &#x2F;&#x2F;结合上边的常引用 const int*&amp;p还是int* const &amp;p哪一个是正确的呢? const int*&amp;p其中,const修饰的是*p,并非引用，是错误的 int * const &amp;p;是正确的 int* const &amp;p&#x3D;(int*)0x0011ff22;&#x2F;&#x2F;可以看作是 int* const temp&#x3D;(int*)0x0011ff22;&#x2F;&#x2F;临时量存储立即数 int* const &amp;p&#x3D;temp; &#125; 引用不参与类型，不能说是引用类型 12345678910#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123; int a&#x3D;10; int &amp;b&#x3D;a; cout&lt;&lt;typeid(b).name()&lt;&lt;endl; return 0;&#125; 可见引用不参与类型，但是指针是参与类型的。 三、const和二级指针的结合二级指针的模型二级指针有三种表达方式，即q、*q和 **q,所以const和二级指针最基本的结合方式有三种。 123int const **q;&#x2F;&#x2F;修饰的是**q,没有修饰*q和qint* const *q;&#x2F;&#x2F;修饰的是*q,没有修饰**q和qint** const q;&#x2F;&#x2F;修饰的是q,没有修饰**q和*q 二级指针和const结合的典型问题1. 123456789101112131415161718192021int main()&#123; int a&#x3D;10; int* p&#x3D;&amp;a; const int** q&#x3D;&amp;p; &#x2F;&#x2F;错误 **q和*p是等价的，*q和p是等价的 &#x2F;&#x2F;由于const修饰了**q,所以不需考虑通过*p修改常量的值 &#x2F;&#x2F;*q是const int*类型 &#x2F;&#x2F;const int a&#x3D;10; &amp;a -&gt; const int* &#x2F;&#x2F;*q&#x3D;&amp;a 由于*q和p等价 p&#x3D;&amp;a &#x2F;&#x2F;所以存在通过对*q解引用修改常量内存块的风险 &#x2F;&#x2F;通过对p解引用修改常量内存块的风险 以下两种修改方式均是正确的 int a&#x3D;10; const int *p&#x3D;&amp;a; const int **q&#x3D;&amp;p 或 int a&#x3D;10; int *p&#x3D;&amp;a; const int* const *q&#x3D;&amp;p; &#125; 2. 123456int main()&#123; int a&#x3D;10; int *p&#x3D;&amp;a; const int *&amp;q&#x3D;p;&#x2F;&#x2F; q和p等价，错误同上 const int **q&#x3D;&amp;p;&#125; 3. 123456789int main()&#123; int a&#x3D;10; int *p&#x3D;&amp;a; int* const *q&#x3D;&amp;p;&#x2F;&#x2F;正确 int a&#x3D;10; int *p&#x3D;&amp;a; int** const q&#x3D;&amp;p;&#x2F;&#x2F;正确&#125; 4. 123456int main()&#123; int a&#x3D;10; const int* p&#x3D;&amp;a;&#x2F;&#x2F;const修饰的是*p即内存a被封锁 int** q&#x3D;&amp;p;&#x2F;&#x2F;错误，通过**q可以将常量内存块修改 改正为：int const **q&#x3D;&amp;p;&#125; 5. 123456int main()&#123; int a&#x3D;10; int* const p&#x3D;&amp;a;&#x2F;&#x2F;const修饰的是p int** q&#x3D;&amp;p;&#x2F;&#x2F;错误，通过*q可以修改常量内存块的值 改正为：int* const *q&#x3D;&amp;p;&#125; 综上：当一级指针、二级指针和const结合时。 1.`const int*` 转化为`int* ` 错误 2.`int*` 转化为`const int*`正确 3.`const int** `转化为`int**`错误 4.`int** `转化为`const int**`错误 5.当const为`**`之间时，`*const*退化为一级指针考虑。`","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"volatile关键字的使用","slug":"volatile关键字的使用","date":"2018-08-03T16:10:31.000Z","updated":"2020-11-29T19:35:26.911Z","comments":true,"path":"2018/08/04/volatile关键字的使用/","link":"","permalink":"http://example.com/2018/08/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"MSDN手册中对volatile关键字的解释：大概的翻译：volatile关键字是一个类型限定符，用于声明一个对象可以通过其他语句(例如操作系统、硬件或并发执行的线程)在程序中进行修改。volatile关键字的两个功能：（1）防止编译器对汇编指令做顺序上的优化。（2）防止寄存器存储变量的副本值。 应用在多线程中 1234567891011121314151617181920212223int gdata&#x3D;10;&#x2F;&#x2F;全局变量int fun()&#123; gdata&#x3D;20;&#125;thread1线程1&#123; fun();&#125;thread2线程2&#123; int a&#x3D;gdata; &#x2F;&#x2F;mov eax,dword ptr[gdata] &#x2F;&#x2F;mov dword ptr[c],eax int c&#x3D;gdata;&#x2F;&#x2F;mov dword ptr[c],eax &#x2F;&#x2F;为了优化指令，编译器认为两次赋值中间没有对gdata进行赋值 &#x2F;&#x2F;第二次对c赋值使用gdata存储在寄存器eax的副本值 &#x2F;*实际上会存在这样的情况，由于时间片轮转技术。当分配给线程2时间 片用完时，恰巧将mov dword ptr[c],eax执行完毕。此时，时间片分 线程1，当线程1执行完毕后，gdata&#x3D;20。时间片再次分配给线程1，现场 恢复后，int c&#x3D;gdata用的暂存在eax寄存器中的gadta&#x3D;10,而此时 gdata&#x3D;20,显然时错误的*&#x2F; &#x2F;&#x2F;因此，为了防止类似这样的错误，可以加volatile关键字，防止寄存器 &#x2F;&#x2F;存储变量的副本值&#125; 指令的调优1.编译器对指令的调优 使用 volatile关键字 12345void fun(int *a)&#123;*a&#x3D;10;int b&#x3D;*a;&#125;&#x2F;&#x2F;上述的代码，进过汇编编译器可能优化汇编指令为：void fun(int *a)&#123;int b&#x3D;*a;*a&#x3D;10;&#125;&#x2F;&#x2F;如果不需要或防止编译器对汇编指令作顺序的优化，添加volatile关键字限定void fun(volatile int* a)&#123;*a&#x3D;10;int b&#x3D;*a&#125; 2.程序执行时cpu对指令的调优 barrier()当程序开始执行时，由于CPU的流水线技术，可能会对指令进行顺序上的调优。以达到指令级并行，提高指令执行的速度。但是如果程序员不希望发生顺序的调优，则可在可能发生调优的上下程序段之间添加barrier();以防止CPU对指令的调优。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C和C++中的const修饰符的全面对比","slug":"C和C++中的const修饰符的全面对比","date":"2018-08-01T16:59:47.000Z","updated":"2020-11-29T19:35:27.183Z","comments":true,"path":"2018/08/02/C和C++中的const修饰符的全面对比/","link":"","permalink":"http://example.com/2018/08/02/C%E5%92%8CC++%E4%B8%AD%E7%9A%84const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%A8%E9%9D%A2%E5%AF%B9%E6%AF%94/","excerpt":"","text":"C和C++中的const 12345678910111213141516171819202122232425main.c&#x2F;*C中的constconst修饰的变量可以不初始化const修饰的量叫常变量，不是常量绝对的常量就是一个立即数，可以作为数组的下标const修饰的常变量和普通变量的唯一区别是：常变量定义以后不能作为左值存在常变量和普通变量的编译方式一模一样同一工程下，可以引用其他文件中定义的被const修饰的全局变量a.c const int gdata &#x3D; 10;&#x2F;&#x2F;生成的符号是global属性的b.c extern const int gdata;*&#x2F;int main()&#123; const int a;&#x2F;&#x2F;可以不初始化，如果不初始化，以后没有办法给其一个合适的值 const int b &#x3D; 10; &#x2F;&#x2F;b &#x3D; 20;&#x2F;&#x2F;错误，不能进行赋值，常变量不能作为左值存在 &#x2F;&#x2F;int array[a] &#x3D; &#123;0&#125;;&#x2F;&#x2F;不能做为数组的下标 int *p &#x3D; (int*)&amp;b; *p &#x3D; 30; printf(&quot;*p &#x3D; %d \\n&quot;,*p); printf(&quot;b &#x3D; %d \\n&quot;,b); return 0;&#125; 1234567891011121314151617main.cpp&#x2F;*c++中的const的必须初始化const修饰的量是真正的常量，可以作为数组的下标（c++中const的编译规则 所有使用常量名字的地方全部替换为常量的初始值）*&#x2F;int main()&#123; const int a &#x3D; 10; int arr[a] &#x3D; &#123;0&#125;; int *p &#x3D; (int*)&amp;a;&#x2F;&#x2F;这里引用的是a的地址，不是a的值 cout&lt;&lt;&quot;p &#x3D; &quot;&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;&quot;&amp;a &#x3D; &quot;&lt;&lt;&amp;a&lt;&lt;endl; *p &#x3D; 30; cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;*p &#x3D; &quot;&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 什么时候const修饰的常量会退化为常变量？当const所修饰的量引用一个编译阶段不明确的值的时候，const会退化为常变量。 1234567test.cppint main()&#123; int a &#x3D; 20;&#x2F;&#x2F;是指令，执行的时候才能确定下来 const int b &#x3D; a; int arr[b] &#x3D; &#123;0&#125;; return 0;&#125; 从汇编的角度看const 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int a &#x3D; 10;&#x2F;&#x2F;mov dword ptr[ebp-4],0Ah const int b &#x3D; a;&#x2F;&#x2F;退化成常变量 &#x2F;&#x2F;eax,dword ptr[ebp-4] &#x2F;&#x2F;mov dword ptr[ebp-8],eax cout&lt;&lt;b&lt;&lt;endl; const int c &#x3D; 10;&#x2F;&#x2F;真正的常量 &#x2F;&#x2F;mov dword ptr[ebp-0Ch],0Ah cout&lt;&lt;c&lt;&lt;endl;&#125; c++中const生成的符号在c++中，定义的被const修饰的全局变量所生成的符号是local。若在其他*.cpp文件引用该全局变量，则会出现链接错误。因为链接器只处理属性为global的符号，不处理属性为local的符号。 12a.cppconst int gdata &#x3D; 20; 为了使得在 *.cpp文件定义的被const所修饰的全局变量可以在其他 *.cpp文件所能引用，则需在定义就加extern关键字，使其生成属性为global的符号。 12a.cppextern const int gdata &#x3D; 20; 由图可以看到，此时被const修饰的全局变量gdata所生成的符号其属性为global。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"c++ 默认类型的转换","slug":"c++ 默认类型的转换","date":"2018-08-01T14:12:58.000Z","updated":"2020-11-29T19:35:27.187Z","comments":true,"path":"2018/08/01/c++ 默认类型的转换/","link":"","permalink":"http://example.com/2018/08/01/c++%20%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"对于C/C++语言来说，在通常情况下语句和表达式的操作通常只使用一种类型的变量和常量。但在实际的开发中，往往会有不同类型的变量之间进行运算，为了满足这样的代码需求，通常在编译器中会设置不同类型自动类型转换，以完成相应的运算。但是如果我们对这样的自动类型转换不熟悉，往往会写出错误的代码，令人摸不清头脑，这种错误往往也是严重的。 123456789&#x2F;&#x2F;测试代码一：#include&lt;stdio.h&gt;int main()&#123; unsigned int a &#x3D; 1; char b &#x3D; -1; return a&gt;b?&#39;a&#39;:&#39;b&#39;; return 0;&#125; 对于上边的代码，表观看上去变量a为1，变量b为-1。所以上述代码的执行结果为a,但实际上执行结果却是b，如下图。为什么会出现这种情况？-1难道比1大吗？ 实际上当不同类型的变量做运算时，编译器为了提高计算的精度，会进行数据的类型自动转换，按照下图的方式进行转换。自动数据类型转换的规则： 1.横向红色的箭头表示的是无条件转换，float类型数据运算时，将其转换为double类型进行运算，运算结果再转换为float；short和char类型数据在做运算时，首先转换为int，再将运算结果转换为short、char类型。2.纵向的蓝色箭头，当不同数据类型之间进行运算时，位于箭头下方的数据类型会转换为箭头上方的数据类型。 借助上述的规则，分析一下上述代码的执行结果为什么是b。 123456789#include&lt;stdio.h&gt;int main()&#123; unsigned int a &#x3D; 1;&#x2F;&#x2F;0x00000001 char b &#x3D; -1;&#x2F;&#x2F;会自动转换为int类型 return a&gt;b?&#39;a&#39;:&#39;b&#39;; &#x2F;&#x2F;a &gt; b,unsigned int和int进行比较时，int会转换为unsigned int &#x2F;&#x2F;unsigned int b &#x3D; -1;&#x2F;&#x2F;十六进制表达为 0xffffffff return 0;&#125; 因此，输出为b。 12345678910111213141516171819&#x2F;&#x2F;测试代码二:#include&lt;iostream&gt;using namespace std;bool compare(int a,int b)&#123; cout&lt;&lt;&quot;compare(int,int)&quot;&lt;&lt;endl; return a&gt;b;&#125;bool compare(float a,float b)&#123; cout&lt;&lt;&quot;compare(float,float)&quot;&lt;&lt;endl; return a&gt;b;&#125;int main()&#123; compare(10,20); compare(10.1,20.2); return 0;&#125; 显然，上述的代码是编译不通过的。函数重载会进行类型推演，但是对于compare(10.1,20.2)参数首先会自动转换为double类型，但是进行重载时，如上图类型转换图中没有一个规定对于double的数据到底转换为int还是float，出现了二义性因此会出现编译错误。以上两个例子比较鲜明，对于这样编译器这样的自动类型转换，程序员需要熟稔于心，才不会写出错误的代码。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"c++ typeid().name()输出变量类型","slug":"c++ typeid().name()输出变量类型","date":"2018-08-01T12:03:13.000Z","updated":"2020-11-29T19:35:27.199Z","comments":true,"path":"2018/08/01/c++ typeid().name()输出变量类型/","link":"","permalink":"http://example.com/2018/08/01/c++%20typeid().name()%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"头文件：#include&lt;typeinfo&gt;在上头文件中定义了typeid()操作符可以输出变量的类型。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123; bool a; char b; short c; int d; long e; float f; double g; long long h; cout&lt;&lt;typeid(i).name()&lt;&lt;endl; cout&lt;&lt;typeid(a).name()&lt;&lt;endl; cout&lt;&lt;typeid(b).name()&lt;&lt;endl; cout&lt;&lt;typeid(c).name()&lt;&lt;endl; cout&lt;&lt;typeid(d).name()&lt;&lt;endl; cout&lt;&lt;typeid(e).name()&lt;&lt;endl; cout&lt;&lt;typeid(f).name()&lt;&lt;endl; cout&lt;&lt;typeid(g).name()&lt;&lt;endl; cout&lt;&lt;typeid(h).name()&lt;&lt;endl; return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C语言中的强符号和弱符号","slug":"C语言中的强符号和弱符号","date":"2018-07-29T01:30:10.000Z","updated":"2020-11-29T19:35:27.455Z","comments":true,"path":"2018/07/29/C语言中的强符号和弱符号/","link":"","permalink":"http://example.com/2018/07/29/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%BA%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%BC%B1%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"一、强弱符号 强弱符号针对的是处于同一工程下在不同源文件下定义的全局变量符号，链接器只处理global的符号而不处理local的符号。链接的核心是符号的重定位，在符号引用的地方找到符号定义的地方，包括函数产生的符号和全局变量产生的符号。 强符号：函数和初始化的全局变量所生成的符号。弱符号：未初始化的全局变量所生成的符号。 很多情况下写出的代码会出现链接的错误，符号重定义，这是因为在不同的源文件中定义了同名的全局变量并且都进行了初始化。 123456789&#x2F;&#x2F;a.cint gdata &#x3D; 10;&#x2F;&#x2F;b.cint gdata &#x3D; 20;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;gdata &#x3D; %d\\n&quot;,gdata); return 0;&#125; 这是很多新手容易犯的错误，若将a.c或b.c中全局变量gdata只初始化一次，则不会出现链接错误，并且会链接成功。那么新的问题是：（1）出现强符号和弱符号，选择哪一个？（2）若出现多个同名的强符号，最终怎么选择？（3）若出现多个同名的弱符号，最终会怎么选择？显然需要这样的一套规则来约束这些可能存在的问题。 二、强弱符号的使用规则 （1）如果出现多个强符号，最终会出现链接错误即符号的重定义。（2）如果出现强符号和弱符号，编译器最终会选择强符号。（3）如果出现多个同名弱符号，编译器最终会选择内存占用量最大的那个符号。 一个有趣的小例子再看强弱符号： 12345678910111213141516&#x2F;&#x2F;a.cint x;void func()&#123; x &#x3D; 20;&#125;&#x2F;&#x2F;b.c#include&lt;stdio.h&gt;short x &#x3D; 10;short y &#x3D; 10;extern void func();int main()&#123; func(); printf(&quot;x &#x3D; %d,y &#x3D; %d\\n&quot;,x,y); return 0;&#125;&#x2F;&#x2F;试问输出的x和y分别是多少，大家可以自己先想一下，看看自己的答案。 执行结果：和大家心中的答案是否一致呢？有很多人会有疑问，为什么y输出的不是10，而是0呢？源文件是独立进行编译的 123456789101112131415&#x2F;&#x2F;a.cint x;&#x2F;&#x2F;弱符号void func()&#123; x &#x3D; 20; &#x2F;&#x2F;往x的内存上写20,写4个字节 编译阶段就完成的&#125;&#x2F;&#x2F;b.c#include&lt;stdio.h&gt;short x &#x3D; 10;&#x2F;&#x2F;强符号 14 00 00 00最终将y覆盖为0short y &#x3D; 10;extern void func();int main()&#123; func();&#x2F;&#x2F;链接的完成选择强符号 printf(&quot;x &#x3D; %d,y &#x3D; %d\\n&quot;,x,y); return 0;&#125; 在 gcc中，可以通过__attribute__((weak))来强制定义任何一个符号为弱符号。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"linux系统调用函数 mmap--创建内存映射区（在虚拟地址空间上)/munmap--释放内存映射区","slug":"linux系统调用函数 mmap--创建内存映射区（在虚拟地址空间上)!munmap--释放内存映射区","date":"2018-07-28T11:11:50.000Z","updated":"2020-11-29T19:35:27.211Z","comments":true,"path":"2018/07/28/linux系统调用函数 mmap--创建内存映射区（在虚拟地址空间上)!munmap--释放内存映射区/","link":"","permalink":"http://example.com/2018/07/28/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%20mmap--%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88%E5%9C%A8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8A)!munmap--%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA/","excerpt":"","text":"1.mmap函数所需头文件：#include&lt;sys/mman.h&gt;函数原型：void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset)参数：第一个参数void* addr是映射区的首地址，传NULL，让内核去指定，返回值用来指定映射区的首地址。 第二个参数是映射区的大小size_t length,由于32bit的linux内核虚拟地址空间是由4KB大小的页面组织的，实际大小是4KB的整数倍。不能指定为0，否则调用失败！一般来讲，文件多大，length就指定多大。 第三个参数是映射区的权限int prot ， PROT_READ （映射区必须要有读权限）、 PROT_WRITE。 第四个参数 int flags 指示标志位参数， MAP_SHARED 数据会同步到磁盘、MAP_PRIVATE 数据不会同步到磁盘。 第五个参数是文件描述符fd，要映射的文件对应的文件描述符fd。使用open系统调用获取文件描述符。第六个参数off_t offset映射文件指针的偏移量，偏移量必须是4KB的整数倍，一般传入0即可，除非有特殊的需求。返回值：成功时，返回内存映射区的首地址。失败，*MAP_FAILED (void)-1**。功能： 将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。（1）使用普通文件提供的内存映射：适用于任何进程之间。此时，需要打开或创建一个文件，然后再调用mmap()典型调用代码如下： 12345int fd &#x3D; open(name, flag, mode); if(fd&lt;0) ...void* ptr &#x3D; mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，可以参看UNIX网络编程第二卷。 （2）适用于具有亲缘关系的进程之间。由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用 fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区 域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。 对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可。2.munmap函数所需头文件：#include&lt;sys/mman.h&gt;函数原型： int munmap(void* addr,size_t length)参数：第一个参数void* addr，mmap的返回值，是映射区的首地址。第二个参数，映射区的长度。返回值： 示例代码 1234567891011121314151617181920212223&#x2F;&#x2F;mmap.c#include&lt;sys&#x2F;mman.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; &#x2F;&#x2F;打开一个文件 int fd &#x3D; open(&quot;a.txt&quot;,O_RDWR); int len &#x3D; lseek(fd,0,SEEK_END); &#x2F;&#x2F;创建内存映射区 void* p &#x3D; mmap(NULL,len,PORT_READ | PORT_WRITE,MAP_SHARED,fd,0); if(p &#x3D;&#x3D; MAP_FAILED)&#123; perrot(&quot;mmap error&quot;); exit(1); &#125; printf(&quot;%s\\n&quot;,(char*)p); &#x2F;&#x2F;释放内存映射区 munmap(p,len); close(fd); return 0;&#125; a.txtgcc -o mmap mmap.c","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"深入理解编译、链接和运行（obj文件组成格式分析，可执行文件组成格式分析）","slug":"深入理解编译、链接和运行（obj文件组成格式分析，可执行文件组成格式分析）","date":"2018-07-28T09:29:41.000Z","updated":"2020-11-29T19:35:27.243Z","comments":true,"path":"2018/07/28/深入理解编译、链接和运行（obj文件组成格式分析，可执行文件组成格式分析）/","link":"","permalink":"http://example.com/2018/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C%EF%BC%88obj%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%89/","excerpt":"","text":"一、简单的CS历史现代大多数计算机都是基于冯.诺伊曼提出的存储程序原理采用冯.诺伊曼架构，即由运算器、控制器、存储器和输入输出设备组成。 为了屏蔽I/O设备的底层差异，产生虚拟文件系统virtual file system（VFS)。为了屏蔽内存和I/O的差异产生了虚拟存储器(虚拟内存)，而为了屏蔽CPU、I/O和内存的差异进而产生进程的概念。 虚拟的概念是由大名鼎鼎的计算机公司IBM提出的，为了方便理解虚拟，IBM写出下面的几句话： 1、看得见 存在 物理2、看得见 不存在 虚拟3、看不见 存在 透明 二、程序是怎么执行的我们或多或少都有疑问，这些看似平常的由字符组成的文章是通过怎样的过程可最终以在计算机上执行，高级语言如pascal、c、c++、java等，尽管语言不相同，持有各自的特性，但其最终生成的无非就是指令和数据，毫不夸张的讲程序其实就是指令和数据。所以计算机是在做运算，处理指令和数据。那么我们用高级语言编写的程序最终是怎么成为计算机可以识别的机器语言的。在linux系统上，当我们输入./a.out并进行回车时发生了什么。作为一名程序员，这是我们需要知道的。 下边的代码，用于分析编译、链接过程。 1234567891011121314151617#include&lt;stdio.h&gt;int gdata1 &#x3D; 10;int gdata2 &#x3D; 0;int gdata3;static int gdata4 &#x3D; 20;static int gdata5 &#x3D; 0;static int gdata6;int main()&#123; int a &#x3D; 30; int b &#x3D; 0; int c; static int d &#x3D; 40; static int e &#x3D; 0; static int f; return 0;&#125; 上边共定义的12个变量，其中哪些是指令，哪些是数据。都分布在内存的哪些区域是我们所需清楚的。为探究上述问题，首先我们需要清楚的了解虚拟地址空间的内存布局。操作系统为每一个进程分配虚拟地址空间，而虚拟地址空间的大小，取决于CPU的位数，更具体的说是ALU（算术逻辑运算单元的宽度）即一次可以处理最长整数的宽度，同时也可以理解为数据总线的条数。在32bit的linux内核，也可以理解为地址总线的条数，因为地址总线的条数和数据总线的条数相同。总而言之，在32bit操作系统下，虚拟地址空间的大小为2^32即4G的大小的虚拟地址空间。 三、虚拟地址空间由上边分析可知，在32bit的CPU架构下地址总线的条数为32条，所以其寻址能力为2^32个，按字节编址，所以虚拟地址空间的大小为4GB。下面以图示的方式说明这4GB的虚拟地址空间布局是什么样的。 用户空间的分析：（1）保留区：很多情况下，正是由于我们对虚拟地址空间布局不熟悉所以编写出错误的程序。如果熟悉虚拟地址空间的内存布局，大可避免这些不必要的错误。如下边的小程序正是许多许多新手程序员经常犯的错误： 12345678#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* p &#x3D; NULL; int len &#x3D; strlen(p); printf(&quot;len &#x3D; %d\\n&quot;,len); return 0;&#125; 显然程序中并没有给指针变量p分配合理的内存，就对p进行了访问，此时p所指向的内存区域正是虚拟地址空间中128MB的保留区，所以会出现段错误。（2）.data、.bss和.text图中绿色区域位于虚拟地址空间中的数据段(.bss和.data)，而红色区域位于虚拟地址控制中的.text即代码段。其中，经过加载.data段存放初始化不为0的全局变量而.bss段存放初始化为0的全局变量和未初始化的局部变量。注意，这里的局部变量和全局变量是指符号解析为local和global符号。bss(better save space)这里.bss节省的是文件的空间还是虚拟地址空间放在后边进行解释。实际上.bss段（better save space）节省的obj文件格式的大小。 （3）共享库 如果程序中用到了库函数，如printf、scanf、puts、gets等。则在共享库中包含了这些函数的定义。 （4）栈 函数运行用到的栈 内核空间的分析： （1）ZONE_DMA：直接内存访问，正常情况下，磁盘中的数据到达主存需要进过存储器的层次结构，需要经过CPU。若这些数据不需要CPU处理，则浪费了大量的CPU时间。如果在主存和辅存之间之间开辟一条数据通路，则可提高CPU的使用率，同时可以加快主存和辅存之间交换数据的速度，进而提高整机的性能。DMA直接内存访问正是提供了这样的一种机制。（2）ZONE_NORMAL（3）ZONE_HEIGHMEM：主要用于在32bit的linux系统中在内核映射高于1GB的物理内存时会用到高端内存。 四、深入编译和链接过程。下面详细分析由源文件是如何经过编译和链接过程最终生成可执行文件。测试环境：ubuntu18.04 + gcc测试工具：逆向和反汇编工具 objdump和readelf测试代码： 1234567891011121314151617int gdata1 &#x3D; 10; &#x2F;&#x2F;.dataint gdata2 &#x3D; 0; &#x2F;&#x2F;.bssint gdata3; &#x2F;&#x2F;.bssstatic int gdata4 &#x3D; 20; &#x2F;&#x2F;.datastatic int gdata5 &#x3D; 0; &#x2F;&#x2F;.bssstatic int gdata6; &#x2F;&#x2F;.bssint main()&#123; &#x2F;&#x2F;.text int a &#x3D; 30; &#x2F;&#x2F;.text int b &#x3D; 0; &#x2F;&#x2F;.text int c; &#x2F;&#x2F;.text static int d &#x3D; 40; &#x2F;&#x2F;.data static int e &#x3D; 0; &#x2F;&#x2F;.bss static int f; &#x2F;&#x2F;.bss return 0; &#x2F;&#x2F;.text&#125;&#x2F;&#x2F;.bss共占24个字节 .data共占12个字节 编译生成可重定位的二进制文件：编译整个编译过程分为预编译、编译和汇编，最终生成可执行文件，其中在windows下生成 .obj文件，在linux下生成 .o文件，学名叫做二进制可重定位文件（1）预编译：gcc -E *.c -o *.i预编译要干的事情：如删除注释、替换宏、递归展开头文件、处理以#开头的预编译指令等，在预编译阶段不做任何 有效信息的类型检查。 （2）编译：gcc -S *.i -o *.s词法分析、语法分析和语义分析、代码的优化、编译、汇总所有的所有的符号 （3）汇编：gcc -c *.s -o *.o将汇编指令转换为特定平台下的机器语言、构建*.o文件组成格式。 链接（1）合并所有obj文件的段，并调整段偏移和段长度，合并符号表，进行符号解析，分配内存地址（虚拟地址）。（2）链接的核心：符号的重定位。 针对编译和链接过程，提出以下需要解决的问题： （1）编译的过程是怎么样的? （2）obj文件的组成格式是什么，它为什么不能执行? 1.readelf -h main.o输出obj文件头部，可以查看到obj文件一些重要信息。2.file main.o在上边两个图中，可以得出这样的一个结论。.obj是一个二进制可重定位文件，不能执行，并不是一个executable的文件。 下面分析.obj文件的组成格式3.objdump -s main.o 4.readelf -S main.o产看当前二进制可重定位文件中所有的段。 .obj文件组成格式的分析，着重看 现在新的问题出现了：（2.1）既然.obj文件中都没有存储.bss段的信息，那么在程序中那些初始化为0的全局变量和未初始化的局部变量它是怎么识别它们的？答：由于.bss段中都是0，所以不需要记录。只需要记录其大小即可，所以通过段表即可找到。（2.2）分析测试代码，得出由六个变量位于.bss段，但实际上在.bss中大小只有20个字节即只记录了5个变量，那么还有一个变量为什么不记录，它在哪里？ 答：这里涉及到强弱符号，我会单独写出来。浅显的可以这样理解，由于全局变量gdata3是一个弱符号，而未经链接。并不知道是否有强符号的存在，所以在.bss段中并为记录。而gdata6虽然未经初始化，但由于其经static关键字修饰，本文件可见，所以不存在强弱符号之分。（3）链接的第二步具体做了哪些事情，什么是符号重定位？ 链接器只对所有.obj文件的global符号进行处理，对local的符号不做任何处理。如static生成的符号就是local的符号。objdump -t main.o查看生成的符号表可以看到弱符号在 *COM*中存放。为方便探究链接的过程及其核心符号的重定位，用下边两个文件的代码进行验证： 1234567891011121314151617181920212223&#x2F;&#x2F;main.cextern int gdata10;&#x2F;&#x2F;不可对外部变量进行初始化extern int sum(int,int);int gdata1 &#x3D; 10;int gdata2 &#x3D; 0;int gdata3;static int gdata4 &#x3D; 20;static int gdata5 &#x3D; 0;static int gdata6;int main()&#123; int a &#x3D; 30; int b &#x3D; 0; int c; static int d &#x3D; 40; static int e &#x3D; 0; static int f; return 0;&#125;&#x2F;&#x2F;sum.cint gdata10 &#x3D; 20;int sum(int a,int b)&#123; return a+b;&#125; 分别查看main.o和sum.o所生成的符号表：符号解析：所有obj文件符号表中对符号引用的地方都要找到符号定义的地方，否则就会出现链接错误。由于源文件是单独编译的，所以对外部的符号处理为*UND*即undefine。objdump -d main.o可以看到编译过程并不给数据和函数入口分配内存地址，都是以0地址作为替代。下面详细看链接过程：简单的合并策略，将每个obj文件的段拿来即可，像下边这样：实际上这样做并不好，通过上边的分析，在.obj文件中，每个段对齐方式是4字节对齐，但是可执行文件是按照页面对齐的，在32bit的CPU架构下，常用的页面大小是4KB，假设现在每个段现在都是一字节大小，如果按照这种简单的合并策略，将会有大量的空间会被浪费。合理的分配策略：将所有属性相同的段合并，组织在一个页面上。合并所有.obj文件的段，调整段大小和段偏移，重点：合并符号表，进行符号解析，即符号的重定位，即在符号引用的地方找到符号定义的地方。现在手动链接:ld -e main *.o -o runobjdump -h run链接完成后，弱符号gdata3并为找到强符号，所用就用它自己，此时.bss大小为24个字节，即六个变量。查看符号表objdump -t run 此时所有符号都有合理的虚拟地址空间的地址，即符号进行了重定位。将代码段中数据的地址替换为数据的地址，将函数入口的地址的偏移量替换到调用函数的call指令中。这整个过程称为符号的重定位。 （4）可执行文件的组成格式是什么？它为什么可以执行？它从哪开始执行? CPU怎么知道它从哪开始执行？分析可执行文件run的组成格式readelf -h run获取可执行文件的头部信息可以看到入口地址已经不是0地址了，正是main函数的地址。程序的运行，进程：（1）./a.out 创建虚拟地址空间到物理内存的映射（创建内核地址映射结构体），创建页目录和页表。（2）加载代码段和数据段。（3）将可执行文件人入口地址写入CPU的PC寄存器中 可执行文件的组成格式可见可执行文件组成较.obj文件组成多了program headers，前面提到了可执行文件是按照页面进行组织的，可是现在看来它的对齐方式还是按照四字节，需要搞清楚这个问题就需要搞清楚program headers中到底有什么?readelf -l run输出program headers头部信息会看到两个LOAD项，其对齐方式为0x200000即2MB对齐，由于我的机器是64bit操作系统，实际上在32bit系统下对齐为4KB，按照页面对齐的。这里的两个LOAD页非常重要，第一个LOAD页.text，可读可执行，第二个LOAD页可读可写包含了.bss和.data。这两个LOAD页面指示了操作系统LOADER加载器要把当前程序的哪些内容加载到物理内存上。为什么之前讲可执行文件的组织方式是页面，就是为了之后方便映射。包括虚拟地址空间和物理内存都是以页面进行组织的。而从磁盘到虚拟地址空间的映射是由mmap函数的映射，而虚拟地址空间到物理内存映射是多级页表的方式进行映射的，属于操作系统的内容。关于多级页表映射方式我会独立写出一篇相关的博客。strace ./run跟踪一下可执行文件run成为进程后所涉及到系统调用等信息。这里可以看到许多mmap系统调用函数。为了方便观察进程执行后虚拟地址空间的布局，不能让程序直接跑完，需要添加一些输入，设置阻塞。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;extern int gdata10;&#x2F;&#x2F;不可对外部变量进行初始化extern int sum(int,int);int gdata1 &#x3D; 10;int gdata2 &#x3D; 0;int gdata3;static int gdata4 &#x3D; 20;static int gdata5 &#x3D; 0;static int gdata6;int main()&#123; int a &#x3D; 30; int b &#x3D; 0; int c; static int d &#x3D; 40; static int e &#x3D; 0; static int f; getchar(); getchar(); return 0;&#125;&#x2F;&#x2F;sum.cint gdata10 &#x3D; 20;int sum(int a,int b)&#123; return a+b;&#125; gcc -o run *.c./run &amp;放到后台执行cat /proc/2508/maps查看run进程虚拟地址空间相信自习看完本篇的内容，大家一定会对编译和链接过程有新的理解，这对我们写出高效的代码是非常有帮助的。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结","slug":"linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结","date":"2018-07-09T11:18:09.000Z","updated":"2020-11-29T19:35:27.203Z","comments":true,"path":"2018/07/09/linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结/","link":"","permalink":"http://example.com/2018/07/09/linux%E4%B8%8Btar.gz%E3%80%81tar%E3%80%81bz2%E3%80%81zip%E7%AD%89%E8%A7%A3%E5%8E%8B%E7%BC%A9%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/","excerpt":"","text":"linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结 Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法： tar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下： # tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包-f指定包的文件名。 # tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 # tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 # tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思 以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。 1) tar调用gzip gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下： # tar -czf all.tar.gz *.jpg 这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz # tar -xzf all.tar.gz 这条命令是将上面产生的包解开。 2) tar调用bzip2 bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下： # tar -cjf all.tar.bz2 *.jpg 这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2 # tar -xjf all.tar.bz2 这条命令是将上面产生的包解开。 3)tar调用compress compress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下： # tar -cZf all.tar.Z *.jpg 这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z # tar -xZf all.tar.Z 这条命令是将上面产生的包解开 有了上面的知识，你应该可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结： 1)对于.tar结尾的文件 tar -xf all.tar 2)对于.gz结尾的文件 gzip -d all.gz gunzip all.gz 3)对于.tgz或.tar.gz结尾的文件 tar -xzf all.tar.gz tar -xzf all.tgz 4)对于.bz2结尾的文件 bzip2 -d all.bz2 bunzip2 all.bz2 5)对于tar.bz2结尾的文件 tar -xjf all.tar.bz2 6)对于.Z结尾的文件 uncompress all.Z 7)对于.tar.Z结尾的文件 tar -xZf all.tar.z 另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们： 1)对于.zip linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： # zip all.zip *.jpg 这条命令是将所有.jpg的文件压缩成一个zip包 unzip all.zip 这条命令是将all.zip中的所有文件解压出来 2)对于.rar 要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从http://www.rarsoft.com/download.htm下载RARfor Linux 3.2.0，然后安装： # tar -xzpvf rarlinux-3.2.0.tar.gz # cd rar # make 这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： # rar a all *.jpg 这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar扩展名将自动附加到包名后。 # unrar e all.rar 这条命令是将all.rar中的所有文件解压出来 到此为至，我们已经介绍过linux下的tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar等程式，你应该已经能够使用它们对.tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar这10种压缩文件进行解压了，以后应该不需要为下载了一个软件而不知道如何在Linux下解开而烦恼了。而且以上方法对于Unix也基本有效。 本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10种压缩文件进行操作。 以下补充tar -c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -xf all.tar这条命令是解出all.tar包中所有文件，-x是解开的意思压缩tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 总结1、*.tar 用 tar –xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、*.tar.gz和*.tgz 用 tar –xzf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar –xjf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar –xZf 解压8、*.rar 用 unrar e解压9、*.zip 用 unzip 解压","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"进程状态的概念及状态转换图","slug":"进程状态的概念及状态转换图","date":"2018-07-03T00:39:45.000Z","updated":"2020-11-29T19:35:27.159Z","comments":true,"path":"2018/07/03/进程状态的概念及状态转换图/","link":"","permalink":"http://example.com/2018/07/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/","excerpt":"","text":"一、进程状态 1.创建状态进程由创建而产生。创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中。 2.就绪状态这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行。如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列。有执行资格，没有执行权的进程。 3.运行状态这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态。既有执行资格，又有执行权的进程。 4.阻塞状态这里是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞。此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态 5.终止状态进程的终止也要通过两个步骤：首先，是等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还给系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能在再执行，但是操作系统中任然保留了一个记录，其中保存状态码和一些计时统计数据，供其他进程进行收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除其进程，即将其PCB清零，并将该空白的PCB返回给系统。 二、进程状态转换关系图","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"库函数和系统调用的区别和联系","slug":"库函数和系统调用的区别和联系","date":"2018-07-01T00:48:08.000Z","updated":"2020-11-29T19:35:27.163Z","comments":true,"path":"2018/07/01/库函数和系统调用的区别和联系/","link":"","permalink":"http://example.com/2018/07/01/%E5%BA%93%E5%87%BD%E6%95%B0%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/","excerpt":"","text":"一、库函数和系统调用概念 库函数：库函数是语言或应用程序的一部分，可以运行在用户空间中。系统调用：又称广义指令，它是由操作系统向程序提供的程序接口，而非直接向用户提供，用户只能通过程序间接的使用这些接口。 1.在概念对比中，可以直观的感触到系统调用是依赖于操作系统的，由于其依赖于平台，所以系统调用的平台移植性较差。2.而函数库，是将一些已经编写好函数进过封装，存放到函数库（静态库或动态库）中，是具有特定功能函数的集合。 通过库文件向程序员提供相关的函数，以便于调用。程序员不需要关心平台的差异性，如linux或windows,由库对不同平台差异屏蔽。 二、库函数和系统调用在不同方面的对比。 对比 库函数 系统调用 移植性 平台移植性好 依赖于内核，不保证移植性 执行区域 用户空间 内核空间 开销 属于过程调用，开销小 需要中断，在用户空间和内核空间进行切换开销大 数量 库函数数量较多 系统调用较少 运行时间 属于用户时间 属于系统时间 关于系统调用的几点说明： 1、系统调用的目的：为了是系统更加稳定安全，防止小白用户、恶意用户进行非法的越权操作。 2、从用户态切换到内核态必须要通过”中断”，只要发生中断，就需要对中断进行处理，也不然会切换到内核点。 三、总结 库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核提供给用户的程序接口，运行在内核空间中，而且许多的库函数都会使用系统调用实现功能，如在linux下C中的fopen、fclose、fwrite等文件操作函数其底层就是通过open、close、write等系统调用是实现的。没有使用系统调用的库函数，执行效率通常比系统调用高。因为使用系统调用时，需要通过中断进行上下文的切换以及由用户态向内核态的转移。","categories":[],"tags":[]},{"title":"c和c++的区别 （一）函数默认值、内联函数、函数的重载和c/c++之间的相互调用","slug":"c和c++的区别 （一）函数默认值、内联函数、函数的重载和c!c++之间的相互调用","date":"2018-06-24T03:30:54.000Z","updated":"2020-11-29T19:35:27.199Z","comments":true,"path":"2018/06/24/c和c++的区别 （一）函数默认值、内联函数、函数的重载和c!c++之间的相互调用/","link":"","permalink":"http://example.com/2018/06/24/c%E5%92%8Cc++%E7%9A%84%E5%8C%BA%E5%88%AB%20%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8Cc!c++%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/","excerpt":"","text":"一.函数默认值c++支持给函数的形式参数进行默认初始化，其规则为从右向左依此初始化。 还有以下需要注意的几点：1.定义处可以不给出形参的默认值，在声明处可以给出形参的默认值。2.声明处形参默认值给出要符合以上规则。3.不能重复给形参默认值进行初始化，即一个形式参数只能初始化一次。 12345678#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F;以下的两组声明是正确的int sum(int a,int b&#x3D;10);int sum(int a&#x3D;10,int b);&#x2F;&#x2F;由于上一个声明已经将b初始化为10，所以符合从右向左依此初始化的规则int sum(int a&#x3D;10,int b);&#x2F;&#x2F;错误，不符合规则 函数默认值存在的意义是什么？对比无默认值和带默认值在汇编上的区别不带默认值测试代码： 1234567891011121314#include&lt;iostream&gt;using namespace std;int sum(int a,int b)&#123; return a+b;&#125;int main()&#123; int a &#x3D; 10; int b &#x3D; 30; sum(a,b); return 0;&#125; 我们都知道如果调用不带默认值的sum函数的第一步是压实参mov eax,dword ptr[ebp-8]push eaxmov ecx,dword ptr[ebp-4]push ecxcall sumadd esp,8 回退形参内存带默认值测试代码： 12345678910111213#include&lt;stdio.h&gt;int sum(int a,int b&#x3D;20)&#123; return a+b;&#125;int main()&#123; int a &#x3D; 10; sum(a); return 0;&#125; push 14h mov ecx,dword ptr[ebp-4] push ecx call sum add esp,4 结论：对比两者在汇编上的区别，对有函数默认值的函数在汇编语言表现为减少一个mov的指令周期看似比较短，但如果在一个大型项目中上万次调用这样的带有默认值的函数，其优势就体现出来了，大量减少了代码的执行时间，使得代码的效率提高。这就是函数默认值存在的意义！ 二.内联函数 1.内联函数是在调用点，将函数的代码全部展开，并且这个过程是在编译阶段进行的。 2.内联函数只在编译器的release版本下起作用，而debug版本无效，还是会有函数栈帧的开辟和回退。其目的是方便程序员调试。3.内联函数实际上只是程序员对编译器的一种建议，其建立的基础是当调用函数函数的开销 &gt; 执行函数的开销时，处理成内联函数是更加高效。但实际上如递归函数是不可能被处理成内联函数的。因为递归函数调用的次数只有在执行完毕才能确定，而内联函数的处理实在编译阶段根据上述规则进行处理的。而递归函数没有给编译器提供这样的规则。 内联函数和宏函数的区别？ 内联函数和static函数的区别？ 从三个角度分析 函数类型 作用域 符号的产生 栈帧的开辟和回退 内联函数 当前文件可见 不产生符号 没有标准的栈帧开辟和回退 static函数 当前文件可见 产生local的符号，链接器不做处理 有 宏函数 当前文件可见 不产生符号 无 普通函数 示具体作用域 产生global的符号，链接器进行处理 有 1234567891011121314151617#include&lt;iostream&gt;using namespace std;static void print()&#123; cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125; int sum(int a,int b)&#123; return a+b;&#125;int main()&#123; return 0;&#125; 使用`objdump -t test.o`查看上述代码产生的符号： ![这里写图片描述](https://img-blog.csdn.net/20180624102006234?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSkJGSlNC/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 可以看到static函数和普通函数生成的符号分别为local属性和global属性的。 三.函数的重载 在C语言中，符号的生成仅仅由函数名称决定。我们都知道，如果在同一个项目如果两个函数的函数名称相同，那么编译器在链接会报错。如在a.c和b.c中实现如下的两个同名的函数：但是在c++中却支持这样的机制。为什么不会报出链接错误呢？在一个项目，有许多源文件。每个源文件独立的进行编译，生成符号。链接的核心就是符号的重定位，即在符号 引用的地方找到符号定义的地方，这时候发现符号相同，因此产生了链接错误。而在c++当同名称函数产生的符号也是不相同的。c++函数符号的生成：函数名+参数列表(参数个数+参数类型+参数顺序)下面验证一下在c++中重载函数产生的符号:使用objdump -t test.o查看生成的符号表可以看到在c++中符号的组成是由函数名称和参数列表共同决定的。 函数参数被cosnt修饰能否构成重载？ 123void fun(int a)&#123;;&#125;void fun(const int)&#123;;&#125;int main()&#123;return 0;&#125; 不能构成重载 12345678910void fun(int *a)&#123;;&#125;void fun1(const int* a)&#123;cout&lt;&lt;&quot;fun(const int* a)&quot;&lt;&lt;endl;&#125;void fun1(int* const a)&#123;cout&lt;&lt;&quot;fun(int* const a)&quot;&lt;&lt;endl;&#125;int main()&#123; int a&#x3D;10; const int *p &#x3D; &amp;a; int* const q&#x3D;&amp;a; fun(p); fun(q);return 0;&#125; 因此，可以得出构成重载的条件：1.函数名称相同。2.参数列表不同。3.不能以返回值不同作为判断重载的条件，因为返回值类型符符号的生成无关。4.对实参的值是否有影响，如被const/volatile修饰的*（指针）/&amp;（引用）可以作为函数重载的前提条件。 最重要的一点，构成重载的函数必须在同一作用域！ 四.c和c++之间相互调用在实际的应用当中，有时候会发生这样的事情,c程序可能需要调用一些优秀的c++程序的接口，而在c++程序中也可能需要调用优秀的c程序接口，这样就需要提供这样相互调用机制。 1234extern &quot;C&quot; &#x2F;&#x2F;告诉编译器里边的符号是按照c规则生成&#123; ;&#125; 前面已经谈到，由于c和c++生成符号的规则不相同。如果一致，才能调用。举两个例子，谈谈其用法。 （1）c++程序调用c程序两个源文件分别为main.cpp和sum.c，其中sum.c中包括sum函数的实现，而在main.cpp调用它 123456789101112#include&lt;iostream&gt;using namespace std;int sum(int a,int b);&#x2F;&#x2F;在main.cpp生成的符号为 sum_int_int 而在sum.c中生成sum这样必然导致链接错误，找不到sum_int_intextern &quot;C&quot;&#123; int sum(int a,int b);&#x2F;&#x2F;在main.cpp生成的符号为sum和在sum.c中生成的符号sum一致 &#x2F;&#x2F;这样链接进行符号重定位的时候，在符号引用的地方找到符号定义的地方，不会报出链接 &#x2F;&#x2F;错误&#125; （2）c程序调用c++程序由于没有extern “c++”这样的机制，实际上c程序调用c++程序相对还是比较麻烦的，需要在c++源文件在每一个可能被c程序调用的函数外加extern “C”以生成c程序可以识别的符号。test.cpp 1234567extern &quot;C&quot;&#123; int sum(int a,int b)&#x2F;&#x2F;生成的符号为sum，而不是sum_int_int &#123; return a+b; &#125;&#125; main.c 123456int sum(int a,int b);&#x2F;&#x2F;sum函数声明，生成的符号为sumint main()&#123; sum(a,b);&#x2F;&#x2F;调用 return 0;&#125; 可见，上述的处理不会引起链接错误。但由于其实际应用非常麻烦，现在大多采用的是动态链接库和静态链接库。 综上：c++程序调用c程序相对简单，而c程序调用c++程序相对复杂。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"将N阶二维数组的右上三角部分的数字乘以m(整数)","slug":"将N阶二维数组的右上三角部分的数字乘以m(整数)","date":"2018-06-19T02:34:04.000Z","updated":"2020-11-29T19:35:27.767Z","comments":true,"path":"2018/06/19/将N阶二维数组的右上三角部分的数字乘以m(整数)/","link":"","permalink":"http://example.com/2018/06/19/%E5%B0%86N%E9%98%B6%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%B3%E4%B8%8A%E4%B8%89%E8%A7%92%E9%83%A8%E5%88%86%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%98%E4%BB%A5m(%E6%95%B4%E6%95%B0)/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#define N 3void fun(int arr[][N],int m)&#123; for(int i &#x3D; 0;i &lt; N;++i) &#123; for(int j &#x3D; 0;j &lt;&#x3D; i;++j) &#123; arr[j][i] *&#x3D; m; &#125; &#125;&#125;void show(int arr[][N],int len)&#123; for(int i &#x3D; 0;i &lt; len;++i) &#123; for(int j &#x3D; 0;j &lt; len;++j) &#123; printf(&quot;%d &quot;,arr[i][j]); if(j &#x3D;&#x3D; len-1) &#123; printf(&quot;\\n&quot;); &#125; &#125; &#125;&#125;int main()&#123; int arr[][N] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; int len &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); show(arr,len); fun(arr,2);&#x2F;&#x2F;乘以2 show(arr,len); return 0;&#125;","categories":[{"name":"编程练习","slug":"编程练习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"统计文章中单词个数","slug":"统计文章中单词个数","date":"2018-06-17T15:44:29.000Z","updated":"2020-11-29T19:35:27.667Z","comments":true,"path":"2018/06/17/统计文章中单词个数/","link":"","permalink":"http://example.com/2018/06/17/%E7%BB%9F%E8%AE%A1%E6%96%87%E7%AB%A0%E4%B8%AD%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0/","excerpt":"","text":"123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;assert.h&gt;int fun(const char* str)&#123; assert(str !&#x3D; NULL); const char* p &#x3D; str; int count &#x3D; 0;&#x2F;&#x2F;计数器 while(*p !&#x3D; &#39;\\0&#39;) &#123; if(*p !&#x3D; &#39; &#39; &amp;&amp; (*(p+1) &#x3D;&#x3D; &#39; &#39; || *(p+1) &#x3D;&#x3D; &#39;\\0&#39;)) &#123; count ++; &#125; p++; &#125; retrun count;&#125;","categories":[{"name":"编程练习","slug":"编程练习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"位运算练习题","slug":"位运算练习题","date":"2018-06-13T12:16:10.000Z","updated":"2020-11-29T19:35:27.703Z","comments":true,"path":"2018/06/13/位运算练习题/","link":"","permalink":"http://example.com/2018/06/13/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"","text":"位运算和移位运算作为计算机的基本运算之一，其都是对二进制位进行操作。掌握它是非常有必要的。位运算包括与、或、非和异或。下面是一些位运算的练习题： 1234567891011121314151、去掉最后一位 101101 -&gt; 101102、在最后加一个0 101101 -&gt; 10110103、在最后加一个1 101101 -&gt; 10110114、把最后一位变成0 101101 -&gt; 1011005、把最后一位变成1 101100 -&gt; 1011016、把最后一位取反 101101 -&gt; 1011007、把右数第k位变成1 k&#x3D;3 101001 -&gt; 1011018、把右数第k位变成0 k&#x3D;3 101101 -&gt; 1010019、右数第k位去反 k&#x3D;3 101001 -&gt; 10110110、取末三位 1101101 -&gt; 10111、取末k位 k&#x3D;5 1101101 -&gt; 0110112、取右数第k位 k&#x3D;4 1101101 -&gt; 113、把右边连续的1变成0 100101111 -&gt; 10010000014、把右边连续的0变成1 11011000 -&gt; 11011111","categories":[],"tags":[]},{"title":"区分算术移动和逻辑移动","slug":"区分算术移动和逻辑移动","date":"2018-06-06T00:26:16.000Z","updated":"2020-11-29T19:35:27.703Z","comments":true,"path":"2018/06/06/区分算术移动和逻辑移动/","link":"","permalink":"http://example.com/2018/06/06/%E5%8C%BA%E5%88%86%E7%AE%97%E6%9C%AF%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%80%BB%E8%BE%91%E7%A7%BB%E5%8A%A8/","excerpt":"","text":"移位运算是计算机三大基本运算之一，基本运算包括按位运算、逻辑运算和移位运算。基本运算的特点:（1）仅对寄存器中的数据进行运算。（2）计算机中最基本的操作单元，在一个时钟周期内完成。（3）需要控制信号。区分算术移位和逻辑移位从运算符本身是区分不了算术移位还是逻辑移位，因为它们的运算符号都是&lt;&lt;，&gt;&gt;,实际上取决于操作数的类型。如果操作数是无符号数即是逻辑移位，如果操作数是带符号数，是算术移位。 1.逻辑移位操作对象： 二进制无符号数，例如像地址。（1）逻辑右移特点：高位补0，低位移出。（2）逻辑左移特点：低位补0，高位移出。问题探究：什么时候会发生溢出？如何判断溢出？如果高位移出的是一，则左移发生溢出。 2.算术移位操作对象: 二进制有符号数，现代计算机中有符号数字使用补码表示。由于计算机不能识别正负号，而0和1恰好可以表示这两种状态。这样就将符号数字化了。问题探究：什么时候会发生溢出？如何判断溢出？算术左移溢出判断：如果移出的位不等于新的符号位，则溢出。算术右移不会发生溢出，但是如果移出的低位不为0，则可能发生数据丢失的的情况。 （1）算术左移算术左移：按指定的位数向左移位，C语言中用符号 “&lt;&lt;” 表示。**移出的位放在一个特殊的寄存器中，低位补0。**算术左移可以实现的功能: 左移n位实现乘以2^n的功能。 （2）算术右移算术右移：按指定的位数向右移位，C语言中用符号 “&gt;&gt;” 表示。算术右移可以实现的功能： 右移n位实现乘以2^(-n)的功能。","categories":[],"tags":[]},{"title":"图示构造函数的析构顺序（默认构造函数、拷贝构造函数和赋值运算符重载函数）","slug":"图示构造函数的析构顺序（默认构造函数、拷贝构造函数和赋值运算符重载函数）","date":"2018-05-29T09:42:40.000Z","updated":"2020-11-29T19:35:27.703Z","comments":true,"path":"2018/05/29/图示构造函数的析构顺序（默认构造函数、拷贝构造函数和赋值运算符重载函数）/","link":"","permalink":"http://example.com/2018/05/29/%E5%9B%BE%E7%A4%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%EF%BC%88%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89/","excerpt":"","text":"示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;class Test&#123;public: Test(int a&#x3D;10,int b&#x3D;20) &#123; _a &#x3D; a; _b &#x3D; b; cout &lt;&lt; this &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;Test(int,int)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;_a &#x3D; &quot; &lt;&lt; _a &lt;&lt; &quot;,_b &#x3D; &quot; &lt;&lt; _b &lt;&lt; endl; &#125; Test(const Test&amp; src) &#123; _a &#x3D; src._a; cout &lt;&lt; this &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;_a &#x3D; &quot; &lt;&lt; _a &lt;&lt; &quot;,_b &#x3D; &quot; &lt;&lt; _b &lt;&lt; endl; &#125; void operator&#x3D;(const Test&amp; src) &#123; _a &#x3D; src._a; cout &lt;&lt; this &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;operator(const Test&amp;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;_a &#x3D; &quot; &lt;&lt; _a &lt;&lt; &quot;,_b &#x3D; &quot; &lt;&lt; _b &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; this &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; cout &lt;&lt; &quot;_a &#x3D; &quot; &lt;&lt; _a &lt;&lt; &quot;,_b &#x3D; &quot; &lt;&lt; _b &lt;&lt; endl; &#125;private: int _a; int _b;&#125;;Test t1(20,20);int main()&#123; Test t2(30,30); Test t3 &#x3D; t2; static Test t4 &#x3D; Test(40,40); t2 &#x3D; Test(50,50); t2 &#x3D; (Test)(60,60); t2 &#x3D; 70; Test *p1 &#x3D; &amp;Test(70,70); Test &amp;q &#x3D; Test(80,80); Test *p2 &#x3D; new Test; delete p2; return 0;&#125;Test t5(90,90); 运行结构分析：","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"孤儿进程和僵尸进程的概念及进程回收（wait函数及waitpid函数）","slug":"孤儿进程和僵尸进程的概念及进程回收（wait函数及waitpid函数）","date":"2018-05-26T02:34:50.000Z","updated":"2020-11-29T19:35:27.723Z","comments":true,"path":"2018/05/26/孤儿进程和僵尸进程的概念及进程回收（wait函数及waitpid函数）/","link":"","permalink":"http://example.com/2018/05/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%EF%BC%88wait%E5%87%BD%E6%95%B0%E5%8F%8Awaitpid%E5%87%BD%E6%95%B0%EF%BC%89/","excerpt":"","text":"一.孤儿进程孤儿进程可以理解为一个子进程的父进程英年早逝（父进程先于子进程退出），就将这样的一个进程称为孤儿进程，在linux操作系统上。孤儿进程被init进程收养，此时孤儿进程的ppid==1，即init进程的pid == 1。也就是说init进程变成孤儿进程的父进程（干爹）。 下面举例说明什么是孤儿进程： 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;stdio.h&gt;int main()&#123; pid_t pid &#x3D; fork(); if(pid &#x3D;&#x3D; 0)&#x2F;&#x2F;子进程 &#123; sleep(1);&#x2F;&#x2F;目的是让父进程先于子进程执行完毕 printf(&quot;son process start\\n&quot;); printf(&quot;my pid is %d,my ppid is %d\\n&quot;,getpid(),getppid()); printf(&quot;son process end\\n&quot;); &#125; else &#123; printf(&quot;father process start\\n&quot;); printf(&quot;my pid is %d\\n&quot;,getpid()); printf(&quot;father process end\\n&quot;); &#125; return 0;&#125; 从执行结果来看，此时由pid == 3363父进程创建的子进程，其输出的父进程pid == 1，说明当其为孤儿进程时被init进程回收。 我们查证一下init进程的pid是否为1 操作系统为什么要给孤儿进程分配init进程收养孤儿进程？其目的只有一个，就是为了释放系统资源进程结束之后，能够释放用户区空间。但不能释放pcb（进程控制块），即内核资源。pcb必须由子进程的父进程进行释放。 二.僵尸进程（1）父进程成功创建子进程，且子进程先于父进程退出。（2）子进程需要父进程回收其所占资源，释放pcb。但是父进程不作为，不去释放已经退出子进程的pcb。（3）这样的子进程变为僵尸进程。（4）僵尸进程是一个已经死掉了的进程。 下面举例验证什么是僵尸进程： 1234567891011121314151617181920#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;int main()&#123; pid_t pid &#x3D; fork();&#x2F;&#x2F;创建子进程 if(pid &#x3D;&#x3D; 0) &#123; printf(&quot;my pid is %d\\n&quot;,getpid()); printf(&quot;my ppid is %d\\n&quot;,getppid()); &#125; else &#123; while(1) &#123; ;&#x2F;&#x2F;死循环，阻塞 不处理已经退出的子进程，致使子进程称为僵尸进程 &#125; &#125; return 0;&#125; 从图可以看出，子进程执行完毕。父进程处于阻塞状态（陷入死循环）。再开启另外一个bash窗口，使用ps -aux | grep 3749命令查看僵尸进程的状态。defunct是已死的，僵尸的意思。也就是说pid值为3749的进程为僵尸进程，是因为其父亲不对已经结束的子进程做进程回收。但是已经结束的子进程的资源必须由其父进程进行回收，因而产生了僵尸进程。 试想一下，如果有大量的僵尸进程驻在系统之中，必然消耗大量的系统资源。但是系统资源是有限的，因此当僵尸进程达到一定数目时，系统因缺乏资源而导致奔溃。所以在实际编程中，避免和防范僵尸进程的产生显得尤为重要。 三.进程回收（1）回收僵尸进程的资源，一种比较暴力的做法是将其父进程杀死，那么子进程资源也将被回收。但是这种做法在大多数情况下都是不可取的，如父进程是一个服务器程序，如果为了回收其子进程的资源，而杀死服务器程序，那么将导致整个服务器崩溃，得不偿失。显然这种回收进程的方式是不可取的，但其也有一定的存在意义。那么有没有更好的解决方案呢，且看下边的两种方式。注：kipp -9 + (父进程的pid)是第一种回收子进程资源的方式。 （2）wait系统调用函数所需头文件： 12#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;wait.h&gt; 函数原型： pid_t wait(int* status)，是一个阻塞函数。 返回值：如果为-1,回收失败，已经没有子进程可以回收了。 如果 &gt; 0,返回值为子进程对应的pid。 参数：子进程的退出状态，是一个传出参数。判断子进程是如何死的 （1）正常退出 （2）被信号杀死 （1）WIFEXITED（status）：为非0，进程正常结束。 WEXITSTATUS（status）：如果上宏为真，使用此宏，获取进程的退出状态（exit/return的参数）。（2）WIFEXITEDWIFSIGNALED（status）：为非0，进程异常终止。WTERMSIG（status）：如上宏为真，使用此宏，获取使进程终止的那个信号的编号。 注意：pid_t类型即为int类型。调用一次，只能回收一个子进程，如果回收多个子进程，就需要多次调用wait函数。函数功能：（1）阻塞并等待子进程退出。（2）回收子进程残留资源。（3）获取子进程结束状态（退出原因）。 实例一：不关心子进程的退出状态 1234567891011121314151617181920#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;wait.h&gt;int main()&#123; pid_t pid &#x3D; fork(); if(0 &#x3D;&#x3D; pid) &#123; printf(&quot;my pid is %d\\n&quot;,getpid()); &#125; else &#123; sleep(1);&#x2F;&#x2F;目的是让子进程先于父进程结束 &#x2F;*wait函数是阻塞函数，会等到子进程结束回收资源*&#x2F; pid_t dpid &#x3D; wait(NULL);&#x2F;&#x2F;对子进程的退出状态不关心 printf(&quot;the died son process pid is %d\\n&quot;,dpid); &#125; return 0;&#125; 执行结果： 实例二：利用参数int* status获取子进程的退出状态 1.获取正常退出的状态 12345678910111213141516171819202122232425#include&lt;sys&#x2F;types&#x2F;h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; pid_t pid &#x3D; fork(); if(0 &#x3D;&#x3D; pid) &#123; printf(&quot;my pid is %d\\n&quot;,getpid()); &#125; else &#123; sleep(1); int status &#x3D; 0;&#x2F;&#x2F;初始化为0 pid_t dpid &#x3D; wait(&amp;status); if(WIFEXITED(status)) &#123; printf(&quot;exit value:%d\\n&quot;,WEXITSTATUS(status)); &#125; printf(&quot;the died son process pid is %d\\n&quot;,dpid); &#125; return 10;&#x2F;&#x2F;返回值为10 &#125; 执行结果：2.获取异常退出的状态。 12345678910111213141516171819202122232425262728#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; pid_t pd &#x3D; fork(); if(pid &#x3D;&#x3D; 0) &#123; while(1) &#123; printf(&quot;my pid is %d\\n&quot;,getpid()); sleep(2);&#x2F;&#x2F;控制执行速度不要太快 &#125; else &#123; sleep(1); int status &#x3D; 0;&#x2F;&#x2F;初始化为0 wait(&amp;status); if(WIFSIGNALED(status)) &#123; printf(&quot;exit by signal : %d\\n&quot;,WTEEMSIG(status)); &#125; &#125; &#125; return 0;&#125; 查找子进程的pid值，并杀死。 再次查看执行结果 使用kill -l命令可以擦看所有信号，其中编号为9的信号是SIGKILL。 子进程被编号为9的信号杀死。（3）waitpid系统调用函数函数功能：和wait函数相同。所需头文件 12#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;wait.h&gt; 函数原型： pid_t waitpid(pid_t pid,int* status,int options)返回值：（1）&gt;0：返回清理掉的子进程的PID。（2）-1：无子进程可以回收。（3）=0：参数3为WNOHANG，且子进程正在运行。参数：1.pid 可以有选择的回收（1）pid：pid == -1,等待任意子进程，与wait等效。（2）pid &gt; 0,等待其进程ID与pid相等的子进程。（3）pid == 0,等待其组ID等于调用进程的组ID的任一子进程。（4）pid &lt; -1,等待其组ID等于pid的绝对值的任一子进程。2.status：子进程的退出状态，用法同wait函数。3.options：设置为WNOHANG,函数非阻塞。设置为0，阻塞函数。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"字符串匹配算法 -- 朴素匹配","slug":"字符串匹配算法 -- 朴素匹配","date":"2018-05-18T08:10:25.000Z","updated":"2020-11-29T19:35:27.707Z","comments":true,"path":"2018/05/18/字符串匹配算法 -- 朴素匹配/","link":"","permalink":"http://example.com/2018/05/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20--%20%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D/","excerpt":"","text":"**何为匹配? **就是在一个串中寻找是否和有何目标串相同的真字串。 为什么叫做朴素匹配，我理解的就是这是一种寻常想法，简单粗暴的算法。是一种暴力的算法，不考虑其时间复杂度以及效率。只要达到匹配的目的即可。 代码实现： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;static int PuSu(const char* s,const char* sub,int pos)&#123; assert(s !&#x3D; NULL); assert(sub !&#x3D; NULL); int i &#x3D; pos;&#x2F;&#x2F;从主串的第pos个位置开始匹配 int j &#x3D; 0;&#x2F;&#x2F;目标串 int lens &#x3D; strlen(s); int lensub &#x3D; streln(sub); while(i &lt; lens &amp;&amp; j &lt; lensub) &#123; if(s[i] &#x3D;&#x3D; sub[j]) &#123; i++;j++; &#125; else &#123; i &#x3D; i - j + 1;&#x2F;&#x2F;主串回溯 j &#x3D; 0;&#x2F;&#x2F;目标串回退到下标为0 &#125; &#125; if(j &gt;&#x3D; lensub) &#123; return i-j; &#125; return -1;&#x2F;&#x2F;返回&#96;-1&#96;以示未匹配到&#125; 测似： 12345678int main()&#123; char* s &#x3D; &quot;abcdabad&quot;; char* sub &#x3D; &quot;aba&quot;;&#x2F;&#x2F;可以看出，在主串的第四个位置可以匹配到 下标从0开始 int n &#x3D; PuSu(s,sub,0); printf(&quot;n &#x3D; %d\\n&quot;,n); return 0;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"printf行缓冲的概念以及刷新缓冲区的条件","slug":"printf行缓冲的概念以及刷新缓冲区的条件","date":"2018-05-18T04:26:02.000Z","updated":"2020-11-29T19:35:27.679Z","comments":true,"path":"2018/05/18/printf行缓冲的概念以及刷新缓冲区的条件/","link":"","permalink":"http://example.com/2018/05/18/printf%E8%A1%8C%E7%BC%93%E5%86%B2%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%9D%A1%E4%BB%B6/","excerpt":"","text":"什么是行缓冲？当输入输出遇到换行符的这类缓冲定义为行缓冲。标准输入和标准输出都是行缓冲。引入缓冲区的目的是什么？简单的讲，设置缓冲区是为提高IO速度，减少CUP等待IO而浪费CPU资源。 大部分磁盘都是机械硬盘，读取寻道时间和写入寻道时间都是在ms级别。相对于内存读写速度都非常快，因为内存属于电子设备，读写速度时nm级别的。因此在内存上设置IO缓冲区，相对于从磁盘上读写数据可以显著的提高读写速度。缓冲区刷新的条件：1.进程结束。2.遇到\\n。3.缓冲区满。4.手动刷新缓冲区fflush(stdout)。5.调用exit(0);但是还可以调用_exit(0)，不刷新缓冲区。 下面一一测试缓冲区刷新的条件：（1）进程结束 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;assert.h&gt;#inckude&lt;sys&#x2F;types.h&gt;int main()&#123; pid_t pid &#x3D; for(); assert(pid !&#x3D; -1); if(pid &#x3D;&#x3D; 0)&#x2F;&#x2F;子进程 &#123; printf(&quot;aaa&quot;); &#125; else &#123; sleep(20);&#x2F;&#x2F;让子进程先获取CPU的控制权，让子进程先结束 wait();&#x2F;&#x2F;回收子进程的资源 &#125; return 0;&#125; 从执行结果可以看出，当子进程结束后，即进程接受后，缓冲区的内容被输出。（2）遇到\\n。 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;assert.h&gt;#include&lt;sys&#x2F;types.h&gt;int main()&#123; printf(&quot;hello&quot;);&#x2F;&#x2F;不加&#96;\\n&#96; &#x2F;*printf(&quot;hello\\n&quot;); 加\\n *&#x2F; pid_t pid &#x3D; fork(); assert(pid !&#x3D; -1); if(pid &#x3D;&#x3D; 0) &#123; printf(&quot;world&quot;); &#125; else &#123; wait(); &#125; return 0;&#125; 我们对上边两种情况进行对比：在这里还需要具备的知识，子进程只会拷贝fork之前父进程缓冲区的内容。第一种：加\\n第二种：不加\\n 对比图一和图二，为什么不加\\n子进程会输出helloworld而加了\\n输出的只有world呢？ 因为\\n具备刷新缓冲区的作用当没有添加\\n时，父进程缓冲区的内容hello被拷贝到子进程的缓冲区内，因此当子进程结束的时候会输出helloworld,而当添加\\n时刷新了父进程的缓冲区，所以进程结束的时候输出的只有子进程缓冲区中的内容world。（3）缓冲区满printf函数的缓冲区大小为1024个字节，当超出缓冲区的大小，缓冲区会被刷新。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"UDP协议的特点及UDP头部结构","slug":"UDP协议的特点及UDP头部结构","date":"2018-05-17T14:32:27.000Z","updated":"2020-11-29T19:35:27.707Z","comments":true,"path":"2018/05/17/UDP协议的特点及UDP头部结构/","link":"","permalink":"http://example.com/2018/05/17/UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8AUDP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"参考：王道《计算机网络复习指导》UDP协议的特点：（1）UDP无需建立连接。因此UDP不会引入建立连接的时延。试想如果DNS运行在TCP之上而不是UDP，则DNS的速度会满很多。HTTP使用TCP而不是UDP，是因为基于文本数据的Web网页来说，可靠性是至关重要的。什么是DNS？ DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。 （2）无连接状态。TCP需要在端系统中维护连接状态。此连接状态包括接受和发送缓存、拥塞控制参数和确认号和序号的参数。而UDP不维护连接状态，也不跟踪这些参数，因此某些专用应用服务器使用UDP时，一般都能支持更多的活动客户机。 （3）分组首部开销更小。TCP有20字节的的首部开销，而UDP只有8个字节的首部开销。 （4）应用层能够更地控制要发送的数据和发送时间。UDP没有拥塞控制，因此网络中的拥塞也不会影响主机的发送效率。某些实时应用（如直播）要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而UDP正好可以满足这些应用的需求。 （5）UDP常用于一次性传输比较小数据的网络应用，如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为创建连接、维护和拆除而带来不小的开销。UDP也常用于多媒体应用（如IP电话、实时视频会议、流媒体等），显然，可靠数据传输对于这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。 （6）UDP提供尽最大努力的交付，即不保证可靠交付，但并不意味着应用对数据的要求是不可靠的，因此需要维护传输可靠性的工作需要用户在应用层来完成。应用实体可以根据应用需求来灵活设计自己的可靠性机制。 （7）UDP是面向报文的的。发送方UDP对应用层交下来的报文，在添加首部后就交付给IP层，既不合并，也不拆分，而是保留这些报文的边界；接受方UDP对IP层交上来的用户数据报，在去除首部后就原封不动的交付给上层的应用进程，一次交付一个完整的报文，因此报文不可分割，是UDP数据处理的最小单位。 UDP头部结构 头部结构中各部分的作用：（1）16位源端口号 记录源端口号，在需要对方回信时选用。不需要时可用全0。（2）16位目的端口号 记录目标端口号。这在终点交付报文时必须要使用到。（3）长度 UDP数据报的长度（包括数据和首部），其最小值为8B（即仅有首部没有数据的情况）。（4）校验和 检测UDP数据报在传输中是否有错，有错就丢弃。该字段时可选的，当源主机不想计算校验和，则直接令该字段为全0。当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给进程。如果接收方UDP发现收到的报文中目的端口号不正确（即不存在对应端口号的应用进程），就丢弃该报文，并由ICMP发送“端口不可达”差错报文交给发送方。","categories":[],"tags":[]},{"title":"引用的条件及从汇编角度理解引用","slug":"引用的条件及从汇编角度理解引用","date":"2018-05-17T09:00:22.000Z","updated":"2020-11-29T19:35:27.719Z","comments":true,"path":"2018/05/17/引用的条件及从汇编角度理解引用/","link":"","permalink":"http://example.com/2018/05/17/%E5%BC%95%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%8F%8A%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8/","excerpt":"","text":"引用：引用可以看作是对已定义变量的别名，变量名实际上是对一段连续存储空间的别名。 关于引用几点比较重要的内容： （1）定义引用时必须进行初始化。（2）初始化的值要能取地址，不能用一个立即数进行初始化。 1int &amp;p &#x3D; 100;&#x2F;&#x2F;这是错误的 （3）引用不能改变，一旦初始化，不能引用其他变量名。（4）访问引用变量，永远访问的是被引用变量的内存。 引用的这几点重要的内容，可以反应出引用相对于指针来讲，更加安全。她不会引用一个未初始化的内存块，建议在C++中更多使用引用。提出一个问题，引用究竟有没有进行内存的开辟？许多书籍上写出引用没有开辟空间，到底对不对呢，还是理解的方向不正确？下面通过一段代码分析 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int a &#x3D; 10; int &amp;b &#x3D; a; int *p &#x3D; &amp;a; b &#x3D; 20; cout &lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot;,b &#x3D; &quot;&lt;&lt;b&lt;&lt;&quot;,*p &#x3D; &quot;&lt;&lt;*p&lt;&lt;endl; *p &#x3D; 30; cout &lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot;,b &#x3D; &quot;&lt;&lt;b&lt;&lt;&quot;,*p &#x3D; &quot;&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 由上图看出，修改引用和修改指针都达到修改a内存块值的目的。也就是说 a b *p似乎是一块内存。 试着输出一下int a = 10;int &amp;b = a;int *p = &amp;a;中a和b的地址，以及p的值。 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a &#x3D; 10; int &amp;b &#x3D; a; int *p &#x3D; &amp;a; cout &lt;&lt; hex &lt;&lt; &quot;&amp;a &#x3D; &quot; &lt;&lt; &amp;a &lt;&lt; &quot;,&amp;b &#x3D; &quot; &lt;&lt; &amp;b &lt;&lt; &quot;,p &#x3D; &quot; &lt;&lt; p &lt;&lt; endl; return 0;&#125; 在输出结果中，似乎变量a的地址、引用的地址相同。似乎验证了刚才提到的问题，引用没有开辟独立的内存块。实际则不然，下面看上述代码的反汇编： 12345678910111. int a &#x3D; 10;2. mov dword ptr [ebp-4],0Ah3. int &amp;b &#x3D; a;4. lea eax,[ebp-4]5. mov dword ptr [ebp-8],eax6. int *p &#x3D; &amp;a;7. lea ecx,[ebp-4]8. mov dword ptr [ebp-0Ch],ecx 对比上边3，4，5和6，7，8汇编代码，我们发现在底层语言中，压根就没有引用和指针的区别。在函数栈帧的开辟中，用栈底指针ebp的偏移量表示局部变量的地址。[ebp-4]对应的内存块就是a。 12345678910int &amp;b &#x3D; a;lea eax,[ebp-4]&#x2F;&#x2F;就是将内存块a的地址保存在eax寄存器中&#x2F;&#x2F;lea指令是移地址指令,对比下边int *p &#x3D; &amp;a的汇编指令是一摸一样.dword ptr [ebp-8],eax&#x2F;&#x2F;[ebp-8]即是引用b的内存块&#x2F;&#x2F;所以说引用是开辟了内存块的，用来保存被引用变量的地址。int *p &#x3D; &amp;a;lea ecx,[ebp-4]&#x2F;&#x2F;就是将内存块a的地址保存在eax寄存器中&#x2F;&#x2F;lea指令是移地址指令mov dword ptr [ebp-0Ch],ecx 通过上边的反汇编，我们可以得到的一条结论是：引用实际上开辟了内存用于保存被引用变量的地址。但是，为什么我们输出引用变量b的地址，却是内存块a的地址呢？实际上，只要一旦使用，在编译器内部就会自动进行解应用。也就是说永远不可能访问到引用变量b的地址，因为每当你使用引用时，已经经过解引用。 初学者如何方便的定义引用变量呢？通过上边的分析，引用底层也是一个指针。只是在使用时，就进行了解引用，对程序员来讲这个过程是透明的。 1234int a&#x3D;10;int *p &#x3D; &amp;a;&#x2F;&#x2F;首先定义一个指针&#x2F;&#x2F;将右边的取地址符&amp;覆盖左边的*符号，即可得到引用变量的定义int &amp;p &#x3D; a; 定义引用变量引用数组名 123456&#x2F;&#x2F;按照上边的规则int arr[10] &#x3D; &#123;0&#125;;&#x2F;&#x2F;首先定义一个指向数组的指针int (*p)[10] &#x3D; &amp;arr;&#x2F;&#x2F;将右边的取地址符&amp;覆盖左边的*符号，即可得到引用变量的定义int (&amp;p)[10] &#x3D; arr; 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int arr[10] &#x3D; &#123;0&#125;; int (*p)[10] &#x3D; &amp;arr; int (&amp;q)[10] &#x3D; arr; cout&lt;&lt;sizeof(arr)&lt;&lt;&quot; &quot; &lt;&lt;sizeof(p)&lt;&lt;&quot; &quot; &lt;&lt;sizeof(q)&lt;&lt;endl; return 0;&#125; 64bit编译器下，指针变量的大小为8个字节。 引用变量作为函数参数当数组名作为函数参数时会退化为指针，因此实际应用中往往还需要传递数组的长度。 12345678void fun(int arr[])&#123; printf(&quot;sizeof(arr)&#x3D;%d\\n&quot;,sizeof(arr));&#125;int main()&#123; int arr[10]&#x3D;&#123;0&#125;; printf(&quot;sizeof(arr)&#x3D;%d\\n&quot;,sizeof(arr)); fun(arr);&#125; 注：64bit编译器指针变量的大小为8个字节。引用作为函数参数 12345678910void fun(int (&amp;p)[10])&#123; cout&lt;&lt;&quot;sizeof(p)&#x3D;&quot;&lt;&lt;sizeof(p)&lt;&lt;endl;&#125;int main()&#123; int arr[10]&#x3D;&#123;0&#125;; int (&amp;p)[10] &#x3D; arr; cout&lt;&lt;&quot;sizeof(arr)&#x3D;&quot;&lt;&lt;sizeof(arr)&lt;&lt;endl; fun(p); return 0;&#125; 可见当引用变量引用数组名时，作为函数参数不会退化为指针。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"opendir/readdir/closedir 目录遍历相关函数","slug":"opendir!readdir!closedir 目录遍历相关函数","date":"2018-05-14T13:25:56.000Z","updated":"2020-11-29T19:35:28.003Z","comments":true,"path":"2018/05/14/opendir!readdir!closedir 目录遍历相关函数/","link":"","permalink":"http://example.com/2018/05/14/opendir!readdir!closedir%20%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/","excerpt":"","text":"1.打开目录所需头文件： 12#include&lt;sys&#x2F;types.h&gt;#include&lt;dirent.h&gt; opendir是一个C库函数，可以通过man 3 opendir查看函数相关的详细内容。 函数原型：DIR *opendir(const char *name) 参数：name为目录名。返回值：成功返回一个指向目录的指针，失败返回NULL,同时errno会被设置为一个合适的值。 2.读目录所需头文件： 1#include&lt;dirent.h&gt; 函数原型：struct dirent *readdir(DIR *dirp)参数：opendir函数的返回值。返回值：指向目录项结构体的指针。 1234567struct dirent&#123; ino_t d_ino; &#x2F;&#x2F;此目录进入点的inode off_t d_off; &#x2F;&#x2F;目录文件开头至此目录进入点的偏移 signed short int d_reclen; &#x2F;&#x2F;d_name的长度,不包括NULL字符 unsigned char d_type; &#x2F;&#x2F;d_name所指文件的类型 char d_name[256]; &#x2F;&#x2F;文件名&#125; 123&#x2F;&#x2F;类型声明ino_t 为 unsigned long intoff_t 为 long int 实例应用：在当前目录下有一个dir目录文件： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;dirent.h&gt;#include&lt;assert.h&gt;#include&lt;sting.h&gt;#include&lt;sys&#x2F;types.h&gt;int main(int argc,char *argv[])&#123; DIR *drip &#x3D; opendir(argv[1]); if(drip &#x3D;&#x3D; NULL) &#123; perror(&quot;opendir&quot;); exit(1); &#125; struct dirent* dir &#x3D; NULL; dir &#x3D; readdir(drip); assert(dir !&#x3D; NULL); printf(&quot;Inode &#x3D; %lu\\n&quot;,dir-&gt;d_ino); printf(&quot;目录文件至此目录进入点的偏移 &#x3D; %ld\\n&quot;,dir-&gt;d_off); return 0;&#125; 3.关闭目录所需头文件： 12#include&lt;sys&#x2F;types.h&gt;#include&lt;dirent.h&gt; 函数原型：int close(DIR *drip)参数：opendir函数的返回值。返回值：成功关闭返回0，失败返回-1，同时errno被设置为一个合适的值。 注意：closedir与opendir搭配使用。大家可以与C语言中的fopen和fclose函数联系，其作用是相同的。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"linux系统调用函数 rename/getcwd/chdir/mkdir/rmdir--目录操作相关函数","slug":"linux系统调用函数 rename!getcwd!chdir!mkdir!rmdir--目录操作相关函数","date":"2018-05-14T10:33:04.000Z","updated":"2020-11-29T19:35:28.023Z","comments":true,"path":"2018/05/14/linux系统调用函数 rename!getcwd!chdir!mkdir!rmdir--目录操作相关函数/","link":"","permalink":"http://example.com/2018/05/14/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%20rename!getcwd!chdir!mkdir!rmdir--%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/","excerpt":"","text":"1.文件重命名在linux的shell解释器中输入mv 原文件名 新文件名即可进行重命名，实际上C库函数提供了具有相同功能的系统调用函数rename。 所需头文件：#include&lt;stdio.h&gt;函数原型： int rename(const char *oldpath,const char *newpath)参数： oldpath原文件名,newpath为新文件名。返回值：成功返回0，失败返回-1，同时errno被设置为合适的值。 该函数用法比较简单，不做实例验证，大家可以自行验证。 2.修改当前进行（应用程序）的路径 cd。所需头文件： #include&lt;unistd.h&gt;函数原型： int chdir(const char *path)参数： path即为要切换的路径。返回值： 成功返回0，失败返回-1,同时errno会被设置为合适的值。 3.获取当前进程的工作目录 pwd函数原型：char* getcwd(char *buf,size_t size)参数：buf,缓冲区，存储当前的工作目录。size，缓冲区的大小。返回值：成功返回当前的工作目录，失败返回NULL。 实例验证：（1）输入pwd获取当前工作目录。（2）函数验证 1234567891011121314151617#include&lt;stdio.h&gt;#unclude&lt;sys&#x2F;types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char buff[128] &#x3D; &#123;0&#125;; char* s &#x3D; getcwd(buff,sizeof(buff)); if(NULL &#x3D;&#x3D; s) &#123; perror(&quot;getcwd&quot;); exit(1); &#125; printf(&quot;%s\\n&quot;,buff); return 0;&#125; 观察上图结果和我们用pwd获取到的当前工作目录是一致的。 4.创建目录 mkdir所需头文件： 12#include&lt;sys&#x2F;stat.h&gt;#include&lt;sys&#x2F;types.h&gt; 函数原型：int mkdir(const char *pathname,mode_t mode)参数：pathname为目录名 mode是目录权限，是一个八进制的数字，实际权限：mode &amp; ~umask返回值：成功返回0，失败返回-1，同时errno会被设置成一个合适的值。 5.删除一个空目录 rmdir所需头文件： 1#include&lt;unistd&gt; 函数原型：int rmdir(const char* pathname)参数：空目录的名字。返回值：成功返回0，失败返回-1，同时errno会被设置为一个合适的值。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"linux系统调用函数 chmod/chown/truncate--修改文件属性","slug":"linux系统调用函数 chmod!chown!truncate--修改文件属性","date":"2018-05-14T09:39:33.000Z","updated":"2020-11-29T19:35:28.359Z","comments":true,"path":"2018/05/14/linux系统调用函数 chmod!chown!truncate--修改文件属性/","link":"","permalink":"http://example.com/2018/05/14/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%20chmod!chown!truncate--%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"1.chmod 修改文件权限所需头文件： #include&lt;sys/stat.h&gt;函数原型： int chmod(const char *filename,int mode)参数： filename为文件名，mode为文件权限，八进制数。返回值：成功返回0，失败返回-1，同时errno会被设置为合适值。 应用实例：当前目录文件下：我们在应用chmod函数修改其a.txt的权限。 123456789101112131415#include&lt;stdio.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int res &#x3D; chmod(&quot;.&#x2F;a.txt&quot;,0777); if(res &#x3D;&#x3D; -1) &#123; perror(&quot;chmod&quot;); exit(1); &#125; printf(&quot;chmod success!\\n&quot;); return 0;&#125; 2.修改文件所有者和所属组。所需头文件： #include&lt;unistd.h&gt;函数原型： int chown(const char *path,uid_t owner,gid_t group)参数： path为文件路径，相对路径和绝对路径均可。 owner（无符号整型），用户ID。group（无符号整型）组ID。返回值：成功返回0，失败返回-1，同时errno会被设置为一个合适的值。 注意：可以通过 /etc/passwd访问用户ID，通过/etc/group访问组ID。使用man文档查看passwd的组成，man 5 passwd。 3.修改文件大小。所需头文件： 12#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt; 函数原型： int truncate(const char *path,off_t length)参数： path为文件名，length为为文件的最终大小。off_t为长整型，long int。（1）最终大小比原来大，向后扩展。（2）最终大小比原来小，删除后边的部分。 应用实例：现在在当前目录文件下创建名为a.txt的文件，再没行数如10个字符，且行为都有一个换行符，如下：所以其大小为55。 现在我们在代码中分别进行扩大和缩小文件大小，观察结果进行对比： 1234567891011121314151617181920&#x2F;&#x2F;1.扩大a.txt文件#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;int main()&#123; int res &#x3D; truncate(&quot;a.txt&quot;,100);&#x2F;&#x2F;将其扩大为100 if(res &#x3D;&#x3D; -1) &#123; perror(&quot;truncate&quot;); exit(1); &#125; else &#123; printf(&quot;&quot;truncate success!\\n); &#125; return 0;&#125; 由图可知，此时a.txt文件已经扩大至100。我们查看一下此时a.txt文件中的内容：这里的^@其实就是\\0。和man文档中的描述是一致的。 1234567891011121314151617181920&#x2F;&#x2F;2.缩小a.txt文件#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;int main()&#123; int res &#x3D; truncate(&quot;a.txt&quot;,25);&#x2F;&#x2F;将其缩小为25 if(res &#x3D;&#x3D; -1) &#123; perror(&quot;truncate&quot;); exit(1); &#125; else &#123; printf(&quot;&quot;truncate success!\\n); &#125; return 0;&#125; 执行后，查看此时的a.txt文件的大小：所以缩小源文件的大小会造成数据的丢失，使用请慎重。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"linux系统调用函数 access--获取文件属性","slug":"linux系统调用函数 access--获取文件属性","date":"2018-05-14T04:15:36.000Z","updated":"2020-11-29T19:35:28.019Z","comments":true,"path":"2018/05/14/linux系统调用函数 access--获取文件属性/","link":"","permalink":"http://example.com/2018/05/14/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%20access--%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"所需头文件: #include&lt;unistd.h&gt;函数原型： int access(const char *pathname,int mode) 参数： pathname代表文件名，绝对路径或相对路径都可以。 mode代表权限，共四种。分别是R_OK(读)、W_OK(写)、X_OK(执行)和 F_OK(文件是否存在)。 返回值： 0 表示存在某种权限，或文件不存在。 -1 没有，或文件不存在。功能：测试当前用户指定文件是否具有某种属性，注意当前用户，使用哪个用户调用这个函数，这个用户就是当前用户。 下面举例应用access函数： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char *argv[])&#123; if(argc &lt; 2) &#123; printf(&quot;filename:%s\\n&quot;,argv[0]); exit(1); &#125; int res &#x3D; access(argv[1],R_OK);&#x2F;&#x2F;X_OK,W_OK和F_OK测试方法相同 if(res &#x3D;&#x3D; -1) &#123; perror(&quot;access&quot;); exit(1); &#125; else &#123; printf(&quot;%s can be read!\\n&quot;,argv[1]); &#125; return 0;&#125; 当前目录下的文件： 运行上述代码，结果如下：","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"TCP协议的特点及TCP头部结构信息","slug":"TCP协议的特点及TCP头部结构信息","date":"2018-05-14T03:17:20.000Z","updated":"2020-11-29T19:35:28.035Z","comments":true,"path":"2018/05/14/TCP协议的特点及TCP头部结构信息/","link":"","permalink":"http://example.com/2018/05/14/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8ATCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF/","excerpt":"","text":"TCP协议的特点：（1）相对于传输层的UDP协议，TCP协议的特点是面向连接的、可靠的传输和字节流。（2）使用TCP协议通信的双方必须首先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上的数据传输。TCP是全双工通信，即双方的数据读写可以通过一个连接进行。完成数据交换后，通信双方必须断开连接以释放系统资源。（3）TCP是端对端的，所以基于广播和多播的应用程序不能使用TCP服务，而无连接的UDP协议则非常适合于广播和多播。 TCP的头部结构 （1）16位端口号：告诉主机该报文段来自哪里以及传给哪个上层协议或应用程序（目的端口号）的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务器端口号。在/etc/services中可以查看相关服务的端口。如http，ftp等。著名的http和ftp服务的端口号位80和21。 （2）32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向的字节流的每个字节的编号。（注意是每一个自己都由编号）。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN。那么在该传输方向上（A -&gt; B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携数据的第一个字节在整个字节流中的偏移。 （3）32位确认号：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值+1。现在假设主机A于主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且还包含对B发送来的TCP报文段的确认号。反之亦然。 （4）4位头部长度： 用来标识TCP头部有多少个32bit字（4字节）。因为四位二进制数最大是15，所以TCP头部最长有60字节。 （5）6位标志位：URG：紧急指针。ACK：标识确认号是否有效。PSH：提示接受端应用程序应该立即从TCP接受缓冲区中读走数据，为接受后续数据腾出空间（如果应用程序不将接受到的数据读走，它们就会一直停留在TCP缓冲区中）。RST：表示要求对方重新建立连接。将携带RST标志的TCP报文段称为复位报文段。SYN：表示请求建立一个连接。将携带SYN标志的TCP报文段称为同步报文段。FIN：表示通知对方本端要关闭连接了。将携带FIN标志的TCP报文段称为结束报文段。 （6）16位窗口大小：这是控制TCP流量的一个手段。这里的窗口，指的是接受通告窗口。它告诉对方本端的TCP缓冲区还能容纳多少位字节的数据，这样对方就可以控制发送数据的速度。 （7）16位校验和：由发送端填充，接受端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意：这里的检验不仅包括TCP头部，也包括数据部分。这是TCP传输可靠的一个重要保障。 （8）16位紧急指针：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切的说，这个字段的紧急指针是相对于当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接受端发送紧急数据的方法。 参考《Linux 高性能服务器编程》","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"linux系统调用函数  lstat--获取文件属性","slug":"linux系统调用函数  lstat--获取文件属性","date":"2018-05-13T01:03:56.000Z","updated":"2020-11-29T19:35:28.043Z","comments":true,"path":"2018/05/13/linux系统调用函数  lstat--获取文件属性/","link":"","permalink":"http://example.com/2018/05/13/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%20%20lstat--%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"所需头文件： 123#include&lt;unistd.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;sys&#x2F;types.h&gt; 函数功能：用来获取linux操作系统下文件的属性。函数原型： int stat(const char *pathname,struct stat *buf); 参数：第一个参数为传入参数，pathname为文件的绝对路径或相对路径。第二参数为传出参数，一个struct stat类型的结构体指针。传出参数可以采用下边两种方法，定义结构体变量struct stat st,或定义结构体指针变量*strut stat st = &amp;st(注意这里一定要进行初始化，说明其为一块有效的内存空间)，相对而言，使用结构体变量更为方便。 注意，在linux操作系统下，一切皆文件。文件共有七种类型，分别是普通文件、目录文件、管道文件、可执行文件、压缩文件、设备文件（字符、管道和块）和其他文件。 下面介绍一下struct stat结构体： 123456789101112131415struct stat &#123; dev_t st_dev; 文件的设备编号 ino_t st_ino; 节点 mode_t st_mode; 文件的类型和权限 nlink_t st_nlink; 连到该文件的硬链接数目，刚建立的文件值为1 uid_t st_uid; 用户ID gid_t st_gid; 组ID dev_t st_rdev; 设备类型）若此文件为设备文件，则为其设备编号 off_t st_size; 文件字节数（文件大小） blksize_t st_blksize; 块大小（文件I&#x2F;O缓冲区的大小） blkcnt_t st_blocks; 块数 time_t st_atime; 最后一次访问时间 time_t st_mtime; 最后一次修改时间 time_t st_ctime; 最后一次改变时间（指属性）&#125;; 下面举例使用stat函数获取文件的属性：在linux的shell解释器中，输入这样的命令stat + 文件名即可获取文件的属性。如：那么如何在函数中获取文件属性并将其打印出来呢？下面应用stat函数获取main.c文件的属性。 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;int main()&#123; struct stat st;&#x2F;&#x2F;定义结构体变量，保存所获取的文件属性 int res &#x3D; stat(&quot;&#x2F;home&#x2F;lsc&#x2F;Desktop&#x2F;linux&#x2F;k0512&#x2F;test&#x2F;main.c&quot;，&amp;st); if(res &#x3D;&#x3D; -1)&#x2F;&#x2F;获取文件属性失败，errno设置为合适的值 &#123; perror(&quot;stat fail&quot;); exit(1); &#125; printf(&quot;大小:%d &quot;,st.st_size); printf(&quot;设备:%d &quot;,st.st_dev); printf(&quot;块:%d &quot;,st_st_blocks); printf(&quot;Inode:%d &quot;,st.st_ino); printf(&quot;硬链接:%d &quot;,st.st_nlink); printf(&quot;uid:%d &quot;,st.st_uid); printf(&quot;gid:% &quot;,st.st_gid); return 0;&#125; 执行结果：和我们用stat + 文件名命令获取到文件的属性信息是一致的。 大家可能注意到，在代码中并为涉及输出st_mode属性相关的信息。重点：下面着重深入的研究一下st_mode这属性，可以通过它来获取文件的文件类型以及权限。 mode_t st_mode是一个16位的short类型，对应16个标志位，其组成如下： 而其，通常情况下特殊权限位不使用。那么如何取出对应的位置的位获取相关的信息呢，Linux系统调用给我们提供了一系列的宏，可以查看man文档 man 2 stat。 1234567891011121314151617181920212223S_IFMT 0170000 &#x2F;&#x2F;掩码，过滤st_mode中除文件类型以外的信息S_IFSOCK 0140000 &#x2F;&#x2F;套接字S_IFLNK 0120000 &#x2F;&#x2F;符号链接(软链接)S_IFREG 0100000 &#x2F;&#x2F;普通文件S_IFBLK 0060000 &#x2F;&#x2F;块设备S_IFDIR 0040000 &#x2F;&#x2F;目录文件S_IFCHR 0020000 &#x2F;&#x2F;字符设备S_IFIFO 0010000 &#x2F;&#x2F;管道S_ISUID 0004000 &#x2F;&#x2F;设置用户IDS_ISGID 0002000 &#x2F;&#x2F;设置组IDS_ISVTX 0001000 &#x2F;&#x2F;粘住位S_IRWXU 00700 &#x2F;&#x2F;掩码，过滤st_mode除文件所有者权限以外的信息S_IRUSR 00400 &#x2F;&#x2F;用户读权限S_IWUSR 00200 &#x2F;&#x2F;用户写权限S_IXUSR 00100 &#x2F;&#x2F;用户执行权限S_IRWXG 00070 &#x2F;&#x2F;掩码，过滤st_mode除所属组权限以外的信息S_IRGRP 00040 &#x2F;&#x2F;读权限S_IWGRP 00020 &#x2F;&#x2F;写权限S_IXGRP 00010 &#x2F;&#x2F;执行权限S_IRWXO 00007 &#x2F;&#x2F;掩码，过滤st_mode除其他人权限以外的信息S_IROTH 00004 &#x2F;&#x2F;读权限S_IWOTH 00002 &#x2F;&#x2F;写权限S_IXOTH 00001 &#x2F;&#x2F;执行权限 下面举一个简单例子，验证一个文件是否为普通文件。在当前目录下有一个普通文件： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#incude&lt;sys&#x2F;stat.h&gt;#include&lt;sys&#x2F;types.h&gt;int main()&#123; struct stat st; int res &#x3D; stat(&quot;.&#x2F;test.c&quot;,&amp;st); if(-1 &#x3D;&#x3D; res) &#123; perror(&quot;stat fail&quot;); exit(1); &#125; if((st.st_mode &amp; S_IFMT) &#x3D;&#x3D; S_IFREG) &#123; printf(&quot;regular file\\n&quot;); &#125; return 0;&#125; 相信完全理解了系统调用函数stat之后，实现一个ls -l的命令也会变得简单，大家可以试试。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"C和C++中经const修饰的常量、常变量和普通变量的区别","slug":"C和C++中经const修饰的常量、常变量和普通变量的区别","date":"2018-05-12T06:23:53.000Z","updated":"2020-11-29T19:35:28.067Z","comments":true,"path":"2018/05/12/C和C++中经const修饰的常量、常变量和普通变量的区别/","link":"","permalink":"http://example.com/2018/05/12/C%E5%92%8CC++%E4%B8%AD%E7%BB%8Fconst%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B8%B8%E9%87%8F%E3%80%81%E5%B8%B8%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.在C89标准下的const const 修饰的类型是一个常变量，不能作为数组的下标。常变量不能作为左值。 如： 1234const int a &#x3D; 10;int b &#x3D; a;&#x2F;&#x2F;其编译的过程和一般变量编译的过程相同&#x2F;&#x2F;并不会把引用符号的地方替换为对应的数据 2.C++99 （1）常量：在c++中，const int a = 10是一个真真正正的常量。（2）常变量：退化为常变量的情况，初始化为一个不明确的值。（3）常变量和普通变量生成的符号的作用域不一样。 12int a &#x3D; 10;const int b &#x3D; a;&#x2F;&#x2F;在编译阶段不会进行运算 对比下面两段代码，都是执行打印操作，但在本质上它们是有区别的。 123456&#x2F;&#x2F;常变量int a &#x3D; 10;const int b &#x3D; a;cout &lt;&lt; b &lt;&lt; endl;mov eax,dword ptr[ebp-8]push eax 123456&#x2F;&#x2F;常量const int b &#x3D; 20;cout &lt;&lt; b &lt;&lt; endl;&#x2F;&#x2F;cout其实也是函数调用，调用会压参数。&#x2F;&#x2F;汇编代码push 20 测试常量和普通变量所生成符号的作用域： 123456789#include&lt;iostream&gt;using namespace std;int a &#x3D; 10;&#x2F;&#x2F;普通全局变量const int d &#x3D; 20;&#x2F;&#x2F;常量int main()&#123; return 0;&#125; 1.g++ test.cpp -c 生成test.o文件2.使用readelf -s test.o命令查看编译之后生成的符号表。 由图可见，普通变量生成的符号为GLOBAL，而经过const修饰的常量生成的符号是LOCAL。所以普通变量和常量作用域是不相同的。 3.要访问另外一个文件中定义的常量的方法。在定义处添加extern关键字，使其编程后生成的符号为GLOBAL，这样链接器就可以对其进行处理。 12345678910&#x2F;&#x2F;简单的测试一下，方法同上#include&lt;iostream&gt;using namespace std;extern const int a &#x3D; 10;int mian()&#123; return 0;&#125;&#x2F;&#x2F;g++ test.cpp -c -o test.o&#x2F;&#x2F;readelf -s test.o 可以看到，经过extern修饰的常量，进过编译生成的符号表中其作用域变为GLOBAL。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"c++函数重载概念及重载规则","slug":"c++函数重载概念及重载规则","date":"2018-05-06T05:19:14.000Z","updated":"2020-11-29T19:35:27.983Z","comments":true,"path":"2018/05/06/c++函数重载概念及重载规则/","link":"","permalink":"http://example.com/2018/05/06/c++%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99/","excerpt":"","text":"函数重载概念： 用一个函数名定义不同的函数，当函数名和不同的参数搭配是函数的含义不同。 重载规则：1.函数名需相同。2.参数的个数、参数的顺序和参数的类型不同均可构成重载。3.在同一作用域4.返回值类型不同不能构成重载。5.对实参是否有影响，如volatile/const修饰的指针或引用时，也可以构成重载。 123456789101112int fun(int a,int b); &#x2F;&#x2F;可以int fun(float a,float b); &#x2F;&#x2F;可以int fun(char a,char b); &#x2F;&#x2F;可以float fun(int a,int b); &#x2F;&#x2F;不可以int fun(int a,float b);&#x2F;&#x2F;可以int fun(float a,int b);&#x2F;&#x2F;可以int func(int *p);int func(const int *p);int fun(int&amp; a);int fun(const int&amp; a);","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"C/C++函数调用约定汇总","slug":"C!C++函数调用约定汇总","date":"2018-04-22T05:26:11.000Z","updated":"2020-11-29T19:35:28.127Z","comments":true,"path":"2018/04/22/C!C++函数调用约定汇总/","link":"","permalink":"http://example.com/2018/04/22/C!C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E6%B1%87%E6%80%BB/","excerpt":"","text":"转: VC C/C++ 函数调用约定（最全） 函数调用约定 常见的函数调用约定[5]：cdecl , stdcall , fastcall , thiscall , naked call MFC调用约定(VS6:Project Settings-&gt;C/C++ Calling convention:) 1, __cdecl（C调用约定.The C default calling convention）C/C++ 缺省调用方式 ，缺省即默认。 1)压栈顺序:函数参数从右到左 2)参数栈维护:由调用函数把参数弹出栈,传送参数的内存栈由调用函数来维护 。 （正因为如此，实现可变参数vararg的函数(如printf)只能使用该调用约定） 3)函数修饰名约定:VC将函数编译后会在函数名前面加上下划线前缀 。 4)每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大 。 2, __stdcall (Pascal方式清理C方式压栈，通常用于Win32 Api中) 1)压栈顺序:函数参数从右到左的压栈顺序 。 2)参数栈维护:被调用函数把参数弹出栈(在退出时清空堆栈)。 3)函数修饰名约定:VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上”@”和参数的字节数。 ex. VC: int f(void *p) (编译后)-&gt; _f@4(在外部汇编语言里可以用这个名字引用这个函数) 3, __fastcall (快速调用约定,通过寄存器来传送参数) 1)压栈顺序:用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送 2)参数栈维护:被调用函数在返回前清理传送参数的内存栈 3)函数修饰名约定:VC将函数编译后会在函数名前面加上”@”前缀，在函数名后加上”@”和参数的字节数 4, thiscall (本身调用,仅用于“C++”成员函数) 1)压栈顺序:this指针存放于CX/ECX寄存器中，参数从右到左的压栈顺序 2)thiscall不是关键词，因此不能被程序员指定 5, naked call (裸调) 1)当采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来 保存ESI，EDI，EBX，EBP寄存器,退出函数时则产生代码恢复这些寄存器的内容 (这些代码称作 prolog and epilog code,一般，ebp,esp的保存是必须的) 2)naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用 关键字 __stdcall、__cdecl和__fastcall(1-3)可以直接加在要输出的函数前。 它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl 要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，函数名修饰约定可通过其它方法模仿 WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定， 在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs 引用: 很多API函数就是象这样声明的: int WINAPI MessageBoxA(HWND,LPCSTR,LPSTR,UINT); 而WINAPI实际上就是__stdcall. 大多数API都采用__stdcall调用规范,这是因为几乎所有的语言都支持__stdcall调用. 相比之下,__cdecl只有在C语言中才能用. 但__cdecl调用有一个特点,就是能够实现可变参数的函数调用, 比如printf,这用__stdcall调用是不可能的. __fastcall这种调用规范比较少见,但是在Borland C++ Builder中比较多的采用了这种调用方式. 如果有共享代码的需要,比如写DLL,推荐的方法是用__stdcall调用,因为这样适用范围最广. 如果是C++语言写的代码供Delphi这样的语言调用就必须声明为__stdcall, 因为Pascal不支持cdecl调用(或许Delphi的最新版本能够支持也说不定,这个不太清楚). 在其他一些地方,比如写COM组件,几乎都用的是stdcall调用. 在VC或Delphi或C++Builder里面都可以从项目设置中更改默认的函数调用规范, 当然也可在函数声明时加入__stdcall,__cdecl,__fastcall关键字来明确的指示本函数用哪种调用约定. __declspec一般都是用来声明DLL中的导出函数.这个关键字也有一些其他的用法,不过非常罕见. __declspec主要是用于说明DLL的引出函数的,在某些情况下用__declspec(dllexport)在DLL中声明引出函数, 比用传统的DEF文件方便.在普通程序中也可用__declspec(dllimport)说明函数是位于另一个DLL中的导出函数.例子不太好举啊,其实就是在函数声明的时候多加一个关键字,比如很多API函数就是象这样声明的: int WINAPI MessageBoxA(HWND,LPCSTR,LPSTR,UINT); 而WINAPI实际上就是__stdcall. 大多数API都采用__stdcall调用规范,这是因为几乎所有的语言都支持__stdcall调用.相比之下,__cdecl只有在C语言中才能用.但是__cdecl调用有一个特点,就是能够实现可变参数的函数调用,比如printf,这用__stdcall调用是不可能的. __fastcall这种调用规范比较少见,但是在Borland C++ Builder中比较多的采用了这种调用方式. 如果有共享代码的需要,比如写DLL,推荐的方法是用__stdcall调用,因为这样适用范围最广.如果是C++语言写的代码供Delphi这样的语言调用就必须声明为__stdcall,因为Pascal不支持cdecl调用(或许Delphi的最新版本能够支持也说不定,这个我不太清楚).在其他一些地方,比如写COM组件,几乎都用的是stdcall调用.在VC或Delphi或C++Builder里面都可以从项目设置中更改默认的函数调用规范,当然你也可以在函数声明的时候加入__stdcall,__cdecl,__fastcall关键字来明确的指示本函数用哪种调用规范. __declspec一般都是用来声明DLL中的导出函数.这个关键字也有一些其他的用法,不过非常罕见. 关于DLL的函数： 动态链接库中定义有两种函数：导出函数(export function)和内部函数(internal function)。 导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用。 输出函数的方法有以下几种： 1、传统的方法 在模块定义文件的EXPORT部分指定要输入的函数或者变量。语法格式如下： entryname[=internalname] [@ordinal[NONAME]] [DATA] [PRIVATE] 其中： entryname是输出的函数或者数据被引用的名称； internalname同entryname; @ordinal表示在输出表中的顺序号(index)； NONAME仅仅在按顺序号输出时被使用（不使用entryname）； DATA表示输出的是数据项，使用DLL输出数据的程序必须声明该数据项为_declspec(dllimport)。 上述各项中，只有entryname项是必须的，其他可以省略。 对于“C”函数来说，entryname可以等同于函数名；但是对“C++”函数（成员函数、非成员函数） 来说，entryname是修饰名。可以从.map映像文件中得到要输出函数的修饰名，或者使用 DUMPBIN /SYMBOLS得到，然后把它们写在.def文件的输出模块。DUMPBIN是VC提供的一个工具。 如果要输出一个“C++”类，则把要输出的数据和成员的修饰名都写入.def模块定义文件。 2、在命令行输出 对链接程序LINK指定/EXPORT命令行参数，输出有关函数。 3、使用MFC提供的修饰符号_declspec(dllexport) 在要输出的函数、类、数据的声明前加上_declspec(dllexport)的修饰符，表示输出。__declspec (dllexport)在C调用约定、C编译情况下可以去掉输出函数名的下划线前缀。extern “C”使得在C++中 使用C编译方式成为可能。在“C++”下定义“C”函数，需要加extern “C”关键词。用extern “C”来 指明该函数使用C编译方式。输出的“C”函数可以从“C”代码里调用。 例如，在一个C++文件中，有如下函数： extern “C” {void __declspec(dllexport) __cdecl Test(int var);} 其输出函数名为：Test MFC提供了一些宏，就有这样的作用。 AFX_CLASS_IMPORT：__declspec(dllexport) AFX_API_IMPORT：__declspec(dllexport) AFX_DATA_IMPORT：__declspec(dllexport) AFX_CLASS_EXPORT：__declspec(dllexport) AFX_API_EXPORT：__declspec(dllexport) AFX_DATA_EXPORT：__declspec(dllexport) AFX_EXT_CLASS： #ifdef _AFXEXT AFX_CLASS_EXPORT #else AFX_CLASS_IMPORT AFX_EXT_API：#ifdef _AFXEXT AFX_API_EXPORT #else AFX_API_IMPORT AFX_EXT_DATA：#ifdef _AFXEXT AFX_DATA_EXPORT #else AFX_DATA_IMPORT 像AFX_EXT_CLASS这样的宏，如果用于DLL应用程序的实现中，则表示输出（因为_AFX_EXT被定义，通 常是在编译器的标识参数中指定该选项/D_AFX_EXT）；如果用于使用DLL的应用程序中，则表示输入 （_AFX_EXT没有定义）。 要输出整个的类，对类使用_declspec(_dllexpot)；要输出类的成员函数，则对该函数使用 _declspec(_dllexport)。如： class AFX_EXT_CLASS CTextDoc : public CDocument { … } extern “C” AFX_EXT_API void WINAPI InitMYDLL(); 这几种方法中，最好采用第三种，方便好用；其次是第一种，如果按顺序号输出，调用效率会高些； 最次是第二种。 ////////////////////// 模块定义文件(.DEF) 模块定义文件(.DEF)是一个或多个用于描述DLL属性的模块语句组成的文本文件，每个DEF文件至少必 须包含以下模块定义语句： 第一个语句必须是LIBRARY语句，指出DLL的名字； EXPORTS语句列出被导出函数的名字；将要输出的函数修饰名罗列在EXPORTS之下，这个名字必须与定义函数的名字完全一致，如此就得到一个没有任何修饰的函数名了。 可以使用DESCRIPTION语句描述DLL的用途(此句可选)； “;”对一行进行注释(可选)。 //////////////////////////// DLL程序和调用其输出函数的程序的关系 1、dll与进程、线程之间的关系 DLL模块被映射到调用它的进程的虚拟地址空间。 DLL使用的内存从调用进程的虚拟地址空间分配，只能被该进程的线程所访问。 DLL的句柄可以被调用进程使用；调用进程的句柄可以被DLL使用。 DLL使用调用进程的栈。 2、关于共享数据段 DLL定义的全局变量可以被调用进程访问；DLL可以访问调用进程的全局数据。使用同一DLL的每一个 进程都有自己的DLL全局变量实例。如果多个线程并发访问同一变量，则需要使用同步机制；对一个 DLL的变量，如果希望每个使用DLL的线程都有自己的值，则应该使用线程局部存储(TLS，Thread Local Strorage)。 在程序里加入预编译指令，或在开发环境的项目设置里也可以达到设置数据段属性的目的.必须给 这些变量赋初值,否则编译器会把没有赋初始值的变量放在一个叫未被初始化的数据段中。 extern “C” 指示编译器用C语言方法给函数命名。 在制作DLL导出函数时由于C++存在函数重载，因此 __declspec(dllexport) function(int,int) 在DLL会被decorate，例如被decorate成为 function_int_int，而且不同的编译器decorate的方法不同，造成了在用GetProcAddress取得function地址时的不便，使用extern “C”时，上述的decorate不会发生，因为C没有函数重载，但如此一来被extern”C”修饰的函数，就不具备重载能力，可以说extern 和 extern “C”不是以回事。 __declspec(dllexport) 声明一个导出函数，是说这个函数要从本DLL导出。我要给别人用。一般用于dll中__declspec(dllimport) 声明一个导入函数，是说这个函数是从别的DLL导入。我要用。一般用于使用某个dll的exe中_declspec(thread)可以降低程序员的负担，又能做到线程局部存储的要求。VC++允许一个变量或结构被声明为“具有线程局部性”。例如，下面的声明，如果放在一个DLL之中，将产生出一个全局变量，对每一个进程而言独一无二： DWORD gProgressCounter； 但是如果这样声明，它就是对每一个线程独一无二： _declspec(thread) DWORD gProgressCounter; 每一个以这种方式声明对象的EXE和DLL，将在可执行文件中有一个特殊的节区(section),内含所有的线程局部变量。当EXE或DLL被载入时，操作系统会认识这个节区并适当的处理之。这个节区会被操作系统社定为“对每一个线程具有局部性”。 当一个EXE被载入时，操作系统扫描可执行文件以及所有静态链接(implicity linked)的DLLs，以便找出所有的线程局部节区。所有节区的大小被加总在一起以求出每个线程启动时应该配置的内存数量。 __declspec(align(16)) struct SS{ int a,b; };它与#pragma pack()是一对兄弟，前者规定了对齐的最小值，后者规定了对齐的最大值。同时出现时，前者优先级高。 __declspec(align())的一个特点是，它仅仅规定了数据对齐的位置，而没有规定数据实际占用的内存长度，当指定的数据被放置在确定的位置之后，其后的数据填充仍然是按照#pragma pack规定的方式填充的，这时候类/结构的实际大小和内存格局的规则是这样的：在__declspec(align())之前，数据按照#pragma pack规定的方式填充，如前所述。当遇到__declspec(align())的时候，首先寻找距离当前偏移向后最近的对齐点（满足对齐长度为max(数据自身长度,指定值))，然后把被指定的数据类型从这个点开始填充，其后的数据类型从它的后面开始，仍然按照#pragma pack填充，直到遇到下一个__declspec(align())。当所有数据填充完毕，把结构的整体对齐数值和__declspec(align())规定的值做比较，取其中较大的作为整个结构的对齐长度。 特别的，当__declspec(align())指定的数值比对应类型长度小的时候，这个指定不起作用。 #pragma section(“segname”,read) / __declspec(allocate(“segname”)) int i = 0; / int main(){ return 1;};此关键词必须跟随code_seg,const_seg,data_seg,init_seg,section关键字之后使用，以上例子使用了section关键字。使用此关键字将告知编译器，其后的变量间被分配在那个数据段。 __declspec(deprecated(MY_TEXT)) void func(int) {}与pragma deprecated()相同。此声明后，如果在同一作用域中使用func(int)函数，将被提醒c4996警告。 __declspec( dllimport ) declarator&amp; __declspec( dllexport ) declarator无须多说，此二关键字用于导入导出外接元素。 __declspec(jitintrinsic)用于标记一个函数或元素为64位公共语言运行时。具体用法未见到。 __declspec( naked ) int func( formal_parameters ) {}此关键字仅用于x86系统，多用于硬件驱动。此关键字可以使编译器在生成代码时不包含任何注释或标记。仅可以对函数的定义使用，不能用于数据声明、定义，或者函数的声明。 __declspec(restrict) float * init(int m, int n) {};&amp; __declspec(noalias) void multiply(float * a, float * b, float * c) {}；// 优化必用！__declspec(restrict)仅适用于返回指针的函数声明，如 __declspec(restrict) void *malloc(size_t size);restrict declspec 适用于返回非别名指针的函数。此关键字用于 malloc 的 C 运行时库实现，因为它决不会返回已经在当前程序中使用的指针值（除非您执行某个非法操作，如在内存已被释放之后使用它）。restrict declspec 为编译器提供执行编译器优化的更多信息。对于编译器来说，最大的困难之一是确定哪些指针会与其他指针混淆，而使用这些信息对编译器很有帮助。有必要指出，这是对编译器的一个承诺，编译器并不对其进行验证。如果您的程序不恰当地使用 restrict declspec，则该程序的行为会不正确。 __declspec(noalias)也是仅适用于函数，它指出该函数是半纯粹的函数。半纯粹的函数是指仅引用或修改局部变量、参数和第一层间接参数。此 declspec 是对编译器的一个承诺，如果该函数引用全局变量或第二层间接指针参数，则编译器会生成将中断应用程序的代码。 class X {/ __declspec(noinline) int mbrfunc() { return 0; /* will not inline*/ };在类中声明一个函数不需要内联。 __declspec(noreturn) extern void fatal () {}不需要返回值。 void __declspec(nothrow) __stdcall f2();不存在异常抛出。 struct __declspec(novtable) X { virtual void mf(); };/ struct Y : public X {void mf() {printf_s(“In Y/n”);}};此关键字标记的类或结构不能直接实例化，否则将引发AV错误(access violation)。此关键字的声明将阻止编译器对构造和析构函数的vfptr的初始化。可优化编译后代码大小。 struct S { int i;/ void putprop(int j) { i = j; }/ int getprop() { return i; }/ __declspec(property(get = getprop, put = putprop)) int the_prop;};此关键字与C#中get &amp; set属性相同，可定义实现针对一个字段的可读或可写。以上例子，可以使用(如果实例化S为ss)如：ss.the_prop = 156;(此时，ss.i == 156)接着如果：cout&lt;&lt; s.the_prop;(此时将调用getprop，使返回156)。 __declspec(selectany)（转）在MFC，ATL的源代码中充斥着__declspec(selectany)的声明。selectany可以让我们在.h文件中初始化一个全局变量而不是只能放在.cpp中。比如有一个类，其中有一个静态变量，那么我们可以在.h中通过类似__declspec(selectany) type class::variable = value; 这样的代码来初始化这个全局变量。既是该.h被多次include，链接器也会为我们剔除多重定义的错误。对于template的编程会有很多便利。 __declspec(thread) int in_One_Thread;声明in_One_Thread为线程局部变量并具有线程存储时限，以便链接器安排在创建线程时自动分配的存储。 struct __declspec(uuid(“00000000-0000-0000-c000-000000000046”)) IUnknown;将具有唯一表示符号的已注册内容声明为一个变量，可使用__uuidof()调用。 __cdecl,__stdcal和__fastcalll 这三个修饰符是c和c++调用约定调用约定(Calling convention)决定以下内容：函数参数的压栈顺序，由调用者还是被调用者把参数弹出栈，以及产生函数修饰名的方法。MFC支持以下调用约定：__cdecl,__stdcal和__fastcalll都是函数调用规范,规定了参数出入栈的顺序和方法,如果只用VC编程的话可以不用关心,但是要在C++和Pascal等其他语言通信的时候就要注意了,只有用相同的方法才能够调用成功.另外,像printf这样接受可变个数参数的函数只有用cdecl才能够实现. _cdecl按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于“C”函数或者变量，修饰名是在函数名前加下划线。对于“C++”函数，有所不同。如函数void test(void)的修饰名是_test；对于不属于一个类的“C++”全局函数，修饰名是?test@@ZAXXZ。这是MFC缺省调用约定。由于是调用者负责把参数弹出栈，所以可以给函数定义个数不定的参数，如printf函数。 _stdcall按从右至左的顺序压参数入栈，由被调用者把参数弹出栈。对于“C”函数或者变量，修饰名以下划线为前缀，然后是函数名，然后是符号“@”及参数的字节数，如函数int func(int a, double b)的修饰名是_func@12。对于“C++”函数，则有所不同。所有的Win32 API函数都遵循该约定。 _fastcall是把函数参数列表的前三个参数放入寄存器eax,edx,ecx,其他参数压栈。 fastcall是BCB为了更好的兼容Delphi写的VCL而用的，delphi中的默认call是fastcall，是把函数参数列表的前三个参数放入寄存器。举个例子,其实就是在函数声明的时候多加一个关键字,比如很多API函数就是象这样声明的:int WINAPI MessageBoxA(HWND,LPCSTR,LPSTR,UINT);而WINAPI实际上就是__stdcall.大多数API都采用__stdcall调用规范,这是因为几乎所有的语言都支持__stdcall调用.相比之下,__cdecl只有在C语言中才能用.但是__cdecl调用有一个特点,就是能够实现可变参数的函数调用,比如printf,这用__stdcall调用是不可能的.__fastcall这种调用规范比较少见,但是在Borland C++ Builder中比较多的采用了这种调用方式.如果有共享代码的需要,比如写DLL,推荐的方法是用__stdcall调用,因为这样适用范围最广.如果是C++语言写的代码供Delphi这样的语言调用就必须声明为__stdcall,因为Pascal不支持cdecl调用(或许Delphi的最新版本能够支持也说不定,这个我不太清楚).在其他一些地方,比如写COM组件,几乎都用的是stdcall调用.在VC或Delphi或C++Builder里面都可以从项目设置中更改默认的函数调用规范,当然你也可以在函数声明的时候加入__stdcall,__cdecl,__fastcall关键字来明确的指示本函数用哪种调用规范.__declspec主要是用于说明DLL的引出函数的,在某些情况下用__declspec(dllexport)在DLL中生命引出函数,比用传统的DEF文件方便一些.在普通程序中也可以用__declspec(dllimport)说明函数是位于另一个DLL中的导出函数. cdecl 由调用者清除堆栈 stdcall 由被调的函数清除堆栈 fastcall 是把函数参数列表的前三个参数放入寄存器eax,edx,ecx,其他参数压栈。1.今天写线程函数时，发现msdn中对ThreadProc的定义有要求：DWORD WINAPI ThreadProc(LPVOID lpParameter);不解为什么要用WINAPI宏定义，查了后发现下面的定义。于是乎需要区别__stdcall和__cdecl两者的区别； #define CALLBACK __stdcall 123456789#define WINAPI __stdcall#define WINAPIV __cdecl#define APIENTRY WINAPI#define APIPRIVATE __stdcall#define PASCAL __stdcall#define cdecl _cdecl#ifndef CDECL#define CDECL _cdecl#endif 几乎我们写的每一个WINDOWS API函数都是__stdcall类型的，首先，需要了解两者之间的区别： WINDOWS的函数调用时需要用到栈（STACK，一种先入后出的存储结构）。当函数调用完成后，栈需要清楚，这里就是问题的关键，如何清除？？ 如果我们的函数使用了_cdecl，那么栈的清除工作是由调用者，用COM的术语来讲就是客户来完成的。这样带来了一个棘手的问题，不同的编译器产生栈的方式不尽相同，那么调用者能否正常的完成清除工作呢？答案是不能。 如果使用__stdcall，上面的问题就解决了，函数自己解决清除工作。所以，在跨（开发）平台的调用中，我们都使用__stdcall（虽然有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用_cdecl。到这里我们有一个结论，如果你的程序中没有涉及可变参数，最好使用__stdcall关键字。2.__cdecl,__stdcall是声明的函数调用协议.主要是传参和弹栈方面的不同.一般c++用的是__cdecl,windows里大都用的是__stdcall(API)__cdecl是C/C++和MFC程序默认使用的调用约定，也可以在函数声明时加上__cdecl关键字来手工指定。采用__cdecl约定时，函数参数按照从右到左的顺序入栈，并且由调用函数者把参数弹出栈以清理堆栈。因此，实现可变参数的函数只能使用该调用约定。由于每一个使用__cdecl约定的函数都要包含清理堆栈的代码，所以产生的可执行文件大小会比较大。__cdecl可以写成_cdecl。__stdcall调用约定用于调用Win32 API函数。采用__stdcall约定时，函数参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，函数参数个数固定。由于函数体本身知道传进来的参数个数，因此被调用的函数可以在返回前用一条ret n指令直接清理传递参数的堆栈。__stdcall可以写成_stdcall。__fastcall约定用于对性能要求非常高的场合。__fastcall约定将函数的从左边开始的两个大小不大于4个字节（DWORD）的参数分别放在ECX和EDX寄存器，其余的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的堆栈。__fastcall可以写成_fastcall3.__stdcall:_stdcall 调用约定相当于16位动态库中经常使用的PASCAL调用约定。 在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。_stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上”@”和参数的字节数。_cdecl:_cdecl c调用约定, 按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。_cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。__fastcall:__fastcall调用约定是”人”如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。_fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上”@”前缀，在函数名后加上”@”和参数的字节数。thiscall:thiscall仅仅应用于”C++”成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。naked call:采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用。另附:名字修饰约定1、修饰名(Decoration name)“C”或者“C++”函数在内部（编译和链接）通过修饰名识别。修饰名是编译器在编译函数定义或者原型时生成的字符串。有些情况下使用函数的修饰名是必要的，如在模块定义文件里头指定输出“C++”重载函数、构造函数、析构函数，又如在汇编代码里调用“C””或“C++”函数等。修饰名由函数名、类名、调用约定、返回类型、参数等共同决定。2、名字修饰约定随调用约定和编译种类(C或C++)的不同而变化。函数名修饰约定随编译种类和调用约定的不同而不同，下面分别说明。a、C编译时函数名修饰约定规则：__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为_functionname@number。__cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@functionname@number。它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，PASCAL约定输出的函数名无任何修饰且全部大写。b、C++编译时函数名修饰约定规则：__stdcall调用约定：1、以“?”标识函数名的开始，后跟函数名；2、函数名后面以“@@YG”标识参数表的开始，后跟参数表；3、参数表以代号表示：X–void ，D–char，E–unsigned char，F–short，H–int，I–unsigned int，J–long，K–unsigned long，M–float，N–double，_N–bool，….PA–表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复；4、参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前；5、参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。其格式为“?functionname@@YG****@Z”或“?functionname@@YGXZ”，例如int Test1（char *var1,unsigned long）—–“?Test1@@YGHPADK@Z”void Test2（） —–“?Test2@@YGXXZ”__cdecl调用约定：规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。__fastcall调用约定：规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。VC++对函数的省缺声明是“__cedcl“,将只能被C/C++调用.CB在输出函数声明时使用4种修饰符号//__cdeclcb的默认值，它会在输出函数名前加_，并保留此函数名不变，参数按照从右到左的顺序依次传递给栈，也可以写成_cdecl和cdecl形式。//__fastcall她修饰的函数的参数将尽肯呢感地使用寄存器来处理，其函数名前加@，参数按照从左到右的顺序压栈；//__pascal它说明的函数名使用Pascal格式的命名约定。这时函数名全部大写。参数按照从左到右的顺序压栈；//__stdcall使用标准约定的函数名。函数名不会改变。使用__stdcall修饰时。参数按照由右到左的顺序压栈，也可以是_stdcall；VC++对函数的省缺声明是”__cedcl”,将只能被C/C++调用. 注意：1、_beginthread需要__cdecl的线程函数地址，_beginthreadex和CreateThread需要__stdcall的线程函数地址。2、一般WIN32的函数都是__stdcall。而且在Windef.h中有如下的定义： #define CALLBACK __stdcall #define WINAPI __stdcall3、extern “C” _declspec(dllexport) int __cdecl Add(int a, int b); typedef int (__cdecl*FunPointer)(int a, int b); 修饰符的书写顺序如上。4、extern “C”的作用：如果Add(int a, int b)是在c语言编译器编译，而在c++文件使用，则需要在c++文件中声明：extern “C” Add(int a, int b)，因为c编译器和c++编译器对函数名的解释不一样（c++编译器解释函数名的时候要考虑函数参数，这样是了方便函数重载，而在c语言中不存在函数重载的问题），使用extern “C”，实质就是告诉c++编译器，该函数是c库里面的函数。如果不使用extern “C”则会出现链接错误。一般象如下使用： 123456789101112#ifdef _cplusplus#define EXTERN_C extern &quot;C&quot;#else#define EXTERN_C extern#endif#ifdef _cplusplusextern &quot;C&quot;&#123;#endif EXTERN_C int func(int a, int b);#ifdef _cplusplus&#125;#endif 5、DLLMain负责初始化(Initialization)和结束(Termination)工作，每当一个新的进程或者该进程的新的线程访问DLL时，或者访问DLL的每一个进程或者线程不再使用DLL或者结束时，都会调用DLLMain。但是，使用TerminateProcess或TerminateThread结束进程或者线程，不会调用DLLMain。6、一个DLL在内存中只有一个实例7、几乎我们写的每一个WINDOWS API函数都是__stdcall类型的，首先，需要了解两者之间的区别： WINDOWS的函数调用时需要用到栈（STACK，一种先入后出的存储结构）。当函数调用完成后，栈需要清除，这里就是问题的关键，如何清除？？如果我们的函数使用了_cdecl，那么栈的清除工作是由调用者，用COM的术语来讲就是客户来完成的。这样带来了一个棘手的问题，不同的编译器产生栈的方式不尽相同，那么调用者能否正常的完成清除工作呢？答案是不能。如果使用__stdcall，上面的问题就解决了，函数自己解决清除工作。所以，在跨（开发）平台的调用中，我们都使用__stdcall（虽然有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用_cdecl。到这里我们有一个结论，如果你的程序中没有涉及可变参数，最好使用__stdcall关键字。 另：_cdecl按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于“C”函数或者变量，修饰名是在函数名前加下划线。对于“C++”函数，有所不同。如函数void test(void)的修饰名是_test；对于不属于一个类的“C++”全局函数，修饰名是?test@@ZAXXZ。这是MFC缺省调用约定。由于是调用者负责把参数弹出栈，所以可以给函数定义个数不定的参数，如printf函数。stdcall 和pascal一样,都是pascal的调用习惯按从右至左的顺序压参数入栈，由被调用者把参数弹出栈。对于“C”函数或者变量，修饰名以下划线为前缀，然后是函数名，然后是符号“@”及参数的字节数，如函数int func(int a, double b)的修饰名是_func@12。对于“C++”函数，则有所不同。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"汇编角度看函数堆栈调用","slug":"汇编角度看函数堆栈调用","date":"2018-04-22T02:45:10.000Z","updated":"2020-11-29T19:35:28.123Z","comments":true,"path":"2018/04/22/汇编角度看函数堆栈调用/","link":"","permalink":"http://example.com/2018/04/22/%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E8%B0%83%E7%94%A8/","excerpt":"","text":"下面以主函数调用求和函数分析函数堆栈调用 带着以下一个问题来探索：（1）形参的内存空间的开辟和清理是由调用方还是由被调用方执行的？（2）主函数调用函数结束后，主函数从哪里开始执行？从头开始还是从调用之后开始？（3）返回值是如何带出来的？ 用于验证的代码如下： 123456789101112131415161718#include&lt;srtio.h&gt;int sum(int a,int b)&#123; int res &#x3D; 0; res &#x3D; a+b; return res;&#125;int main()&#123; int a &#x3D; 10; int b &#x3D; 20; int ret &#x3D; 0; ret &#x3D; sum(a,b); printf(&quot;ret &#x3D; %d\\n&quot;,ret); return 0;&#125; 实验环境：vc++ 6.0 和 Win10操作系统 注意：linux操作系统采用的汇编指令是AT&amp;T，而Windows采用的是intel x86最简易区分它们的规则是：intel x86从左向右读，而AT&amp;T是从右往左读。反汇编代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761: #include&lt;stdio.h&gt;2:3: int sum(int a,int b)4: &#123;00401020 push ebp00401021 mov ebp,esp00401023 sub esp,44h00401026 push ebx00401027 push esi00401028 push edi00401029 lea edi,[ebp-44h]0040102C mov ecx,11h00401031 mov eax,0CCCCCCCCh00401036 rep stos dword ptr [edi]5: int res &#x3D; 0;00401038 mov dword ptr [ebp-4],06: res &#x3D; a+b;0040103F mov eax,dword ptr [ebp+8]00401042 add eax,dword ptr [ebp+0Ch]00401045 mov dword ptr [ebp-4],eax7: return res;00401048 mov eax,dword ptr [ebp-4]8: &#125;0040104B pop edi0040104C pop esi0040104D pop ebx0040104E mov esp,ebp00401050 pop ebp00401051 ret int main()12: &#123;00401060 push ebp00401061 mov ebp,esp00401063 sub esp,4Ch00401066 push ebx00401067 push esi00401068 push edi00401069 lea edi,[ebp-4Ch]0040106C mov ecx,13h00401071 mov eax,0CCCCCCCCh00401076 rep stos dword ptr [edi]13: int a &#x3D; 10;00401078 mov dword ptr [ebp-4],0Ah14: int b &#x3D; 20;0040107F mov dword ptr [ebp-8],14h15: int ret &#x3D; 0;00401086 mov dword ptr [ebp-0Ch],016: ret &#x3D; sum(a,b);0040108D mov eax,dword ptr [ebp-8]00401090 push eax00401091 mov ecx,dword ptr [ebp-4]00401094 push ecx00401095 call @ILT+0(_sum) (00401005)0040109A add esp,80040109D mov dword ptr [ebp-0Ch],eax17:18: printf(&quot;ret &#x3D; %d\\n&quot;,ret);004010A0 mov edx,dword ptr [ebp-0Ch]004010A3 push edx004010A4 push offset string &quot;ret &#x3D; %d\\n&quot; (0042201c)004010A9 call printf (004010e0)004010AE add esp,819:20: return 0;004010B1 xor eax,eax21: &#125;004010B3 pop edi004010B4 pop esi004010B5 pop ebx004010B6 add esp,4Ch004010B9 cmp ebp,esp004010BB call __chkesp (00401160)004010C0 mov esp,ebp004010C2 pop ebp004010C3 ret 可以看到在主函数和求和函数中首先出现的反汇编代码，我们以求函数举例，其实它们的功能是相同的，就是开辟栈帧。 1234567891000401060 push ebp00401061 mov ebp,esp00401063 sub esp,4Ch00401066 push ebx00401067 push esi00401068 push edi00401069 lea edi,[ebp-4Ch]0040106C mov ecx,13h00401071 mov eax,0CCCCCCCCh00401076 rep stos dword ptr [edi] 要看懂以上的汇编代码，首先我们必须具备的基础知识是几条简单的汇编指令和寄存器的功能和作用以及通常用的几个寄存器。 1.常用的intelx86汇编指令。 12[push 寄存器] 功能：将一个寄存器中的数据入栈。包含两个动作：将寄存器中的数据入栈，栈顶指针向上（低地址）偏移。[pop 寄存器] 功能：出栈，以一个寄存器接受出栈的数据。包含两个动作：将栈中的数据保存在寄存器中，同时栈顶指针向下(高地址)偏移。 12[add 寄存器,数据] 如：add ax,8 &#x2F;&#x2F;相当于ax +&#x3D; 8;[sub 寄存器,数据] 如：sub bx,4 &#x2F;&#x2F;相当于bx -&#x3D; 4; 123456常见的几种mov指令：[mov 寄存器,寄存器] 如：move ax,8[mov 寄存器,数据] 如：move ax,bx[mov 寄存器，内存单元] 如：move ax,[0][mov 内存单元，寄存器] 如：move [0],ax[mov 段寄存器，寄存器] 如：move ds,ax 123call指令：call指令有两个动作(1)将下一行指令地址压栈(2)跳转 1[lea ax,[]] 功能：将有效地址放[]到指定寄存器中。 12345678[rep stos ]如：lea edi,[ebp-0C0h] mov ecx,30h mov eax,0CCCCCCCCh rep stos dword ptr [edi]rep指令的目的是重复其上面的指令。ecx寄存器中的值是重复的次数。stos指令的作用是将eax寄存器中的值拷贝到[edi]指向的地址。 2.常用的寄存器。 1234567eax：累加寄存器，它是许多加法乘法指令的缺省寄存器。(缺省即默认defalut)ebx：基地址寄存器，在内存寻址是存放基地址。ecx：计数器，是重复前缀指令res和loop指令的内定计数器。edx：总是被用来存放整数产生的余数。esp：专门用作堆栈指针，被形象的称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，esp就越来越小。在32位平台上，esp每次减少4个字节。ebp：堆栈的栈底指针。esi&#x2F;edi:&quot;分别叫做源&#x2F;目标索引寄存器&quot;(source&#x2F;destination index),因为在很多字符串操作指令中，DS:ESI指向源串，而ES:EDI指向目标串。 具备上边常用的intelx86汇编指令以及常用寄存器的功能。开始分析函数栈帧开辟的过程： 1234567891000401060 push ebp00401061 mov ebp,esp00401063 sub esp,4Ch00401066 push ebx00401067 push esi00401068 push edi00401069 lea edi,[ebp-4Ch]0040106C mov ecx,13h00401071 mov eax,0CCCCCCCCh00401076 rep stos dword ptr [edi] 123456789101112131415161718192021221.压栈，并将值保存于ebp寄存器中，即ebp指向该块内存区域。2.使得esp和ebp指向同一块内存区域，虽然esp和ebp是寄存器，但由于其内保存的是地址，所以在此我们也可以形象的将esp和ebp看做指针，便于理解。3.sub esp,4Ch,对照上边的汇编指令，这里做的操作是 -&#x3D; ，即esp &#x3D; esp-4ch,我们都知道，指针进行加减还是指针。所以栈顶指针向上(低地址)移动76个字节，为什么会移动76个字节。我们可以认为，编译认为主函数栈帧开辟76个字节大小完全足够使用。在这里还需要注意的一点是，虚拟地址空间中栈的生长方向是从高地址到低地址，所以我们看到的是esp-4ch。4.由于接下来的三条汇编指令 入栈00401066 push ebx00401067 push esi00401068 push edi与后边的出栈指令呼应，相当于没有入栈，在此不做赘述。004010B3 pop edi004010B4 pop esi004010B5 pop ebx5.lea edi [ebp-4ch],将[ebp-4ch]的地址存放在地址寄存器中。6.mov ecx,13h7.mov eax,CCCCCCCCh8.rep stos dword ptr [edi]以上三条指令构成循环拷贝指令，循环次数13.拷贝的内容，CCCCCCCCh,即汉字&quot;烫烫&quot;。也就是说开辟栈帧结束后，对其做初始化。这就是为什么当我们访问未初始化内存中的内容，看到的是如下图的情况。 12345678简单小程序验证一下:#include&lt;stdio.h&gt;int main()&#123; int ch; putchar(ch); return;&#125; //执行程序会报错，但可以通过调试查看内存获取内容。下面将开辟栈帧之后的图展示一下，以便理解： 下面分析栈帧开辟完成之后的汇编指令： 12345678910111213141516171819202113: int a &#x3D; 10;00401078 mov dword ptr [ebp-4],0Ah14: int b &#x3D; 20;0040107F mov dword ptr [ebp-8],14h15: int ret &#x3D; 0;00401086 mov dword ptr [ebp-0Ch],016: ret &#x3D; sum(a,b);0040108D mov eax,dword ptr [ebp-8]00401090 push eax00401091 mov ecx,dword ptr [ebp-4]00401094 push ecx00401095 call @ILT+0(_sum) (00401005)0040109A add esp,80040109D mov dword ptr [ebp-0Ch],eax17:18: printf(&quot;ret &#x3D; %d\\n&quot;,ret);004010A0 mov edx,dword ptr [ebp-0Ch]004010A3 push edx004010A4 push offset string &quot;ret &#x3D; %d\\n&quot; (0042201c)004010A9 call printf (004010e0)004010AE add esp,8 纵观上边列出的指令，可以看到。布局变量并没有表现出来，它是通过ebp栈底指针的偏移量来表示的。 1234567891013: int a &#x3D; 10;00401078 mov dword ptr [ebp-4],0Ah14: int b &#x3D; 20;0040107F mov dword ptr [ebp-8],14h15: int ret &#x3D; 0;00401086 mov dword ptr [ebp-0Ch],01.mov dword ptr [ebp-4],0Ah，dword表示双字，即四字节。即将0Ah放入[ebp-4]指向的四字节内存块中。2.mov dword ptr [ebp-8],14h，将14h放入[ebp-8]指向的四字节内存块中。3. mov dword ptr [ebp-0Ch],0，将0放入[ebp-0Ch]指向的四字节内存块中。 12345678916: ret &#x3D; sum(a,b);0040108D mov eax,dword ptr [ebp-8]00401090 push eax00401091 mov ecx,dword ptr [ebp-4]00401094 push ecx1.将[ebp-8]指向内存块中的值存入寄存器eax中，并进行压栈。同时栈顶指针向上偏移(低地址)。2.将[ebp-4]指向内存块中的值存入寄存器ecx中，并进行压栈。同时栈顶指针向上偏移(低地址)。在这两行代码中，可以得到以下的结论：(1)形参的内存是由调用方开辟的。 1234500401095 call @ILT+0(_sum) (00401005)这条指令是尤为重要的，前面已经讲过call指令有两个动作。(1)将下一条指令的地址压栈。(2)跳转 如何确定call指令是否执行了上述的动作，我们使用反汇编代码进行调试。黄箭头表示此条指令还未执行，那么我们查看此时栈底指针esp的地址，查看内存中的内容。查看0x0019fee0对应的内存块。可见上述实参10和20已经入栈，并且栈顶指针指向10(0A)所在的内存块。 下面执行call指令我们看看会发生什么？首先栈顶指针向上偏移(低地址)。重点：下一条指令的地址被压栈 由于intelx86体系的机器是小端模式，读取0x0019fedc内存块的内容,0040109A,正是call指令下一条指令的地址。 1200401095 call @ILT+0(_sum) (00401005)0040109A add esp,8 跳转到被调用函数中，首先也是开辟栈帧并作初始化，在此不做赘述。但是值得注意的是栈帧开辟的时候进行push ebp的操作。 123456785: int res &#x3D; 0;00401038 mov dword ptr [ebp-4],06: res &#x3D; a+b;0040103F mov eax,dword ptr [ebp+8]00401042 add eax,dword ptr [ebp+0Ch]00401045 mov dword ptr [ebp-4],eax7: return res;00401048 mov eax,dword ptr [ebp-4] 12341.在求和函数中，将0存入[ebp-4]指向的内存块中。2.将[ebp+8]指向的内存块中的值放入eax寄存器中，而[ebp+8]指向的内存块对应的正是实参&#96;10&#96;。3.将[eb[ebp+0Ch]指向的内存块中的值放入eax寄存器中，而[ebp+0Ch]指向的内存中对应的正是实参&#96;20&#96;。4.将eax寄存器中的值压栈，存放到[ebp-4]指向的内存块中，此时eax寄存器中的值为&#96;30&#96;。 12345678910117: return res;00401048 mov eax,dword ptr [ebp-4] 0040104E mov esp,ebp00401050 pop ebp00401051 ret 1.由mov eax,dword ptr [ebp-4]可知，函数的返回值(小于等于四个字节)是由寄存器带回的。 2.0040104E mov esp,ebp使得被调用函数栈帧回退。此时栈帧空间的内容还存在。 13.pop ebp 两个动作，出栈，并将出栈的值赋给ebp。在这里，即ebp&#x3D;&#x3D;0x100。栈顶指针向下回退四个字节(高地址)。 123456&#x2F;&#x2F;下面看主函数调用求和函数执行的指令0040109A add esp,80040109D mov dword ptr [ebp-0Ch],eax1.add esp,8 相当于esp &#x3D; esp + 8,是主函数压实参的栈帧回退。所以形参内存是由调用方清理的。2.将eax寄存器中的值&#96;30&#96;放入[ebp-0Ch]指向的四字节内存块中。 到这里，函数堆栈调用的过程就完全展示出来了。现在回答最开始我们提出的几个题： （1）形参的内存空间的开辟和清理是由调用方还是由被调用方执行的？（2）主函数调用函数结束后，主函数从哪里开始执行？从头开始还是从调用之后开始？（3）返回值是如何带出来的？ 答：（1）形参的内存空间的开辟和清理是由调用方执行的。（2）主函数调用函数后执行执行调用之后的代码，是因为调用方在进行调用的过程中，将下一行指令的地址压栈。所以调用完成之后是从调用之后开始，不会从头开始。（3）返回值是由累加寄存器eax带出来的（当返回值的字节数小于等于四个自己时）。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"子进程继承父进程的锁","slug":"子进程继承父进程的锁","date":"2018-04-20T12:47:41.000Z","updated":"2020-11-29T19:35:28.587Z","comments":true,"path":"2018/04/20/子进程继承父进程的锁/","link":"","permalink":"http://example.com/2018/04/20/%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%94%81/","excerpt":"","text":"fork函数调用会创建子进程，子进程的地址空间是在调用fork时父进程地址空间的拷贝。因为子进程地址空间跟父进程一样，所以调用fork时，子进程继承了父进程中的所有互斥锁、读写锁和条件变量（包括它们的状态）。 但在多线程环境中，调用fork时，子进程中只有一个线程存在，这个线程是调用fork函数的那个线程，其他线程都没有被拷贝。 根据上述两点，子进程中的锁可能被不存在的线程所拥有，这样子进程将没法获取或释放这些锁。针对这个问题有一个解决办法，即在调用fork之前，线程先获取进程中所有锁，在调用fork后分别在父子进程中释放这些锁，从而可以重新利用这些资源。因为fork之前，当前线程拥有所有的锁，所以fork之后，当前线程继续存在，子进程可以安全的释放这些锁。 当然，在调用fork后，子进程马上调用exec，就无需考虑这些问题了，因为子进程地址空间被完全更换了。 函数pthread_atfork专门用来解决这种问题： int pthread_atfork ( void (*prepare)(void), void (*parent)(void), void (*child)(void) ); pthread_atfork安装一些在fork调用时的回调函数。prepare函数将在fork创建子进程之前被调用，通常可以用来获取进程中的所有锁；parent在fork创建子进程后返回前在父进程中被调用，可以用来释放父进程中的锁；child在fork创建子进程后fork返回前在子进程中被调用，可以用来释放子进程中的锁。给这三个参数传递NULL，表示不调用该函数。 可以调用pthread_atfork多次注册多组回调函数，这时，回调函数调用的顺序规定如下： ①prepare函数调用顺序与它们的注册顺序相反； ②parent和child函数的调用顺序与注册顺序相同。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"多线程访问共享的全局变量引发的数据混乱","slug":"多线程访问共享的全局变量引发的数据混乱","date":"2018-04-17T11:55:06.000Z","updated":"2020-11-29T19:35:28.655Z","comments":true,"path":"2018/04/17/多线程访问共享的全局变量引发的数据混乱/","link":"","permalink":"http://example.com/2018/04/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1/","excerpt":"","text":"1.线程共享全局变量 在学习线程的相关概念之后，想探究在进程的虚拟地址空间当中的哪些区域是进程中多个线程共享的。探究发现，全局变量在不同的线程当中访问全局变量是共享的。举例如下： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;pthread.h&gt;&#x2F;&#x2F;线程库char *str;&#x2F;&#x2F;定义指向字符串的全局变量str&#x2F;&#x2F;线程函数void* my_fun(void *arg)&#123; printf(&quot;函数线程：str &#x3D; %s\\n&quot;,str); &#x2F;&#x2F;若共享，输出为主线程修改指向后指向的字符串，否则会出现段错误。 return NULL;&#125;int main(void)&#123; pthread_t id;&#x2F;&#x2F;传出参数，用于保存成功创建线程后对应线程的id int res &#x3D; pthread_create(&amp;id,NULL,my_fun,NULL); &#x2F;&#x2F;成功创建返回值为0 assert(0 &#x3D;&#x3D; res); str &#x3D; &quot;hello&quot;;&#x2F;&#x2F;修改全局指针变量的指向 pthread_exit(NULL);&#x2F;&#x2F;退出当前线程 return 0;&#125; 测试结果可见，全局变量在多个线程中是共享的。 2.多线访问共享变量引发的数据混乱。 虽然线程共享全局变量相对于进程通信会给线程通信带来巨大的方便，但是探究以下问题时发现不做控制的进行访问全局变量也是致命的，带来巨大程序bug，并且难以发现，首先请看一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;pthread.h&gt;#define MAX 10000int count &#x3D; 0;&#x2F;&#x2F;定义全局count并初始化为0&#x2F;&#x2F;函数线程Avoid* my_funa(void *arg)&#123; int i &#x3D; 0; for(;i &lt; MAX;++i) &#123; int cur &#x3D; count; cur++; count &#x3D; cur; printf(&quot;线程A:id &#x3D; %lu,count &#x3D; %d\\n&quot;,pthread_self(),count); usleep(10); &#125; return NULL;&#125;&#x2F;&#x2F;函数线程Bvoid* my_funb(void *arg)&#123; int i &#x3D; 0; for(;i &lt; MAX;++i) &#123; int cur &#x3D; count; cur++; count &#x3D; cur; printf(&quot;线程B:id &#x3D; %lu,count &#x3D; %d\\n&quot;,pthread_self(),count); usleep(10); &#125; return NULL;&#125;&#x2F;&#x2F;解释：定义全局变量count并初始化为0作为计数器&#x2F;&#x2F;在函数线程A和函数线程B分别进行10000次的++操作&#x2F;&#x2F;那么在两个线程执行完毕之后此时计数器count的值为20000&#x2F;&#x2F;usleep(10)，是为了模仿交替执行的过程，主动放弃cpu的执行权。int main()&#123; &#x2F;&#x2F;创建两个线程 pthread_t pthid1,pthid2; int res1 &#x3D; pthread_create(&amp;pthid1,NULL,my_funa,NULL); int res2 &#x3D; pthread_create(&amp;pthid2,NULL,my_funb,NULL); assert(0 &#x3D;&#x3D; res1); assert(0 &#x3D;&#x3D; res2); &#x2F;&#x2F;阻塞，回收函数线程资源 pthread_join(pthid1,NULL); pthread_join(pthid2,NULL); return 0;&#125; 使用gcc编译并执行：多次执行结果： 这里结果就令我感到非常疑惑，按照我们预期的结果。在两个线程中，都访问了全局变量并且同样进行了一万次的++操作，结果应该是20000。但是在这里我们看到多次执行结果每次的输出并不一致，存在结果为20000的情况，但是更多的是小于20000的情况。试想一下，这样的程序应用在实际的软件当中，必然会带来巨大的漏洞和危害，造成一定的经济损失。 下面就开始探索如何这样的问题是如何出现的？为什么执行同一个可执行程序不能得到相同的计算结果？该如何解决这样的问题？ 通过查阅相关的资料，得到了一下的信息。（1）时间片轮转技术（2）cur++的反汇编代码 时间片轮转技术什么是时间片轮转技术？在计算机发展的早期，CPU的价格昂贵，如果执行一个程序时但其输入输出需要的时间比较长，此时CPU就必须等到数据的到来才能进行运算。对于这样的时间浪费，在那个时期简直就是暴殄天物。聪明的计算机前辈很快就意识到这个问题，于是提出了监控CPU状态的程序。当发现CPU处于等待IO时，切换到等待获取CPU执行的程序，使得CPU被充分利用起来，这就是最早期的多道程序设计的思想。但是这样的调度策略显得太过粗糙，不分程序之间的优先级。随后就提出了分时系统的调度策略，即每个程序执行一小段时间之后将CPU的控制权交给其他就绪的程序。使得每个程序都有得到使用CPU执行的机会。这大概就是时间轮转技术的雏形吧。 现代计算机的时间片轮转技术是这样定义的：在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。 在这里为什么要提时间片轮转技术呢？针对我们上边的线程访问全局变量时，分配给单个线程执行时间是有限的，而且为了模仿交替执行的过程，程序中还使用了usleep(10)系统调用函数，主动交出CPU的控制权。但其实在拥有CPU控制权的那段时间内线程只能执行有限的指令条数，但这与输出结果不一致有什么关系呢？ 先看下边cur++的反汇编代码：可以看到++过程是在寄存器中进行的。到这里可以说问题已经解决了。试想下面一个过程。（1）时间片分给线程A执行代码，当cur在寄存中中累加到了100，此时恰巧时间片被用完了，而存放在寄存器中的中间变量还没来及写入实际的物理内存。 （2）时间片分配给线程B，由于线程A算出来的值并没有写回内存，所以实际上此时线程B还是取得 cur == 0 而进行的 ++ 操作，大概进行了 200次 的++ 操作，但这次时间片刚好够用，线程B将得到的 cur == 200 写回了实际的物理内存。 （3）时间片再度分配给线程A,线程A开始执行它在上一个时间片结束时没有执行完的工作，将 cur == 100 写入实际的物理内存,计算机严格按照代码执行指令，殊不知此时会将由线程B计算出来的 cur == 200 覆盖，这就是为什么在上面的图片当中，三次执行相同的代码，得到的结果完全不一致的原因。 当然这就牵扯到了线程安全以及线程同步的问题，在后边的文章中会提到，本人理解目前的能力也就只能理解到这里，希望大佬再次留下您的解答，感激不尽。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"求二进制数中一的个数的三种方法","slug":"求二进制数中一的个数的三种方法","date":"2018-04-14T14:27:10.000Z","updated":"2020-11-29T19:35:28.595Z","comments":true,"path":"2018/04/14/求二进制数中一的个数的三种方法/","link":"","permalink":"http://example.com/2018/04/14/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD%E4%B8%80%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"题目描述：编写一个函数，输入是一个无符号整数，返回的是它所有 位1 的个数（也被称为汉明重量）。 例如，32位整数 &#39;11&#39; 的二进制表示为 00000000000000000000000000001011，所以函数返回3。题目来源： leetcode 方法一：利用整数除法的特点，通过相处和判断余数的值进行分析。 12345678910111213int count(int a)&#123; int count &#x3D; 0; while(a) &#123; if(a % 2 &#x3D;&#x3D; 1) &#123; count++; &#125; a &#x2F;&#x3D; 2; &#125; return count;&#125; 方法二：使用位运算。位运算符当中的右移运算符每一次移动一位，其实与除以2是等价的。进行掩码运算，取当前二进制数的最后一位。 12345678910int count(int a)&#123; int count &#x3D; 0; while(a) &#123; count +&#x3D; a &amp; 0x00000001;&#x2F;&#x2F;获取当前二进制数的最后一位，为0或1。 a &gt;&gt;&#x3D; 1;&#x2F;&#x2F;相当于除以2 &#125; return count;&#125; 方法三： 有技巧的位与运算。举例:如二进制数 1001 0010 进行减一操作后 0110 1101 然后进行位与运算10010010 &amp; 01101101 = 0，证明原二进制数一个2的N次方值。 12345678910int count(int a)&#123; int count &#x3D; 0; while(a) &#123; a &amp;&#x3D; (a-1); count++; &#125; return count;&#125;","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"}],"tags":[]},{"title":"线程的概念及linux下线程库相关函数的使用","slug":"线程的概念及linux下线程库相关函数的使用","date":"2018-04-14T14:10:02.000Z","updated":"2020-11-29T19:35:28.635Z","comments":true,"path":"2018/04/14/线程的概念及linux下线程库相关函数的使用/","link":"","permalink":"http://example.com/2018/04/14/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8Alinux%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.线程的概念在linux操作系统下，线程的本质任然是进程。是轻量级的进程（light weight process）简称LWP，但线程与进程还是有很多的区别。 1.1为什么要引入线程，线程相对于进程优势在哪里？历史回顾：在20世纪90年代，由于多处理系统的迅速发展。提出了比进程更小且能够独立运行的单位——线程，以提高系统内程序并发执行的程度，改善操作系统的性能。 创建进程时，需要为其分配资源，并建立进程控制块pcb；撤销进程时，系统需要回收分配给进程的资源以及释放进程控制块，而当切换进程时，需要保护当前进程的上下文，并为切换的进程提供cpu执行环境。实际操作系统的开销比较大。 正是由于在进程切换时，操作系统的开销比较大。在操作系统中所设置的进程数量不能过多，否则在一定程度上降低了操作系统的并发程度。 引入线程的目的有二：(1).以较低的开销来提高操作系统的并发程度。(2).简化进程间通讯。 2.线程与进程的对比 2.1线程可在cpu上运行的基本执行单位。进程内的一个代码片段可以被创建为一个线程。线程状态：运行、就绪和等待。线程操作：创建、撤销、等待和唤醒等。进程依旧是资源分配的最小单位。线程自己不用有系统资源，通过进程申请资源。 2.2进程重型线程。只有一个主线程。单线程的模型。 对比图 2.3线程结构指令和数据来源于进程。各类资源来源于进程。相对于进程的进程控制块线程有线程控制块：包含栈空间、寄存器集、程序计数器和线程的ID。 3.线程的优点及缺点优点：1.提高程序的并发程度 2.系统开销小 3.数据共享，通信方便。缺点：1.库函数，不稳定 2.调试编写困难，gdb不支持调试。 3.对信号支持不好 4.linux线程库中相关函数的使用。 头文件：#include&lt;pthread.h&gt; 4.1创建线程函数原型： 1int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void* (*start_routine)(void *), void *arg)) 功能：创建一个线程。 返回值：成功创建返回值为0，错误返回错误号。注意：由于创建线程函数是一个库函数，不是系统调用函数。所以其错误信息不能用perror()进行打印，采用strerror(错误号)可以将错误信息打印出来。其中strerror函数是包含#include&lt;string.h&gt;之中的一个库函数。 参数：参数1：是一个传出参数，用于保存成功创建线程之后对应的线程id。参数2：表示线程的属性，通常默认传NULL，如果想使用具体的属性也可以修改具体的参数。参数3：函数指针，一个指向函数的指针。指向创建线程所执行函数的入口地址，函数执行完毕，则线程结束。参数4：线程主函数执行期间所使用的参数。下面举例使用以上函数： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;pthread.h&gt;#include&lt;sys&#x2F;types.h&gt;void* my_fun(void *arg)&#123; int i &#x3D; 0; for(;i &lt; 5;i++) &#123; printf(&quot;child pthread %d\\n&quot;,i); &#125; return NULL;&#125;int main()&#123; pthread_t pthid;&#x2F;&#x2F;传出参数，保存创建成功后的线程id int res &#x3D; pthread_create(&amp;pthid,NULL,my_fun,NULL); &#x2F;&#x2F;参数2默认为NULL，指的是线程的属性 &#x2F;&#x2F;函数指针，指向创建出线程的主函数 &#x2F;&#x2F;线程主函数的参数，就是void* my_fun(void *arg)中的void *arg if(res !&#x3D; 0) &#123; printf(&quot;%s\\n&quot;,strerror(res));&#x2F;&#x2F;打印错误信息 &#125; int i &#x3D; 0； for(;i&lt; 5;++i) &#123; printf(&quot;parent pthread %d\\n&quot;,i); &#125; &#x2F;&#x2F;由于程序执行的速度非常快，子线程还没来得及执行。进程已经结束 &#x2F;&#x2F;主线程睡眠两秒，使得子线程可以执行完毕 sleep(2); return 0;&#125; 4.2获取线程id函数原型： 1pthred_t pthread_self(void); 功能：获取当前线程的id。参数：无参。 返回值：返回值为一个无符号长整型。 1#define pthread_t unsigned long int 说明：线程id是在一个进程中的内部标识，但不同进程中的线程id可能相同。、举例： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;pthread.h&gt;void* fun(void *arg)&#123; printf(&quot;子线程id:%lu\\n&quot;,pthread_self()); return NULL;&#125;int main()&#123; pthread_t pthid; int res &#x3D; pthread_create(&amp;pthid,NULL,fun,NULL); if(res !&#x3D; 0) &#123; printf(&quot;%s\\n&quot;,strerror(res)); &#125; printf(&quot;主线程id:%lu\\n&quot;,pthread_self()); sleep(1); return 0;&#125; 注意：在使用gcc进行编译的时候需要加库名，否则会出先链接错误。因为线程库头文件仅仅包含了函数的声明，函数的实现在哪里编译器是不知道。如果不加库名，会出现如下的链接错误。 4.3单个线程退出 函数原型： void pthread_exit(void *retval)参数：retval表示线程的退出状态，通常穿NULL。当要求传出具体的退出状态时，可以使用retval。 当使用exit函数退出线程时，存在的问题是如果当前还有线程没有执行相应的任务，但是由于进程的退出，强制使得线程被迫退出。因为线程依赖与进程这是非常危险的退出方式，因此提出来了单线程的退出。不会影响到其他线程的撤销以及进程的撤销。 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;pthread.h&gt;void* fun(void *arg)&#123; int i &#x3D; 0; for(;i &lt; 3;++i) &#123; printf(&quot;child pthread i &#x3D; %d\\n&quot;,i); &#125; return NULL;&#125;int main()&#123; pthread_t pthid; int res &#x3D; pthread_create(&amp;pthid,NULL,fun,NULL); if(res !&#x3D; 0) &#123; printf(&quot;%s\\n&quot;,strerror(res)); &#125; int i &#x3D; 0; for(i &#x3D; 0;i &lt; 5;++i) &#123; printf(&quot;parent pthread i &#x3D; %d\\n&quot;,i); &#125; &#x2F;&#x2F;sleep(1);&#x2F;&#x2F;若不加sleep(1)时，由于主线程执行的太快。 &#x2F;&#x2F;子线程还没来得及执行，进程结束子线程被迫结束 pthread_exit(NULL);&#x2F;&#x2F;退出当前的线程，并没结束整个进程。 &#x2F;&#x2F;只有当进程中所有线程执行完毕后，进程才会结束 return 0;&#125; 没有添加单线程退出函数的结果：和我们预期的结果是一致的。 添加单线程退出函数的执行结果： 可见，单线程退出函数确实起到了作用。 4.4阻塞等待线程退出，回收线程的资源。函数原型：int pthread_join(pthread_t thread, void **retval) 参数： pthread为线程id，retval为线程的状态。可以与pthread_exit()结合使用。 调用该函数的线程将挂起等待，为阻塞的状态。直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：1.如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。2.如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。3.如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。4.如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。举例： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;pthread.h&gt;#include&lt;assert.h&gt;void* myfun(void *arg)&#123; printf(&quot;child pthread id &#x3D; %lu\\n&quot;,pthread_self()); char *str &#x3D; &quot;子线程的退出状态！\\n&quot; pthread_exit(str); return NULL;&#125;int main(void)&#123; pthread_t pthid; int res &#x3D; pthread_create(&amp;pthid,NULL,myfun,NULL); assert(res &#x3D;&#x3D; 0); char *str &#x3D; NULL; pthread_join(pthid,&amp;str); printf(&quot;parent pthread id &#x3D; %lu\\n&quot;,pthread_self()); printf(&quot;%s\\n&quot;,str); return 0；&#125; 执行的结果如下：主线程阻塞，等待子线程退出。获取子线程的退出状态并输出。 以上即线程的相关概念以及Linux系统下线程库相关重要的函数具体应用，大家也可以自行举例，验证函数。进一步的去理解线程的真正意义以及如何使用线程相关的开发。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"无头节点单链表的操作","slug":"无头节点单链表的操作","date":"2018-04-11T14:36:09.000Z","updated":"2020-11-29T19:35:28.655Z","comments":true,"path":"2018/04/11/无头节点单链表的操作/","link":"","permalink":"http://example.com/2018/04/11/%E6%97%A0%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;初始化单链表void InitList(LNode **head)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty&quot;); return; &#125; (*head) &#x3D; NULL;&#125;&#x2F;&#x2F;尾插法建立单链表void InsertListTail(LNode **head,int val)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; if(*head &#x3D;&#x3D; NULL) &#123; LNode *s &#x3D; (LNode*)malloc(sizeof(LNode)); if(s &#x3D;&#x3D; NULL) &#123; printf(&quot;apply fail!\\n&quot;); return; &#125; s-&gt;data &#x3D; val; s-&gt;next &#x3D; NULL; *head &#x3D; s; return; &#125; LNode *p &#x3D; *head; while(p-&gt;next !&#x3D; NULL) &#123; p &#x3D; p-&gt;next; &#125; LNode *s &#x3D; (LNode*)malloc(sizeof(LNode)); if(s &#x3D;&#x3D; NULL) &#123; printf(&quot;apply fail!\\n&quot;); return; &#125; s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s; s-&gt;data &#x3D; val;&#125;&#x2F;&#x2F;头插法建立单链表void InsertListHead(LNode **head,int val)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; LNode *p &#x3D; (LNode*)malloc(sizeof(LNode)); if(p &#x3D;&#x3D; NULL) &#123; printf(&quot;apply fail!\\n&quot;); return; &#125; p-&gt;data &#x3D; val; p-&gt;next &#x3D; (*head); (*head) &#x3D; p;&#125;&#x2F;&#x2F;显示单链表中的信息void ShowList(LNode **head)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; LNode *p &#x3D; (*head); while(p !&#x3D; NULL) &#123; printf(&quot;%d &quot;,p-&gt;data); p &#x3D; p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;&#x2F;&#x2F;销毁单链表void DestoryList(LNode **head)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; LNode *p; while(*head !&#x3D; NULL) &#123; p &#x3D; (*head)-&gt;next; free(*head); *head &#x3D; p; &#125;&#125;&#x2F;&#x2F;头删void DeleteListHead(LNode **head)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; if(*head &#x3D;&#x3D; NULL) &#123; printf(&quot;单链表中无结点，无法删除！\\n&quot;); return; &#125; LNode *p &#x3D; *head; LNode *q &#x3D; p-&gt;next; *head &#x3D; q; free(p);&#125;&#x2F;&#x2F;尾删void DeleteListTail(LNode **head)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; if(*head &#x3D;&#x3D; NULL) &#123; printf(&quot;单链表中无结点，无法删除！\\n&quot;); return; &#125; LNode *p &#x3D; *head; LNode *q &#x3D; p-&gt;next; while(q-&gt;next !&#x3D; NULL) &#123; p &#x3D; q; q &#x3D; q-&gt;next; &#125; p-&gt;next &#x3D; NULL; free(q);&#125;&#x2F;&#x2F;按位置删除void ListDeletePos(LNode **head,int pos)&#123; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty！\\n&quot;); return ; &#125; if(*head &#x3D;&#x3D; NULL) &#123; printf(&quot;单链表中无头节点，无法删除&quot;); return; &#125; if(pos &lt;&#x3D; 0) &#123; printf(&quot;删除位置不对!\\n&quot;); return; &#125; LNode *p &#x3D; *head; LNode *q &#x3D; p-&gt;next; while(--pos &amp;&amp; q-&gt;next !&#x3D; NULL) &#123; p &#x3D; q; q &#x3D; q-&gt;next; &#125; *head &#x3D; q; free(p);&#125;&#x2F;&#x2F;按位置插入数据void ListInsertPos(LNode **head,int val,int pos)&#123; LNode *s &#x3D; (LNode*)malloc(sizeof(LNode)); if(s &#x3D;&#x3D; NULL) &#123; printf(&quot;申请结点失败！\\n&quot;); return; &#125; s-&gt;data &#x3D; val; if(head &#x3D;&#x3D; NULL) &#123; printf(&quot;head is empty!\\n&quot;); return; &#125; if(pos &lt;&#x3D; 0) &#123; printf(&quot;插入位置不正确，不能进行插入！\\n&quot;); return; &#125; if(*head &#x3D;&#x3D; NULL) &#123; s-&gt;next &#x3D; *head; *head &#x3D; s; &#125; if(pos &#x3D;&#x3D; 1) &#123; LNode *c &#x3D; *head; *head &#x3D; s; s-&gt;next &#x3D; c-&gt;next; return; &#125; LNode *p &#x3D; *head; LNode *q &#x3D; p-&gt;next; while((pos-2) &gt; 0 &amp;&amp; q !&#x3D; NULL) &#123; p &#x3D; q; q &#x3D; q-&gt;next; --pos; &#125; if(q &#x3D;&#x3D; NULL) &#123; printf(&quot;插入位置不正确，不能进行插入！\\n&quot;); return; &#125; s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"测试机器大小端的两种方法","slug":"测试机器大小端的两种方法","date":"2018-04-11T10:01:04.000Z","updated":"2020-11-29T19:35:28.603Z","comments":true,"path":"2018/04/11/测试机器大小端的两种方法/","link":"","permalink":"http://example.com/2018/04/11/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"什么是机器的大小端。《深入理解计算机系统》给出的解释是:某些机器选择在存储器中按照最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节存储的顺序存储对象。前一种规则——最低有效字节在最前面的方式，称为小端法(little endian)。大多数Intel兼容机都采用这种小端模式的规则。后一种规则——最高有效字节在最前面的方式，称为大端法(big endian),大多数IBM和Sun Microsystems的机器都采用这种规则。 下面举例说明大端和小端。假设变量x的类型为int，位于地址0x100处，它的十六进制值为0x12345678。地址范围为0x100------0x103,其排序依赖于机器的类型。 一.利用共用体进行测定。 原理：由于共用体类型采取的是存储覆盖的机制，准许不同的类型数据相互覆盖，是一种同一存储区域由不同类型成员共享的数据类型。 共用体是多种数据的覆盖存储，几个不同的成员 变量共占同一段内存空间，而且都是从同一地址开始存储的，只是在任意时刻只存储一种数据，因此分配给共用体的存储区域大小至少要有存储最大一个成员数据类型所占用的存储空间。 利用上述特性，就可以进行机器大小端的测试。 12345typedef union un &#123; int a; char ch;&#x2F;&#x2F;注意：由于共用体不是同时存放多个成员的值，因此共用体变量不能进行初始化&#125;un; 1234567891011121314int main()&#123; un y; y.a &#x3D; 0x12345678;&#x2F;&#x2F;对共用体中整形变量a进行初始化 if(y.b &#x3D;&#x3D; 0x78)&#x2F;&#x2F;有共用体的机制决定 &#123; printf(&quot;小端模式！\\n&quot;); &#125; else &#123; printf(&quot;大端模式!\\n&quot;); &#125; return 0;&#125; 二.利用强转指针实现虽然在32位操作系统下，所有指针类型的大小均为4字节。但是不同类型的指针进行解引用的能力是不相同的，利用这个特性，进行机器大小端的测试。 12345678910111213141516#include&lt;stdio.o&gt;int main()&#123; int a &#x3D; 0x12345678;&#x2F;&#x2F;十六进制值为0x12345678 char *p &#x3D; (char*)&amp;a;&#x2F;&#x2F;强转地址，使得指针p仅可以解引用到一个字节大小的值 if(*p &#x3D;&#x3D; 0x78) &#123; printf(&quot;小端模式！\\n&quot;); &#125; else &#123; printf(&quot;大端模式！\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"无限递归引发的堆栈溢出","slug":"无限递归引发的堆栈溢出","date":"2018-04-10T12:50:58.000Z","updated":"2020-11-29T19:35:28.611Z","comments":true,"path":"2018/04/10/无限递归引发的堆栈溢出/","link":"","permalink":"http://example.com/2018/04/10/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E5%BC%95%E5%8F%91%E7%9A%84%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"今天在写strlen函数的递归实现，当执行以下代码时，会出现段错误。 1234567891011121314#include&lt;assert.h&gt;size_t my_strlen(char *str)&#123; assert(str !&#x3D; NULL); if(*str &#x3D;&#x3D; &#39;\\0&#39;) &#123; return 0; &#125; else &#123; return 1 + my_strlen(p++); &#125;&#125; 使用gdb进行调试后，定位到错误。当程序执行 return 1 + my_strlen（p++）这条语句时，会出现以下的段错误情况。程序被SIGSEGV信号终结，并报出段错误.分析 return 1 + my_strlen（p++）,当程序进行递归调用的时候。由于传参为p++即传入p，相当于递归本身，并非移到指向当前字符串下一个字符的位置。递归函数会陷入无限递归的状态，因为没有递归结束的条件。当操作系统为进程分配的虚拟地址空间当中的栈空间被耗尽时，此时会发生堆栈溢出。因而产生段错误。将上述代码尽心更改： 1234567891011121314#include&lt;assert.h&gt;size_t my_strlen(char *str)&#123; assert(str !&#x3D; NULL); if(*str &#x3D;&#x3D; &#39;\\0&#39;) &#123; return 0; &#125; else &#123; return 1 + my_strlen(++p); &#125;&#125; 注意：将return 1+my_strlen(p++)改为return 1+my_strlen(++p)。 在linux操作系统下查看栈空间的大小: ulimit -a可以查看所有默认空间的大小。 查看栈空间的默认大小 ： 命令 ulimit -s可以看到，在我的操作系统下栈空间的默认大小为10MB。 递归的开销实际上是比较大的，在使用时谨防堆栈溢出。注意递归调用结束的条件。","categories":[],"tags":[]},{"title":"strlen字符串长度的递归实现","slug":"strlen字符串长度的递归实现","date":"2018-04-10T12:27:34.000Z","updated":"2020-11-29T19:35:28.591Z","comments":true,"path":"2018/04/10/strlen字符串长度的递归实现/","link":"","permalink":"http://example.com/2018/04/10/strlen%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"函数原型 12typedef unsigned int size_t;size_t strlen( const char *string ) 返回值返回值类型为无符号整型，大小字符串的长度除串尾标志符NULL。 递归实现函数用非递归的方法实现strlen函数，会用到一个中间变量计数器count。当要求不能使用中间变量进行函数实现时，就要采用递归的方法实现。 1234567891011121314#include&lt;assert.h&gt;size_t my_strlen(char *str)&#123; assert(str !&#x3D; NULL); if(*str &#x3D;&#x3D; &#39;\\0&#39;) &#123; return 0; &#125; else &#123; return 1 + my_strlen(++p); &#125;&#125;","categories":[],"tags":[]},{"title":"二维数组的地址（行地址，具体元素地址）","slug":"二维数组的地址（行地址，具体元素地址）","date":"2018-04-07T08:57:03.000Z","updated":"2020-11-29T19:35:28.603Z","comments":true,"path":"2018/04/07/二维数组的地址（行地址，具体元素地址）/","link":"","permalink":"http://example.com/2018/04/07/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%88%E8%A1%8C%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0%E5%9C%B0%E5%9D%80%EF%BC%89/","excerpt":"","text":"1234int a[][4] &#x3D; &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;&#x2F;&#x2F;a：代表第零行的地址&#x2F;&#x2F;如何验证呢？验证其步长printf(&quot;a : %d,a+1: %d&quot;,a,a+1); 数组名加1后得到是比原地址大16，刚好是一行的地址和。可见二维数组名代表第零行的地址。二维数组中第i行的地址 123&#x2F;&#x2F;第i行的地址，有两种等价的表达形式a[i];a+i; 由上图可见，在一个二维数组中。第零行的地址有三种表达形式。（1）a（2）a[0]（3）a+0 二维数组某行首元素的地址 12*(a+i); &#x2F;&#x2F;第i行首元素的地址&amp;a[0]+1 二维数组中某元素的地址 12*(a+i)+j; &#x2F;&#x2F;二维数组中第i行第j列元素的地址&amp;a[0][0]+1 通过指针解引用二维数组中的元素 1*(*(a+i)+j) &#x3D; 10;&#x2F;&#x2F;向二维数组a中的第i行第j列元素赋值为10","categories":[],"tags":[]},{"title":"冒泡排序和简单选择排序的算法实现及优化","slug":"冒泡排序和简单选择排序的算法实现及优化","date":"2018-04-07T08:30:49.000Z","updated":"2020-11-29T19:35:28.635Z","comments":true,"path":"2018/04/07/冒泡排序和简单选择排序的算法实现及优化/","link":"","permalink":"http://example.com/2018/04/07/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"","text":"一.在排序算法中使用到的结构与函数 123456789101112int arr[] &#x3D; &#123;50,60,90,10,30,40,20,70,80&#125;;int len &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]);&#x2F;&#x2F;由于数组作为形参会退化为指针，所以在函数中计算不出数组的长度。&#x2F;&#x2F;因此数组的长度应在主函数中求出，并传入到函数当中以便使用。函数void swap(int *arr,int i,int j)&#123; int temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;&#125; 二.冒泡排序 冒泡排序作为最基础的排序算法，其核心就是通过两两相邻的同类型数据进行比较，进行交换。一组数据经过一次比较之后，就可以最大或最小的元素放在尾部，现实生活中很形象的例子就是冒泡，其名称也因此而来。下面实现冒泡排序算法： 12345678910111213void BubbleSort(int *arr,int len)&#123; for(int i &#x3D; 0;i &lt; len - 1;++i) &#123; for(int j &#x3D; 0;j &lt; len - 1 -i;++j) &#123; if(arr[j] &gt; arr[j+1]) &#123; swap(arr,j,j+1); &#125; &#125; &#125;&#125; 上述的算法虽然可以成功的解决一组数据排列的问题，但是涉及到一个具体的算法时，我们就必须从两方面考虑其性能及空间复杂度和时间复杂度。 由于计算机硬件发展迅速，硬件价格也随之迅速降低。在实际使用算法时，往往通过牺牲空间复杂度来获取较低的时间复杂度，这样的做法其实也是合理的。 针对时间复杂度，对冒泡排序算法进行优化。 123456789101112int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;;&#x2F;&#x2F;要求对arr数组中的数字进行升序排序，可以发现，进过一趟比较。数组中的数字顺序已完成排序&#x2F;&#x2F;但是在算法中还依此进行了七趟没有必要的比较第一趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第二趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第三趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第四趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第五趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第六趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第七趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;; 第八趟 int arr[] &#x3D; &#123;11,22,33,44,55,66,77,88,99&#125;;&#x2F;&#x2F;可见，这样的算法在时间复杂度上的浪费非常大 当然上述的例子，是非常极端的。但是在实际的排序问题中也不乏数据几个或多个相邻的数据已经有序，因此针对已经有序的序列，就不需要进行排序。减少浪费不必要的时间。 优化后的冒泡排序 1234567891011121314151617181920void BubbleSort(int *arr,int len)&#123; bool flag;&#x2F;&#x2F;设置标识位，用于判断相邻两数据之间是否有序 for(int i &#x3D; 0;i &lt; len - 1;++i) &#123; flag &#x3D; true;&#x2F;&#x2F;flag设置为flase,假设已经有序 for(int j &#x3D; 0;j &lt; len - 1 - i;++j) &#123; if(arr[j] &gt; arr[j+1]) &#123; flag &#x3D; false;&#x2F;&#x2F;进入此分支，证明无序 swap(arr,j,j+1); &#125; &#125; if(flag &#x3D;&#x3D; true) &#123; break;&#x2F;&#x2F;证明此时数组中数据已经完成排序 &#125; &#125;&#125; 三.简单选择排序思路：简单选择排序算法就是通过n-i次关键字间比较，从n-1-i个记录中选择出关键字最小的的，并和第i个（0≤i≤n-i）个记录进行交换。简单选择排序算法的实现 12345678910111213void SelectSort(int *arr,int len)&#123; for(int i &#x3D; 0;i &lt; len;++i) &#123; for(j &#x3D; i+1;j &lt; len;++j) &#123; if(arr[i] &gt; arr[j]) &#123; swap(arr,i,j); &#125; &#125; &#125;&#125; 但实际上上述已经实现的简单选择排序也不满足算法在时间复杂度上的要求，其实优化的目的与冒泡排序相同，都是避免出现在已经有序的序列中进行排序，所以其优化的思路与冒泡排序的优化方式一致。优化的简单排序算法 1234567891011121314151617181920void SelectSort(int *arr,int len)&#123; bool flag; for(int i &#x3D; 0;i &lt; len;++i) &#123; flag &#x3D; true; for(int j &#x3D; 0;j &lt; len;++j) &#123; if(arr[i] &lt; arr[j]) &#123; flag &#x3D; true; swap(arr,i,j); &#125; &#125; if(flag &#x3D;&#x3D; true) &#123; break; &#125; &#125;&#125; 上述的标志位法还可以用到许多的实际例子中，如求素数个数问题等。","categories":[],"tags":[]},{"title":"const修饰符的使用（修饰结构体指针，引用外部的const 变量）","slug":"const修饰符的使用（修饰结构体指针，引用外部的const 变量）","date":"2018-04-05T07:55:32.000Z","updated":"2020-11-29T19:35:28.903Z","comments":true,"path":"2018/04/05/const修饰符的使用（修饰结构体指针，引用外部的const 变量）/","link":"","permalink":"http://example.com/2018/04/05/const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BF%AE%E9%A5%B0%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%EF%BC%8C%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E7%9A%84const%20%E5%8F%98%E9%87%8F%EF%BC%89/","excerpt":"","text":"const修饰符的使用 1234567891011&#x2F;&#x2F;const修饰变量为只读const int a &#x3D; 10;a &#x3D; 20;&#x2F;&#x2F;是错误的赋值&#x2F;&#x2F;指针变量 指针指向的内存 两个不同的概念char buf[] &#x3D; &quot;helloworld&quot;;&#x2F;&#x2F;从左往右看，跳过类型，看修饰那个字符&#x2F;&#x2F;如果是*,说明指针指向的内存不能改变&#x2F;&#x2F;如果是指针变量，说明指针的指向不能改变，指针的值不能修改const char *p &#x3D; buf;char const *p1 &#x3D; buf;&#x2F;&#x2F;以上两条语句是等价的，都是修饰指针指向的内存不能改变。是对指针指向的内存空间的内容进行封锁。 1234567891011const封锁的是指针变量，不能修改其指向，但是可以修改指针指向内存当中的内容。char* const p2 &#x3D; buf;p2[1] &#x3D; &#39;3&#39;;&#x2F;&#x2F;可以进行赋值p2 &#x3D; &quot;hello&quot;;是错误的const char * const p2 &#x3D; buf;&#x2F;&#x2F;进行双重封锁，即既不能修改指针的指向，也不能修改指针指向内存当中的内容。 const修饰结构体指针 123456789101112131415161718192021222324252627282930&#x2F;&#x2F;对结构体进行封锁typedef struct &#123; int a; int b;&#125;my_struct;void fun1(my_struct *p)&#123; &#x2F;&#x2F;结构体指针可以修改 &#x2F;&#x2F;结构体指针指向的内存也可以改变 &#125;void fun2(my_struct const *p)&#123; &#x2F;&#x2F;结构体指针可以修改 &#x2F;&#x2F;如 p &#x3D; NULL; 是可以修改的 &#x2F;&#x2F;结构体指针指向的内容不能修改 &#x2F;&#x2F;p-&gt;a &#x3D; 10 是错误的&#125;void fun3(my_struct * const p)&#123; &#x2F;&#x2F;结构体指针的指向不可以修改 p &#x3D; NULL是错误的 &#x2F;&#x2F;结构体指针指向的内容可以修改 p-&gt;a &#x3D; 10是可以修改的&#125;void fun4(const my_struct * const p)&#123; &#x2F;&#x2F;结构体指针的指向不可以修改 &#x2F;&#x2F;结构体指针指向内存当中的内容也不可以修改&#125; 如何引用其他.c文件中的const变量 12extern const int a;&#x2F;&#x2F;注意，不能再进行赋值，只能声明printf(&quot;a &#x3D; %d\\n&quot;,a);","categories":[],"tags":[]},{"title":"strcmp函数的分析及实现","slug":"strcmp函数的分析及实现","date":"2018-04-04T11:40:59.000Z","updated":"2020-11-29T19:35:28.875Z","comments":true,"path":"2018/04/04/strcmp函数的分析及实现/","link":"","permalink":"http://example.com/2018/04/04/strcmp%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"函数原型： int strcmp(const char *string1,const char *string2) 所在库文件： #include&lt;string.h&gt; 参数： 以null结尾的字符串 const修饰防止字符串被修改，进行保护。 返回值：上图在MSDN文档中截取，返回值表明了字符串1和字符串2的字典序关系。什么是字典序关系呢？ 度娘的回答是 在数学中，字典或词典顺序（也称为词汇顺序，字典顺序，字母顺序或词典顺序）是基于字母顺序排列的单词按字母顺序排列的方法。 这种泛化主要在于定义有序完全有序集合（通常称为字母表）的元素的序列（通常称为计算机科学中的单词）的总顺序。 其实讲了这么多，我们只需要明白，这里的字典序是一种按顺序排列的法则，但它排列的根据是什么呢？其根据是ascii码表。 这时就应该联想到在计算机科学中ASCII码表，strcmp函数的返回值是两个字符串的字典序关系，其实也就是在ascii表中的先后排列关系。所以strcmp函数真正比较的是字符串中每个字符的ascii码值大小。 在上图中，请一定注意。返回值的三种情况分别为 0 &gt;0 &lt;0。并没说其返回值为 0 -1 1，所以我们在使用的时候千万不能将返回值与-1或1进行比较的。如果进行了比较，很有可能给程序带来许多潜藏的bug，难以发现。 ASCII表 函数功能描述当s1 &lt; s2时，返回负值。当s1 &gt; s2时，返回正值。当s1 == s2，返回0。两个字符串的每个字符从左到右依此按照对应的ascii码值大小进行比较，若两字符对应的ascii码值相等，继续比较直到出现不同的字符或者遇到串尾标志符&#39;\\0&#39;为止。 下面实现strcmp函数： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;assert.h&gt;int my_strcmp(const char *string1,const char *string2)&#123; assert(NULL !&#x3D; string1); assert(NULL !&#x3D; string2);&#x2F;&#x2F;防御性编程 const char *p &#x3D; string1; const char *q &#x3D; string2; while(*p &#x3D;&#x3D; *q) &#123; if(*p &#x3D;&#x3D; &#39;\\0&#39;)&#x2F;&#x2F;此时*p &#x3D;&#x3D; *q &#x3D;&#x3D; &#39;\\0&#39;即两字符串完全相同 &#123; return 0; &#125; p++; q++; &#125; &#x2F;&#x2F;跳出while循环，即此时的*p与*q不相同 &#x2F;&#x2F;按照返回值 *string1 &gt; *string2 返回值大于0 &#x2F;&#x2F; *string1 &lt; *string2 返回值小于0 &#x2F;&#x2F;ascii码值共有256个 无符号字符型指针进行解引用 0 - 2^8-1 共256 return *(unsigned char*)p - *(unsigned char*)q; &#125; 测试用例：char *p1 = “ABCDE”;char *p2 = “ABCDE”; char *p1 = “ABCDE”;char *p2 = “ABCD”; char *p1 = “ABCD”;char *p2 = “ABCDE”; char *p = “hhha”;char *q = “hhhh”; char string1[] = “The quick brown dog jumps over the lazy fox”;char string2[] = “The QUICK brown dog jumps over the lazy fox”; 更多的测试用例大家可以进行规定，观察结果与预期的结果是否相同。","categories":[],"tags":[]},{"title":"使用vi/vim搜索关键字后删除关键字高亮","slug":"使用vi!vim搜索关键字后删除关键字高亮","date":"2018-04-04T09:11:26.000Z","updated":"2020-11-29T19:35:28.899Z","comments":true,"path":"2018/04/04/使用vi!vim搜索关键字后删除关键字高亮/","link":"","permalink":"http://example.com/2018/04/04/%E4%BD%BF%E7%94%A8vi!vim%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8E%E5%88%A0%E9%99%A4%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/","excerpt":"","text":"在使用vim编辑器的时候，如果我们进行了关键字搜索之后。就会出现关键字高亮的状态，并且一直保持高亮的状态。对于一些患有强迫症的朋(jiu)友(shi)们（wo）会感到不舒服。 1&#x2F;&#x2F;当进行include关键字搜索之后，就会出现关键字高亮的状态 1&#x2F;&#x2F;本着解决问题的态度，如何根治删除搜索关键字的高亮状态呢？ 1&#x2F;&#x2F;经查证，高亮(highlight) 所以只要只要在末行模式中输入 noh 即可删除关键字高亮的状态。注意：末行模式，在vim编辑器中狂按esc键，输入：即可，然后输入删除高亮的命令noh，此时关键字高亮状态被取消。","categories":[],"tags":[]},{"title":"linux目录或文件颜色","slug":"Linux目录或文件颜色","date":"2018-04-04T07:53:06.000Z","updated":"2020-11-29T19:46:31.887Z","comments":true,"path":"2018/04/04/Linux目录或文件颜色/","link":"","permalink":"http://example.com/2018/04/04/Linux%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E9%A2%9C%E8%89%B2/","excerpt":"","text":"熟记Linux操作系统文件颜色有助于迅速理解操作，不会错误使用不同类型的文件或目录。","categories":[],"tags":[]},{"title":"expected `=`,`,`,`;`,`asm` or `attribute`before","slug":"expected `=`,`,`,`;`,`asm` or `attribute`before","date":"2018-04-02T14:44:03.000Z","updated":"2020-11-29T19:35:28.903Z","comments":true,"path":"2018/04/02/expected `=`,`,`,`;`,`asm` or `attribute`before/","link":"","permalink":"http://example.com/2018/04/02/expected%20%60=%60,%60,%60,%60;%60,%60asm%60%20or%20%60attribute%60before/","excerpt":"","text":"今天在使用gcc进行多文件编译时，始终会出现如下的错误。百思不得其解，程序里的代码似乎没有什么问题。 仔细查证后发现还是有很大的问题，原因是C语言中并没有bool类型，因此在使用bool类型时，一定要留心： 123#define bool int #define false 0#define true 1 使用以上的宏定义才可大胆防守使用bool类型。","categories":[],"tags":[]},{"title":"进程通信（一）无名管道和有名管道","slug":"进程通信（一）无名管道和有名管道","date":"2018-04-02T07:36:22.000Z","updated":"2020-11-29T19:35:28.911Z","comments":true,"path":"2018/04/02/进程通信（一）无名管道和有名管道/","link":"","permalink":"http://example.com/2018/04/02/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/","excerpt":"","text":"进程通信 ：进程通信是指进程之间的信息交换。 《王道考研复习指导》 管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流的形式将大量的数据送入（写）管道；而接受管道输出的接受进程（即读进程），则从管道接受（读）数据。为了协调双方的通信，管道机制必须提供一下三个方面的协调能力：互斥、同步和确定对方存在。 下面以linux的管道为例进行说明。在linux中，管道是一种频繁使用的通信机制。从本质上讲，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件通信的两个问题，具体表现为： 1）限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为4KB，使得它不像文件那样不加检验的增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对写管道的write()调用将默认的阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。 2)读进程也可能工作的比写进程快。当所有当前进程数据已被读走时，管道变空。当这种情况发生时，一个随后的read()调用将默认设置为阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。 注意 ：从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用半双工通信，即在某一时刻只能单向传输。要实现父子进程双方互动，需要定义两个管道。 在LINUX操作下使用 ulimit -p命令可以查看默认管道的大小。 1.无名管道（匿名管道） 函数原型： int pipe(int pipefd[2]) 参数: 文件描述符数组，其中fd[0]代表读端，fd[1]代表写端。即管道的两端，注意fd是传出参数。当程序中调用pipe函数，操作系统会创建内核缓冲区，fd作为传出参数，这样才 可以对内核缓冲区进行操控。 返回值: 如果匿名缓冲区被成功创建，返回值为0；否则，返回-1，errno全局变量被设置为相应的错误。 适用范围: 有血缘关系的进程间通信,如父子进程，兄弟进程。 下面举例分析如何使用无名管道在父子进程间进行通信： 前面已经讲过，由于管道是半双工通信，即在某一时=时刻只能单向传输。 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;assert.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;int main()&#123; int fd[2]; &#x2F;&#x2F;创建文件描述符数组，fd[0]对应管道读端，fd[1]对应管道写端 int res &#x3D; pipe(fd);&#x2F;&#x2F;fd作为传出参数，以便对内核缓冲区进行操作 aasert(-1 !&#x3D; res); pid_t pid &#x3D; fork();&#x2F;&#x2F;创建子进程 if(-1 &#x3D;&#x3D; pid) &#123; perror(&quot;fork()&quot;); exit(0); &#125; &#x2F;&#x2F;子进程 if(pid &#x3D;&#x3D; 0) &#123; close(fd[0]);&#x2F;&#x2F;关闭读端 write(fd[1],&quot;hello&quot;,5);&#x2F;&#x2F;向内核缓冲区写入字符串hello &#125; else &#123; close(fd[1]);&#x2F;&#x2F;关闭写端 char buf[128] &#x3D; &#123;0&#125;; read(fd[0],buf,sizeof(buf));&#x2F;&#x2F;将内核缓冲区的内容写入buf中 printf(&quot;%s \\n&quot;,buf);&#x2F;&#x2F;将写入buf中的内容输出到屏幕上 &#125;&#125; 123gcc pipe.c -o pipe.&#x2F;pipehello 可以看出，使用匿名管道完成了父子进程的通信，子进程作为写进程输入信息hello，父进程作为读进程读取信息并输出到屏幕上。 2.有名管道 由于无名管道的局限性，仅限于有血缘关系的进程间通信，所以当需要在不同进程（无血缘关系的进程）之间通信，pipe就不能被使用了。取而代之是有名管道（fifo）。特点：（1）在磁盘上有这样一个文件，使用ls -l命令可以查看管道文件的文件类型为p。（2）伪文件，其大小永远为0。（3）在内核中有一个对应的缓冲区。（4）半双工的通信方式 使用场景（1）没有血缘关系的进程间通信 创建方式（1）mkfifo 管道名（2）调用函数 mkfifo 函数原型： int mkfifo(const char *pathname,mode_t mode); 参数：路径 权限 下面举例应用mkfifo实现两个无血缘关系进程之间的通信简单描述：在A进程中向内核缓冲区输入字符串，输入end表示结束进程。在B进程中将内核缓冲区的内容保存在命令行参数argv[1]指定的文件中。进程A : fifoa.c 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;assert.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;int main()&#123; int fd &#x3D; open(&quot;FIFO&quot;,O_WRONLY);&#x2F;&#x2F;默认是阻塞的 if(fd &#x3D;&#x3D; -1) &#123; int n &#x3D; mkfifo(&quot;FIFO&quot;,0664);&#x2F;&#x2F;创建管道文件FIFO if(-1 &#x3D;&#x3D; n) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; fd &#x3D; open(&quot;FIFO&quot;,O_WRONLY); &#125; assert(-1 !&#x3D; fd); printf(&quot;open success!\\n&quot;); while(1) &#123; printf(&quot;please input:&quot;); char buf[128] &#x3D; &#123;0&#125;; fgets(buf,128,stdin); if(strncmp(buf,&quot;end&quot;,3) &#x3D;&#x3D; 0)&#x2F;&#x2F;输入end用以结束进程 &#123; break; &#125; write(fd,buf,strlen(buf) - 1);&#x2F;&#x2F;strlen(buf)-1减去回车符占用的一个字节长度，否则输出到屏幕上的值为乱码 &#125; close(fd);&#125; 进程B fifob.c 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;assert.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;int main(int argc,char *argv[])&#123; int fd &#x3D; open(&quot;FIFO&quot;,O_RDONLY);&#x2F;&#x2F;浼氶樆濉炶繍琛? if(fd &lt; 0) &#123; int n &#x3D; mkfifo(&quot;FIFO&quot;,0664); if(-1 &#x3D;&#x3D; n) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; fd &#x3D; open(&quot;FIFO&quot;,O_RDONLY); assert(-1 !&#x3D; fd); &#125; int fd1 &#x3D; open(argv[1],O_WRONLY | O_CREAT,0664); assert(fd1 !&#x3D; -1); while(1) &#123; char buf[128] &#x3D; &#123;0&#125;; int n &#x3D; read(fd,buf,127); if(0 &#x3D;&#x3D; n) &#123; break; &#125; write(fd1,buf,n); &#125; close(fd); close(fd1);&#125; 1234gcc fifoa.c -o fifoagcc fifob.c -o fifob.&#x2F;fifoa.&#x2F;fifob a.txt A,B进程必须同时执行，否则被执行的进程会出现阻塞。且看管道机制中的一条，必须确认对方的从在，否则就会阻塞，等待对方的到来。 在A进程中输入字符串：查看由B进程保存的a.txt文件： 正式我们刚刚在A进程中输入的字符串。","categories":[],"tags":[]},{"title":"预处理、编译和汇编这些步骤程序发生的变化","slug":"预处理、编译和汇编这些步骤程序发生的变化","date":"2018-03-31T14:00:31.000Z","updated":"2020-11-29T19:35:28.887Z","comments":true,"path":"2018/03/31/预处理、编译和汇编这些步骤程序发生的变化/","link":"","permalink":"http://example.com/2018/03/31/%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%B1%87%E7%BC%96%E8%BF%99%E4%BA%9B%E6%AD%A5%E9%AA%A4%E7%A8%8B%E5%BA%8F%E5%8F%91%E7%94%9F%E7%9A%84%E5%8F%98%E5%8C%96/","excerpt":"","text":"现在大多数的程序都是在IDE上进行开发的，预处理、编译、汇编和链接这些过程都有编译器已经设定完成，而实际程序在这个过程发生了什么，我们就无从得知了。但是作为程序员，我们有必要去了解在这个过程中我们的程序都发生了哪些变化。下面就详细描述每一个步骤发生了什么。参考《程序员的自我修养》预处理1.将所有的#define删除，宏定义进行替换。2.处理所有条件预编译指令，比如#ifndef ,#define,#if,#elif等。3.删除所有注释，包括单行注释 // 和 多行注释 /**/。4.添加行号和文件名标识。5.保留#program 编译器指令。6.展开头文件 下面验证上述提到的预处理阶段做的事情。 123456789101112131415#include&lt;stdio.h&gt;#define PI 3.14 &#x2F;&#x2F;宏定义#if 1 int main()&#123; &#x2F;&#x2F;单行注释 float a &#x3D; PI; printf(&quot;helloworld\\n&quot;); printf(&quot;a &#x3D; %f\\n&quot;,a); &#x2F;*这里用来测试多行注释 这里用来测试多行注释 这里用来测试多行注释 *&#x2F;&#125;#endif 这是我们main.c源文件，在Linux操作系统下，使用gcc可以获取.i文件，即经过预处理得到的文件。 1gcc main.c -E -o main.i 可以看到，此时的main.i文件相对main.c大了许多，这是因为预处理阶段展开了头文件，大量的库函数的声明即路径被写入到main.i文件中，由于main.i的内容过于庞大，在这里就不贴出来了，大家可以自行验证。我们重点关注一下，宏定义是否被替换、注释是否被删除、以及条件编译指令是否被删除。对照我们上边写出程序，可以看出。宏定义被替换、单行注释和多行注释均被删除、条件编译指令被删除、添加了行号和文件名。其实头文件#include&lt;stdio.h&gt;内容也进行了递归展开，但是由于太多，在这里不进行一一展示，大家可以自行验证。 编译编译过程其实就是把预处理得到的文件进行词法分析、语法分析、语义分析及优化后生成的相应的汇编文件。是整个程序构建过程中最核心的部分，最重要的部分。 1gcc main.i -S -o main.s 由main.i 生成的main.s文件，其内容是main.i程序的对应汇编程序。 汇编汇编器是将汇编代码转换成机器可以识别的二进制代码，每一条汇编语言几乎对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比价简单，它没有复杂的语法，也没有语义，也不需要做指令的优化，只是需要根据汇编指令和机器指令的对照表一一翻译就可以了，”汇编”这个名词也来源于此。 1gcc main.s -c -o main.o 最终生成main.o二进制文件，其内容是01序列，当然我们是看不懂的。但是机器能够理解。","categories":[],"tags":[]},{"title":"虚拟地址空间的内存布局","slug":"虚拟地址空间的内存布局","date":"2018-03-31T08:31:30.000Z","updated":"2020-11-29T19:35:28.895Z","comments":true,"path":"2018/03/31/虚拟地址空间的内存布局/","link":"","permalink":"http://example.com/2018/03/31/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","excerpt":"","text":"实际的物理内存程序员是不能直接管理的，在最早期的x86体系结构中。由于实模式，对内存不进行保护，致使病毒蠕虫横飞。出现保护模式以后，提供虚拟地址空间对实际物理内存抽象虚拟，形成一一映射的关系。","categories":[],"tags":[]},{"title":"memcpy函数的实现及内存重叠问题的分析","slug":"memcpy函数的实现及内存重叠问题的分析","date":"2018-03-29T13:00:19.000Z","updated":"2020-11-29T19:35:28.955Z","comments":true,"path":"2018/03/29/memcpy函数的实现及内存重叠问题的分析/","link":"","permalink":"http://example.com/2018/03/29/memcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%86%85%E5%AD%98%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"","text":"函数原型void *memcpy(char *dest,const char *src,size_t n) 头文件#include&lt;string.h&gt;或#include&lt;memory.h&gt;参数1.memcpy中的三个参数分别为目标字符串 char *dest。 2.源字符串 const char *src const 这里const是对src所指向的静态常量区的字符串常量进行修饰，保护源字符串在内存拷贝的过程不被修改。 3.需要拷贝的字节个数 size_t ntypedef unsigned int szie_t 这里的size_t其实就是为无符号整型unsigned int进行别名，因为在内存拷贝函数中，一方面拷贝的字节数不可能是负整数，另一方面字节数不可能是实数，出于上面两个方面的考虑字节数的类型应定义为size_t. 返回值memcpy returns the value of dest. 返回目标字符串的地址 函数描述The memcpy function copies count bytes of src to dest. If the source and destination overlap, this function does not ensure that the original source bytes in the overlapping region are copied before being overwritten. Use memmove to handle overlapping regions.memcpy函数将src的字节数复制到dest。如果源和目标重叠，这个函数不能确保重叠区域的原始源字节在被覆盖之前被复制。这里已经提到了内存覆盖的问题，而在C语言却并没有对这种现象做相关的规定或检查，也就是说对于这种现象C语言是缺省。后边会详细分析如何处理在字符串拷贝函数中内存重叠的问题。 内存重叠注意：在这里的内存重叠我们只考虑为了成功实现内存拷贝要排除的内存重叠的情况。当然也可能出现目标字符串覆盖源字符串的情况，但如果其满足成功拷贝的条件即可。 可以把src、dest、src+n比作数轴上的三个数字，当进行内存拷贝是。如果dest处于src和src+n之间时，一定会出现内存覆盖的现象，而且还会改变源字符串的内容，进行错误的拷贝。因此为了能够合理进行拷贝，提出如下的解决方案。一. 高地址向低地址进行拷贝由于在虚拟地址空间中，栈空间的生长方向是高地址向低地址生长，首先采用这种方式。简略的讲就是源字符串中的字符从前往后向目标字符串按给定字节的大小依此进行拷贝。观察上图，可以得到两个合理的区间即不会出现内存覆盖的区间。(1)dest&lt;=src 第一种情况dest=src,此时源字符串与目标字符串指针指向同一个位置，拷贝的过程相当自己给自己赋值，因此拷贝结束 后源字符串并没有发生变化。 第二种情况dest &lt; src,这样的拷贝尽管会覆盖src的内容，出现了内存重叠，但其可以完成内存拷贝的功能，并没有将错误的信息拷贝过来。 (2)dest&gt;=src+n由上图可见，当dest&gt;=src+n，无论如何都不会出现内存重叠的问题。 二. 低地址向高地址拷贝这种拷贝方式是为了处理，dest处于src和src+n之间，即一定会出现内存重叠的问题。为了避免出现这种情况，我们可以将src和dest都移动 n-1个位置，这样我们就可以从地址值向高地址进行拷贝，这样尽管也有可能目标字符串覆盖源字符串的情况，但是定影可以得到一个正确的拷贝。大家可以自行进行验证！ memcpy函数的实现 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include &lt;stddef.h&gt;void *my_memcpy(char *dest,const char *src,size_t n)&#123; assert(NULL !&#x3D; dest); assert(NULL !&#x3D; src); char *res &#x3D; (char*)dest; char *p &#x3D; (char*)dest; const char *q &#x3D; (const char*)src; if(p &lt;&#x3D; q || p &gt;&#x3D; q+n) &#123; while(n--) &#123; *p++ &#x3D; *q++; &#125; &#125; else &#123; p &#x3D; p+n-1; q &#x3D; q+n-1; while(n--) &#123; *p-- &#x3D; *q--; &#125; &#125; return res;&#125; 来源于网上的测试用例 12345678910111213void Test()&#123; char p1[256] &#x3D; &quot;hello,world!&quot;; char p2[256] &#x3D; &#123;0&#125;; MyMemMove(p2,p1,strlen(p1)+1); printf(&quot;%s\\n&quot;,p2); MyMemMove(NULL,p1,strlen(p1)+1); MyMemMove(p2,NULL,strlen(p1)+1); MyMemMove(p1+1,p1,strlen(p1)+1); printf(&quot;%s\\n&quot;,p1); MyMemMove(p1,p1+1,strlen(p1)+1); printf(&quot;%s\\n&quot;,p1);&#125;","categories":[],"tags":[]},{"title":"strlen()函数和sizeof()运算符的区别","slug":"strlen()函数和sizeof()运算符的区别","date":"2018-03-29T11:41:08.000Z","updated":"2020-11-29T19:35:28.907Z","comments":true,"path":"2018/03/29/strlen()函数和sizeof()运算符的区别/","link":"","permalink":"http://example.com/2018/03/29/strlen()%E5%87%BD%E6%95%B0%E5%92%8Csizeof()%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"strlen函数原型size_t strlen(const char *string) size_t 是无符号整数的别名，在vs2008编译器中可以查看其宏定义 1typedef unsigned int size_t; 这样定义的原因一方面是字符串的长度不可能是负数，另一方面是不可能为实数。功能其功能是获取字符串的长度。返回值在MSDN文档中查看strlen函数的返回值，叙述如下。 Each of these functions returns the number of characters in string, excluding the terminal NULL. No return value is reserved to indicate an error. 每个函数都返回字符串中的字符数，不包括终端NULL。不保留返回值以指示错误。参数 1Null-terminated string 空终止字符串， 字符串标准库提供的头文件中包含操作以空字符结尾的字符串(null-terminated string)的函数。 sizeof（）运算符很对人以为sizeof是用来计算数据类型大小的一个函数，这其实是一个误区，它同加减乘除一样是运算符。 在MSDN文档查阅sizeof得到如下相关信息：sizeof Operatorsizeof expression The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type (including aggregate types). This keyword returns a value of type size_t. The expression is either an identifier or a type-cast expression (a type specifier enclosed in parentheses). When applied to a structure type or variable, sizeof returns the actual size, which may include padding bytes inserted for alignment. When applied to a statically dimensioned array, sizeof returns the size of the entire array. The sizeof operator cannot return the size of dynamically allocated arrays or external arrays. sizeof运算符运算符表达式sizeof关键字提供了与变量或类型(包括聚合类型)相关的存储空间。该关键字返回类型size_t的值。表达式要么是标识符，要么是类型转换表达式(括号中包含的类型说明符)。当应用到结构类型或变量时，sizeof返回实际大小，其中可能包括插入用于对齐的填充字节。当应用到静态尺寸数组时，sizeof返回整个数组的大小。sizeof运算符不能返回动态分配的数组或外部数组的大小。 了解了以上的相关知识，我们可以总结出两者不同。 下面用代码验证： 12345678910111213#include&lt;stdio.h&gt;#include &lt;string.h&gt;void main()&#123; char str1[10] &#x3D; &#123;&#39;h&#39;,&#39;e&#39;,0,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; char str2[10] &#x3D; &quot;he0llo&quot;; printf(&quot;%d\\n&quot;,sizeof(str1)); &#x2F;&#x2F;6 10 printf(&quot;%d\\n&quot;,sizeof(str2)); &#x2F;&#x2F;10 printf(&quot;%d\\n&quot;,strlen(str1)); &#x2F;&#x2F;6 2 printf(&quot;%d\\n&quot;,strlen(str2)); &#x2F;&#x2F;6&#125; 执行代码得到的结果如下：分析上图得到的结果，定义两个长度为10个字节的字符数组，由上文可知，sizeof(）运算符是计算整个数组的大小，所以输出均为10 而经过strlen计算字符串长度，由其函数特性，在str1数组中，当遇到第一个数字0是strlen函数就已经结束。所以输出的结果为2.在str2数组中，在字符串中有0的存在，但实际上这时的0为字符字符0（‘0’），并不是字符串结束的标志，知道遇到结尾的空字符，才进行返回。 大家也可自行验证。","categories":[],"tags":[]},{"title":"C语言不做数组下标安全性检查","slug":"C语言不做数组下标安全性检查","date":"2018-03-29T11:04:33.000Z","updated":"2020-11-29T19:35:29.171Z","comments":true,"path":"2018/03/29/C语言不做数组下标安全性检查/","link":"","permalink":"http://example.com/2018/03/29/C%E8%AF%AD%E8%A8%80%E4%B8%8D%E5%81%9A%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%9F%A5/","excerpt":"","text":"Ｃ语言的编译器是不检查下标越界的,以前知道这个问题,可是没有想过是什么原因? 总结如下: １,不检查下标是否越界可以有效提高程序运行的效率，因为如果你检查，那么编译器必须在生成的目标代码中加入额外的代码用于程序运行时检测下标是否越界，这就会导致程序的运行速度下降，所以为了程序的运行效率，C/C++才不检查下标是否越界。 ２,不检查下标是为了给程序员更大的空间，也为指针操作带来更多的方便。如果有这个检查的话指针的功能将会大大被削弱，C的数组标识符，里面并没有包含该数组长度的信息，只包含地址信息，所以语言本身无法检查，只能通过编译器检查，而早期的C语言编译器也不对数组越界进行检查，只能由程序员自己检查确保。以及在早期的CRT函数中也不对字符串指针或数组进行越界检查，都是要求程序员确保空间足够，因此也才也才有了在VS2005之后微软提供的安全的CRT函数版本。 自己写了一段检测程序测试这个问题，发现如果数组下标越界了，那么它会自动接着那块内存往后写。想了一下明白了，以前说不允许数组下标越界，并不是因为界外没有存储空间，而是因为界外的内容是未知的。也就是说如果界外的空间暂时没有被利用，那么我们可以占用那块内存，但是如果之前界外的内存已经存放了东西，那么我们越界过去就会覆盖那块内存，导致错误的产生。通用数组长度的计算 123456789101112int main()&#123; char p[] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;&#125;; int arr[] &#x3D; &#123;1,2,3,4,5&#125;; char *str[] &#x3D; &#123;&quot;hello&quot;,&quot;nihao&quot;,&quot;hehe&quot;&#125;; int len1 &#x3D; sizeof(p)&#x2F;sizeof(p[0]); int len2 &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); int len3 &#x3D; sizeof(str)&#x2F;sizeof(str[0]); printf(&quot;len1 &#x3D; %d,len2 &#x3D; %d,len3 &#x3D; %d\\n&quot;,len1,len2,len3);&#125; 通过这种办法，就可以计算出任意类型数组的长度，是一种通用的计算数组长度的方法。","categories":[],"tags":[]},{"title":"数组作为形参退化为指针","slug":"数组作为形参退化为指针","date":"2018-03-29T10:26:43.000Z","updated":"2020-11-29T19:35:29.195Z","comments":true,"path":"2018/03/29/数组作为形参退化为指针/","link":"","permalink":"http://example.com/2018/03/29/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E9%80%80%E5%8C%96%E4%B8%BA%E6%8C%87%E9%92%88/","excerpt":"","text":"#一个小程序进行验证 12345678910111213141516#include&lt;stdio.h&gt;void Sizeof(int arr[])&#123; printf(&quot;%d\\n&quot;,sizeof(arr));&#125;int main(void)&#123; int arr[] &#x3D; &#123;1,2,3,4,5&#125;; printf(&quot;传入Sizeof()函数进行计算:\\n&quot;); Sizeof(arr); printf(&quot;为传入Sizeof()函数直接在主函数中进行计算:\\n&quot;); printf(&quot;%d\\n&quot;,sizeof(arr));&#125; 在代码中可以看到，主函数与Sizeof函数执行了同样的计算。即计算数组的大小，但是结果却是始料未及的。出现这样的结果其原因就是在函数中，当数组作为形式参数进行传参时，其意义发生了变化。将其解析为一个指针，而指针的大小为四个字节。此时将数组作为一个指针类型进行计算。","categories":[],"tags":[]},{"title":"举例分析可变参数函数实现的过程","slug":"举例分析可变参数函数实现的过程","date":"2018-03-12T13:54:14.000Z","updated":"2020-11-29T19:35:29.187Z","comments":true,"path":"2018/03/12/举例分析可变参数函数实现的过程/","link":"","permalink":"http://example.com/2018/03/12/%E4%B8%BE%E4%BE%8B%E5%88%86%E6%9E%90%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/","excerpt":"","text":"求总和函数（可变参数形式） 123456789101112int average(int n,...)&#123; int sum; va_list args; va_start(args,n); for(int i &#x3D; 0;i&lt;n;++i) &#123; sum +&#x3D; va_arg(args,int); &#125; va_end(args); return sum;&#125; 1typedef char * va_list &#x2F;&#x2F;为char* 别名为va_list 函数栈调用对于C语言，其调用遵循_cdecl规则：1.所有参数从右到左依次入栈。2.这些参数由调用者清除，称为手动清除。3.被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。(简化的将就是调用参数的类型和数量不会产生编译阶段的错误) 以求和函数举例 1int sum &#x3D; sum(3,4,5,6); 三个宏宏定义 （1）va_start 1234#define va_start _crt_va_start#define _crt_va_start va_start(ap,v)#define va_start(ap,v) (ap &#x3D; (va_list)&amp;v + _INTSIZEOF(v)) #define _INTSIZEOF(v) ((sizeof(v) + sizeof(int) - 1) &amp; ~(sizeof(int)-1)) va_start宏的作用： 12#define va_start(ap,v) (ap &#x3D; (va_list)&amp;v + _INTSIZEOF(v)) ap &#x3D; (char*)&amp;v + (sizeof(v) + sizeof(int) - 1) &amp; ~(sizeof(int)-1); 参数类型： ap为va_list类型指针，即为char *,v是最后一个确定的参数。其含义是它之后的参数均为可变参数。 功能：获取可变参数中的第一个参数，并将其地址保存在ap中。 1#define _INTSIZEOF(v) ((sizeof(v) + sizeof(int) - 1) &amp; ~(sizeof(int)-1)) _INTSIZEOF(v)宏函数是为了对齐内存。 （2）va_arg 1#define va_arg(ap,t) (*(t*))(ap +&#x3D; _INTSIZEOF(t) - _INTSIZEOF(t)) va_arg宏的作用： 参数类型： ap为va_list类型的指针，即char，它指向当前需要获取的参数。t为当前参数的类型。 功能： 获取ap当前所指向参数的指针，并将其强制转化为 *t,并进行解引用 ,然后将ap指向可变参数表的下一个参数。 （3）va_end 12#define va_end(ap) (ap &#x3D; (va_list)0)ap &#x3D; (char*)0 &#x3D; NULL; va_end宏的作用： 参数类型： ap为va_list类型的指针 。 功能： 使指针指向空，不在使用该指针。防止ap成为野指针，进行错误引用。实际上通常va_start与va_end是配对使用。 了解并掌握以上三个宏的使用方法以及函数栈调用的规则后。 下面开始分析求和可变参数函数的实现过程： 123456789101112int average(int n,...) &#x2F;&#x2F;...表示参数的类型和数量不确定 n表示传入参数的个数&#123; int sum; va_list args; &#x2F;&#x2F;相当于定义 char *p; va_start(args,n); &#x2F;&#x2F;获取可变参数列表中的第一个参数的地址并保存在p内 va_start（p,n） for(int i &#x3D; 0;i&lt;n;++i) &#123; sum +&#x3D; va_arg(args,int); &#125; va_end(args); &#x2F;&#x2F; 等价于*p &#x3D; NULL; return sum;&#125;","categories":[],"tags":[]},{"title":"printf函数的返回值！","slug":"printf函数的返回值！","date":"2018-03-12T07:41:00.000Z","updated":"2020-11-29T19:35:29.195Z","comments":true,"path":"2018/03/12/printf函数的返回值！/","link":"","permalink":"http://example.com/2018/03/12/printf%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%81/","excerpt":"","text":"printf函数原型 1int printf(const char * p,...); 返回值返回值为整型，是输出字符的个数，即格式化字符串中字符的个数。 举例 123456int main（）&#123; int count &#x3D; printf(&quot;ni hao csdn,%d\\n&quot;,111); &#x2F;&#x2F;这里的格式化字符串包括逗号、空格、换行符、字母及数字共计16个字符 printf(&quot;n &#x3D; %d\\n&quot;,n);&#125; 输出结果 1n &#x3D; 16; 来自阿里的一个面试题 1234int main（）&#123; printf(&quot;%d\\n&quot;,printf(&quot;%d\\n&quot;,printf(&quot;hello!\\n&quot;))); &#125; 这样的题目第一眼看上去有一点懵，其实它考的就是printf函数的返回值，及输出字符的个数。输出结果 123456789&#x2F;&#x2F;由内而外依次分析printf(&quot;hello!\\n&quot;);&#x2F;&#x2F;在屏幕上输出hello！并进行换行，其返回值为7。printf(&quot;%d\\n&quot;,printf(&quot;hello!\\n&quot;));&#x2F;*由上一步可以知道其实 printf(&quot;hello!\\n&quot;) &#x3D;&#x3D; 7 所以输出7并进行换行*&#x2F;printf(&quot;%d\\n&quot;,printf(&quot;%d\\n&quot;,printf(&quot;hello!\\n&quot;)));&#x2F;&#x2F;尽管这一行很长，但是经过简化，他可以这样表示printf(&quot;%d\\n&quot;,2);&#x2F;&#x2F;因为printf(&quot;%d\\n&quot;,printf(&quot;hello!\\n&quot;))的返回值为2","categories":[],"tags":[]},{"title":"C语言 实现浮点数的整型强制转化","slug":"C语言 实现浮点数的整型强制转化","date":"2018-03-11T12:09:36.000Z","updated":"2020-11-29T19:35:29.195Z","comments":true,"path":"2018/03/11/C语言 实现浮点数的整型强制转化/","link":"","permalink":"http://example.com/2018/03/11/C%E8%AF%AD%E8%A8%80%20%E5%AE%9E%E7%8E%B0%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%8C%96/","excerpt":"","text":"1.整型在内存中的存储形式 int 与 float 均是四个字节大小，即32位，但是他们在内存中的存储形式却是完全不相同的。 下面举一个例子，在vs下通过查看内存验证一下以上的事实。1.1 int a = 12; 由于是正数，所以符号位取0。 (12) = 1010B 所以其在内存中存储形式为 0101 0000 0000 0000 0000 0000 0000 0000为了方便计算16进制数，将4位二进制数列为一组进行表示。在监视窗口找到a的地址。通过地址查看该地址存储的信息。将其展开 0000 1010 0000 0000 0000 0000 0000 00002.单精度浮点数在内存在内存的储存举例 float b = 12.125; 在监视窗口找到b的地址 通过b的地址，查看一下b在内存中的存储形式。 可见，b在内存中4字节是按照 00 00 42 41存储，因为我的机器是小端模式，所以真正的存储形式是 41 42 00 00。接下来分析一下这32个位都是什么，大家都知道二进制的四位可以用十六进制的1位表示。 关于浮点数的由十进制到二进制的转换大家一定也清楚，整数部分除二取余，小数部分乘二取整。最后的结果是：12.125（10） = 1100.001（2） 浮点数共计占内存4个字节，即32位。这32位是按照这样的规则存储的： （1）一位符号位 整数为0 负数1。用0，1将符号数字化，因为计算机是不懂正负号，而0和1恰恰可以表示这两种状态。 （2）指数位八位比如 float a = 12.125(10) = 1100.001(2)其实就是科学计数法表示， 1.2125 * 10^1 (10) = 1.1100001 * 2^3所在其指数位就为 exp = 3,但是实际计算机在存储的过程中还给指数位加了一个偏移常数127，所以指数为最终的结果是130。以二进制表示就是1000 0010。 （3）由二步骤可以知道12.125尾数为1.1100001,但是可以联想一下，任意一个单精度类型的数据转化成科学计数法的二进制数都是1.xxxxxxxxxx，因此实际上在存储中将第一位的略去不表示，这样一来。其实在尾数位，我们用23位保存了24的数据，这样进度就提高了一位。 由上图可知，这样的事实成功的被验证了。 洋洋洒洒，废话连篇。真正转化现在开始，了解了前面的知识，我们就知道了浮点数是如何计算机中存储的，将其转换成整型无非就是取到它的整数部分即可。 下面实现这样的一个单精度浮点数到整型的强转函数: 12345678910111213141516171819202122232425262728293031323334int float_to_int(float f)&#123; int *p &#x3D; (int*)&amp;f; &#x2F;&#x2F;由于指针访问内存是按照基类型进行的，首先进行强转访问浮点数f int temp &#x3D; *p; &#x2F;&#x2F;用中间变量接受f的值 &#x2F;&#x2F;提取符号位 int sign &#x3D; -1; if((temp &amp; 0x80000000) &#x3D;&#x3D; 0) &#123; sign &#x3D; 1; &#125; &#x2F;&#x2F;条件表达式中进行了位与运算，其实就是提取指数位的值。前面已经讲过了，符号位为0，其为正值。若为1，其为负值。 &#x2F;&#x2F;提取指数位 int exp; exp &#x3D; ( ( (temp &gt;&gt; 23) &amp; 0x0ff ) ) - 127; &#x2F;&#x2F;由于在存储的时候指数位加了偏置常数 现在相当于是计算指数位的逆过程 所以自然要减去 &#x2F;&#x2F;提取尾数位 int tail; tail &#x3D; ( ( temp &amp; 0x007fffff ) | 0x00800000 ); &#x2F;*和之前提取指数位和符号位的方法是一致的，要提取哪几位，在对应的位进行与1运算就可以了 现在我们要提取的是除符号位和指数位共计九位的其他23，即尾数为。只需要在对应的为与1即可*&#x2F; &#x2F;*还记得在存储尾数的时候，因为任意一个单精度的二进制数以科学记数法表示时，第一位都是1， 所以存储的时间，为了能够提高精度，省略了改位。但是现在是在进行他的逆过程，所以我们要在 要进行或1位运算*&#x2F; int res &#x3D; (tail &gt;&gt; (23 - exp)); return res * sign;&#125; 1234567&#x2F;&#x2F;进行验证int main（）&#123; float a &#x3D; 12.125; &#x2F;&#x2F;a &#x3D; -12.125 a &#x3D; 0.05 a &#x3D; -0.05 int b &#x3D; float_to_int(a); printf(&quot;b &#x3D; %d\\n&quot;,b);&#125; 大家也可自行验证，但是美中不足的是这样强转函数存在缺点，就是当我们将浮点数0传入函数进行强转，其结果却差强人意。（关于这点，目前还在测试，一定会有一个满意的解释的） 写到这里，差不多结束了，其实双精度浮点数的强转时类似，只要能完全掌握双精度浮点数在内存中的存数形式。","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://example.com/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"Windows操作系统下使用环境变量打开应用程序","slug":"Windows操作系统下使用环境变量打开应用程序","date":"2018-02-19T13:32:43.000Z","updated":"2020-11-29T19:35:29.191Z","comments":true,"path":"2018/02/19/Windows操作系统下使用环境变量打开应用程序/","link":"","permalink":"http://example.com/2018/02/19/Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"环境变量 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。 —-来之百度百科的解释Environment variables are a set of dynamic named values that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs. —- 来着维基百科的解释 其实通俗的讲环境变量就是路径，，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。 下面以添加TIM的环境变量为例学习使用Windows下的环境变量： （我的操作系统是win10，其实大同小异） 1.右击此电脑，点击属性。 2.在右上角点击高级系统设置，出现如下对话框。 3.点击右下角环境变量，出现如下对话框。 这是我们可以看见两种不同的环境变量，即用户变量和系统变量。他们之间的区别在于用户变量仅仅对该用户提供支持，而系统变量是对所有用户提供支持的，所以在设置的时候可以根据情况自行选择二者之一。 4.我以用户变量举例，点击新建。 5.输入变量名和变量值（即路径） 假设变量名为 ： path 那么怎样设置变量值呢？这是重点，以TIM举例。 （1）找到后缀为.exe的可执行文件所在的文件夹。 （2）点击当前文件所在位置的空白处即可得到绝对路径。 即得到环境变量的变量值。 6.拷贝到变量值所在一栏，点击确定。 至此就将TIM添加到环境变量中，下面验证是否添加成功。 7.键盘组合键 win+R 打开运行窗口,输入TIM即可成功运行TIM。8.同时也可以在命令提示符中输入TIM，运行程序。小伙伴们赶快去试试吧！","categories":[],"tags":[]},{"title":"局部变量的作用域和生存周期","slug":"局部变量的作用域和生存周期","date":"2018-02-12T14:08:11.000Z","updated":"2020-11-29T19:35:29.183Z","comments":true,"path":"2018/02/12/局部变量的作用域和生存周期/","link":"","permalink":"http://example.com/2018/02/12/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/","excerpt":"","text":"变量定义的三种情况（1）在函数开头定义（2）在函数的内部定义（3）在复合语句块内部定义 局部变量定义在函数内部的变量只能在函数内部引用，同样定义在复合语句块中的变量只是在复合语句块内有效。将这种变量称为“局部变量”，顾名思义，这些变量的作用域仅仅是在函数内部或复合语句块内。 1&#x2F;&#x2F;复合语句块的局部变量举例 12345678910# include&lt;stdio.h&gt;int main()&#123; int s &#x3D; 10; &#123; int i &#x3D;1; &#125; s +&#x3D; i; printf(&quot;%d\\n&quot;，s);&#125; 这样的代码在编译的时候就会报错，因为我们在复合语句块内定义一个 整型 i = 1，其作用域是复合语句块内，若我们想在复合语句块外用引用该变量是不可行的。变量i只在复合语句块内有效，离开该复合语句块变量就失效，系统会把它占用的内存释放掉。 1&#x2F;&#x2F;[Error] &#39;i&#39; was not declared in this scope 这是一个错误提示信息，编译器说 i 这个变量没有声明。 1&#x2F;&#x2F;定义在函数内部的局部变量 1234567891011121314# include&lt;stdio.h&gt;int func(int n)&#123; int i &#x3D; 10; return n;&#125;int main()&#123; int n &#x3D; 10; printf(&quot;%d\\n&quot;,func(n)); printf(&quot;%d\\n&quot;,i);&#125; 现在我们定义了一个 返回值为整型func(int n)函数，其功能是我传入一个整型数，其返回值是原值。但在主函数中，我想输出定义在func()函数内部局部变量i的值。同样是不可行的，编译器在编译的的时候就会报错。但是在不同的函数中可以定义同名的变量，因为他们代表不同的对象，互不干扰。 1&#x2F;&#x2F;[Error] &#39;i&#39; was not declared in this scope 1&#x2F;&#x2F;错误提示同我们在复合语句块中引用局部变量是相同的。 上述例子虽然简单，但是也直白直观的感受到局部变量的作用域和生命周期。我们在实际写代码的过程中，一定要注意局部变量的引用。","categories":[],"tags":[]},{"title":"break和contiue的区别","slug":"break和contiue的区别","date":"2018-01-30T05:02:37.000Z","updated":"2020-11-29T17:53:13.104Z","comments":true,"path":"2018/01/30/break和contiue的区别/","link":"","permalink":"http://example.com/2018/01/30/break%E5%92%8Ccontiue%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.continuecontinue语句形式如下： continue; continue语句用于循环结构（包括while(当型循环)、do while（直到型循环）和 for循环）， continue作为循环结构中循环体的一部分。在程序执行的过程中，一旦遇到了continue语句， 立即结束本次循环。跳过循环体中尚未执行的部分，接着进行是否继续循环的条件判断。 2.breakbreak语句的形式如下 break; break语句大多数用于switch…case..。语句的分支语句中，在程序执行的过程中，一旦遇到了 break语句，立即退出当前的switch语句。 同时，break语句可以用于循环结构中，作为循环结构中循环体的一部分。在程序执行的过程， 一旦遇到break语句，立即退出当前的循环体，接着执行循环体之后的语句。 3.continue和break的区别 通过对比break和continue语句在循环结构中的使用，不难发现，continue语句只是结束本次 循环，不在执行循环体continue后边的语句，并不是终止当前循环。而break语句是直接结束 本次循环。 下面用一个简单的例子验证一下：1.continue 123456789101112131415# include&lt;stdio.h&gt;void main()&#123; int arr[]=&#123;1,2,3,4,5&#125;; int len=sizeof(arr)/sizeof(arr[0]); for(int i=0;i&lt;len;++i) &#123; if(arr[i]==4) &#123; continue; &#125; printf(&quot;%d &quot;,arr[i]); &#125;&#125; 运行结果为: 2.break 123456789101112131415# include&lt;stdio.h&gt;void main()&#123; int arr[]=&#123;1,2,3,4,5&#125;; int len=sizeof(arr)/sizeof(arr[0]); for(int i=0;i&lt;len;++i) &#123; if(arr[i]==4) &#123; break; &#125; printf(&quot;%d &quot;,arr[i]); &#125;&#125; 运行结果为： 实际上在continue和break语句在具体程序中的使用，往往可以在较大程度上减少时间复杂度，减小程序运行时间。","categories":[],"tags":[{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"break和continue的区别","slug":"break和continue的区别","date":"2018-01-30T05:02:37.000Z","updated":"2020-11-29T19:35:29.199Z","comments":true,"path":"2018/01/30/break和continue的区别/","link":"","permalink":"http://example.com/2018/01/30/break%E5%92%8Ccontinue%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.continue continue语句形式如下： continue; continue语句用于循环结构（包括while(当型循环)、do&nbsp; &nbsp;while（直到型循环）和 for循环）， continue作为循环结构中循环体的一部分。在程序执行的过程中，一旦遇到了continue语句， 立即结束本次循环。跳过循环体中尚未执行的部分，接着进行是否继续循环的条件判断。 2.break; break语句的形式如下 break; break语句大多数用于switch...case..。语句的分支语句中，在程序执行的过程中，一旦遇到了 break语句，立即退出当前的switch语句。 同时，break语句可以用于循环结构中，作为循环结构中循环体的一部分。在程序执行的过程， 一旦遇到break语句，立即退出当前的循环体，接着执行循环体之后的语句。 3.continue和break的区别 通过对比break和continue语句在循环结构中的使用，不难发现，continue语句只是结束本次 循环，不在执行循环体continue后边的语句，并不是终止当前循环。而break语句是直接结束 本次循环。 下面用一个简单的例子验证一下： 1.continue # include&lt;stdio.h&gt; void main(){ int arr[]={1,2,3,4,5}; int len=sizeof(arr)/sizeof(arr[0]); for(int i=0;i&lt;len;&#43;&#43;i) { if(arr[i]==4) { continue; } printf(&quot;%d &quot;,arr[i]); }}运行结果为： 2.break # include&lt;stdio.h&gt; void main(){ int arr[]={1,2,3,4,5}; int len=sizeof(arr)/sizeof(arr[0]); for(int i=0;i&lt;len;&#43;&#43;i) { if(arr[i]==4) { break; } printf(&quot;%d &quot;,arr[i]); }}运行结果为： 实际上在continue和break语句在具体程序中的使用，往往可以在较大程度上减少时间复杂度，减小程序运行时间。","categories":[],"tags":[]},{"title":"震惊！三天打鱼两天筛网这样写","slug":"震惊！三天打鱼两天筛网这样写","date":"2018-01-21T10:20:17.000Z","updated":"2020-11-29T17:19:05.454Z","comments":true,"path":"2018/01/21/震惊！三天打鱼两天筛网这样写/","link":"","permalink":"http://example.com/2018/01/21/%E9%9C%87%E6%83%8A%EF%BC%81%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E7%AD%9B%E7%BD%91%E8%BF%99%E6%A0%B7%E5%86%99/","excerpt":"","text":"原题目：有一个人从1990年一月一日开始三天打鱼两天晒网，问他今天在干嘛？ 拿到这样的一个题目瞬间会有一点懵，但是仔细分析其中的逻辑关系，可以得到下面的思路。 首先，从1990年1月1日到今天共计多少天。 其次，如何得到今天是打渔还是晒网，可以看出三天打鱼两天晒网是一个循环，也就是是说五天为一个周期。 顺着这样的一个思路，我们开始写代码。 1.针对一个具体的日期，我们需要知道是何年何月何日。因此，在C语言中的结构题类型就可以满足定义这样一个具体日期。 1234567typedef struct &#123; int year; int month; int day;&#125;data; 2.接着我们要计算1990年1月1日到今天为止总计为多少天。考虑到要计算天数，我们要细化日期的内容。对于年，有平年和闰年之分，平年365天，闰年366天，这都是常识。对于月，定义这样的一个平年通用型的数组比较贴切。 定义长度为13且Permonth[0]=0,这样下标与月份一致，便于计算。 1int Permonth[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; 如果今年刚好不是闰年，我们只要计算出这个月前今年的总天数加上这个月的天数就可以了。但是如果是闰年我们还需要继续划分，如果是二月前，同上。如果月份大于三，我们还是需要在二月天数的基础上增加一。即Permonth[2]+=1; 3.二步骤虽然略麻烦一点，但为三步骤提供了思路。C语言就是函数（function）构成的，一个大的功能往往也可以分解为多个子功能去合作完成，也正所谓模块化程序设计。这样，首先我们写一个判断平闰年的函数，在这样的一个题目里，它得到两次使用。 1234567891011121314151617181920bool is_leapyear(int year)&#123; if(year&lt;0) &#123; printf(&quot;输入错误!&quot;); &#125; else &#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0)//判断为闰年核心 &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 接下来我们写总天数的函数 123456789101112131415161718192021222324252627void countday(date *p,int *sum)//传入结构题的地址，并传入保存总天数值的地址&#123; int permonth[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; int totalday=0; for(int year=1990;year&lt;p-&gt;year;++year) &#123; if(is_leapyear(p-&gt;year)) &#123; totalday+=366; &#125; else &#123; totalday+=365; &#125; &#125; if(is_leapyear(p-&gt;year)) &#123; permonth[2]+=1; &#125; for(int i=0;i&lt;p-&gt;month;++i) &#123; totalday+=permonth[i]; &#125; totalday+=p-&gt;day; *sum=totalday;&#125; 到此为止，我们就把从1990年1月1日到今天的总天数计算出来了。4.总天数计算出来后，因为三天打渔两天晒网，五天即一个循环，所以总天数对5取模。结果为4和0时，即为晒网。结果为1，2，3时，即为打渔。5.考虑程序的冗余性，输入的具体日期完全可能出现意料之外的情况，因此也需要考虑在内。 最后，附上源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# include&lt;stdio.h&gt; typedef struct &#123; int year; int day; int month;&#125;date;void init_date(date *p)&#123; p-&gt;day=0; p-&gt;month=0; p-&gt;year=0;&#125;bool is_leapyear(int year)&#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; return true; &#125; else &#123; return false; &#125;&#125;void countday(date *p,int *sum)&#123; int permonth[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; int totalday=0; for(int year=1990;year&lt;p-&gt;year;++year) &#123; if(is_leapyear(p-&gt;year)) &#123; totalday+=366; &#125; else &#123; totalday+=365; &#125; &#125; if(is_leapyear(p-&gt;year)) &#123; permonth[2]+=1; &#125; for(int i=0;i&lt;p-&gt;month;++i) &#123; totalday+=permonth[i]; &#125; totalday+=p-&gt;day; *sum=totalday;&#125;int main()&#123; date l; init_date(&amp;l); printf(&quot;请输入今天是几年几月几日：\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;l.year,&amp;l.month,&amp;l.day); printf(&quot;\\n&quot;); int s; //用来接收总天数 countday(&amp;l,&amp;s); if(s%5==4||s%5==0) &#123; printf(&quot;今天晒网！&quot;); &#125; else &#123; printf(&quot;今天打渔！&quot;); &#125; &#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"c/c++","slug":"c-c","permalink":"http://example.com/categories/c-c/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构 java Leetcode","slug":"数据结构-java-Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-java-Leetcode/"},{"name":"c/c++ 趣味编程 算法基础","slug":"c-c-趣味编程-算法基础","permalink":"http://example.com/categories/c-c-%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"c/c++ 数据结构 算法基础","slug":"c-c-数据结构-算法基础","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"数据结构 算法基础 Leetcode","slug":"数据结构-算法基础-Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"},{"name":"c/c++ 算法基础 Leetcode","slug":"c-c-算法基础-Leetcode","permalink":"http://example.com/categories/c-c-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"},{"name":"c/c++ 数据结构 Leetcode","slug":"c-c-数据结构-Leetcode","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Leetcode/"},{"name":"数据结构 算法基础","slug":"数据结构-算法基础","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"c/c++ 数据结构","slug":"c-c-数据结构","permalink":"http://example.com/categories/c-c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"高等数学","slug":"高等数学","permalink":"http://example.com/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"PAT乙级题解","slug":"PAT乙级题解","permalink":"http://example.com/categories/PAT%E4%B9%99%E7%BA%A7%E9%A2%98%E8%A7%A3/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"linux 操作系统","slug":"linux-操作系统","permalink":"http://example.com/categories/linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"趣味编程 算法基础","slug":"趣味编程-算法基础","permalink":"http://example.com/categories/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"趣味编程","slug":"趣味编程","permalink":"http://example.com/categories/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B/"},{"name":"数据结构 图论","slug":"数据结构-图论","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"PAT甲级题解","slug":"PAT甲级题解","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3/"},{"name":"PAT甲级题解 图论","slug":"PAT甲级题解-图论","permalink":"http://example.com/categories/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E8%A7%A3-%E5%9B%BE%E8%AE%BA/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"数据结构 java","slug":"数据结构-java","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-java/"},{"name":"算法基础 Leetcode","slug":"算法基础-Leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-Leetcode/"},{"name":"编程练习","slug":"编程练习","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"c++ c++11","slug":"c-c-11","permalink":"http://example.com/tags/c-c-11/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构 算法","slug":"数据结构-算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"},{"name":"leetcode c++","slug":"leetcode-c","permalink":"http://example.com/tags/leetcode-c/"},{"name":"动态规划 算法 leetcode","slug":"动态规划-算法-leetcode","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95-leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"1024程序员节","slug":"1024程序员节","permalink":"http://example.com/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/"},{"name":"1024程序员节 c++","slug":"1024程序员节-c","permalink":"http://example.com/tags/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82-c/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"linux系统编程","slug":"linux系统编程","permalink":"http://example.com/tags/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"c语言","slug":"c语言","permalink":"http://example.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]}